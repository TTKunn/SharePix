# 关注功能测试问题汇总报告

**测试日期**: 2025-10-17  
**测试人员**: Claude AI  
**问题严重性**: 🔴 高危 - 服务崩溃  

---

## 🚨 严重问题发现

### 问题1: 服务在处理登录请求后崩溃

**问题描述**:
- 服务启动正常，路由注册成功（包括"Follow routes registered"）
- 健康检查接口`/health`工作正常
- **当发送登录请求`POST /api/v1/auth/login`后，服务立即崩溃**

**崩溃时间线**:
1. `13:12:33` - 服务启动成功
2. `13:12:34` - 健康检查成功（GET /health - 200）
3. `13:13:59` - 收到登录请求（POST /api/v1/auth/login）
4. `13:13:59` - 日志显示"Handling login request"和"User login attempt: testuser"
5. **之后服务进程消失，没有更多日志输出**

**服务日志（崩溃前最后20行）**:
```
[2025-10-17 13:12:33.100] [info] [thread 149609] Initializing HTTP server on 0.0.0.0:8080
[2025-10-17 13:12:33.101] [info] [thread 149609] Auth routes registered
[2025-10-17 13:12:33.101] [info] [thread 149609] Image routes registered
[2025-10-17 13:12:33.101] [info] [thread 149609] LikeHandler routes registered
[2025-10-17 13:12:33.101] [info] [thread 149609] FavoriteHandler routes registered
[2025-10-17 13:12:33.101] [info] [thread 149609] Follow routes registered
[2025-10-17 13:12:33.101] [info] [thread 149609] PostHandler routes registered
[2025-10-17 13:12:33.101] [info] [thread 149609] Auth wildcard routes registered
[2025-10-17 13:12:33.120] [info] [thread 149609] Static files configured successfully
[2025-10-17 13:12:33.120] [info] [thread 149609] HTTP server initialized successfully
[2025-10-17 13:12:33.120] [info] [thread 149609] Starting HTTP server...
[2025-10-17 13:12:34.332] [info] [thread 149616] Request: GET /health
[2025-10-17 13:12:34.416] [info] [thread 149616] Response: 200 for GET /health
[2025-10-17 13:13:59.411] [info] [thread 149617] Request: POST /api/v1/auth/login
[2025-10-17 13:13:59.411] [info] [thread 149617] Handling login request
[2025-10-17 13:13:59.411] [info] [thread 149617] User login attempt: testuser
（服务崩溃，没有更多日志）
```

---

## 🔍 问题排查分析

### 1. 数据库变更回顾

**今天进行的数据库变更**:

#### 1.1 创建`follows`表
```sql
CREATE TABLE follows (
  id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '物理ID（自增主键）',
  follower_id BIGINT NOT NULL COMMENT '关注者ID',
  followee_id BIGINT NOT NULL COMMENT '被关注者ID',
  create_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '关注时间',
  
  UNIQUE KEY uk_follower_followee (follower_id, followee_id),
  KEY idx_follower_create (follower_id, create_time DESC),
  KEY idx_followee_create (followee_id, create_time DESC),
  
  CONSTRAINT fk_follows_follower FOREIGN KEY (follower_id) REFERENCES users (id) ON DELETE CASCADE,
  CONSTRAINT fk_follows_followee FOREIGN KEY (followee_id) REFERENCES users (id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

**验证结果**: ✅ 表创建成功，结构正确

#### 1.2 扩展`users`表
```sql
ALTER TABLE users ADD COLUMN following_count INT NOT NULL DEFAULT 0 COMMENT '关注数';
ALTER TABLE users ADD COLUMN follower_count INT NOT NULL DEFAULT 0 COMMENT '粉丝数';
```

**验证结果**: ✅ 字段添加成功，现有用户的值都是0

**数据库状态检查**:
```bash
mysql> SELECT id, user_id, username, following_count, follower_count FROM users LIMIT 5;
+----+-------------------+-----------+-----------------+----------------+
| id | user_id           | username  | following_count | follower_count |
+----+-------------------+-----------+-----------------+----------------+
|  1 | USR_ADMIN_001     | admin     |               0 |              0 |
|  2 | USR_2025Q4_38TiLL | testuser  |               0 |              0 |
|  3 | USR_2025Q4_Z35Gd6 | testuser5 |               0 |              0 |
|  4 | USR_2025Q4_2EEN3F | 123       |               0 |              0 |
|  5 | USR_2025Q4_GP2JHH | zhangsan  |               0 |              0 |
+----+-------------------+-----------+-----------------+----------------+
```

### 2. 可能的崩溃原因分析

#### ❓ 原因猜测1: `User`模型未更新字段
**问题**: `user_repository.cpp`从数据库读取用户数据时，可能没有处理新增的`following_count`和`follower_count`字段

**影响**: 
- 登录时需要查询用户数据
- 如果`buildUserFromStatement`没有正确绑定这两个新字段，可能导致内存访问错误

**需要检查**: 
- `src/database/user_repository.cpp`中的`buildUserFromStatement`方法
- 是否正确绑定了所有字段（包括新增的两个）

#### ❓ 原因猜测2: `User`模型类定义未更新
**问题**: `src/models/user.h`和`user.cpp`中可能没有添加`following_count`和`follower_count`成员变量

**影响**:
- JSON序列化/反序列化可能失败
- 字段访问越界

**需要检查**:
- `src/models/user.h` - 是否有这两个字段的声明
- `src/models/user.cpp` - 是否有getter/setter和toJson方法

#### ❓ 原因猜测3: SQL查询语句未更新
**问题**: 某些SQL查询使用`SELECT *`可能返回了额外的字段，但代码没有处理

**需要检查**:
- 所有`SELECT * FROM users`的查询
- 结果集绑定是否完整

---

## 📝 测试状态

### 完成的测试
- ✅ 服务编译成功
- ✅ 服务启动成功
- ✅ 路由注册成功（包括Follow routes）
- ✅ 健康检查接口正常
- ✅ 数据库连接正常
- ✅ 数据库表结构正确

### 未完成的测试（因服务崩溃无法进行）
- ❌ 用户登录
- ❌ 关注用户功能
- ❌ 取消关注功能
- ❌ 检查关注关系
- ❌ 获取关注列表
- ❌ 获取粉丝列表
- ❌ 获取用户统计
- ❌ 批量检查关注

---

## 🔧 建议的修复步骤

### 步骤1: 检查User模型定义
检查文件：`src/models/user.h`和`src/models/user.cpp`

需要确认：
1. 是否有`following_count`和`follower_count`成员变量
2. 是否有对应的getter/setter方法
3. `toJson()`方法是否包含这两个字段

### 步骤2: 检查UserRepository的字段绑定
检查文件：`src/database/user_repository.cpp`

需要确认`buildUserFromStatement`方法：
1. MYSQL_BIND数组大小是否正确（应该增加2）
2. 是否正确绑定了`following_count`和`follower_count`
3. 是否正确设置到User对象

### 步骤3: 检查所有SELECT查询
搜索所有查询users表的SQL语句，确保：
1. 如果使用`SELECT *`，结果集绑定要完整
2. 如果列出字段，要包含新增的两个字段（需要的话）

### 步骤4: 添加崩溃日志
在可能的崩溃点添加更详细的日志：
- UserRepository::buildUserFromStatement开始和结束
- 每个字段绑定前后
- User对象创建和初始化

---

## 🎯 下一步行动

1. **立即检查**User模型和UserRepository代码
2. **修复**发现的字段绑定问题
3. **重新编译**并测试
4. **如果问题解决**，继续完整测试所有关注功能
5. **记录所有发现的问题**，更新此文档

---

## 💡 用户反馈确认

用户指出："我发现原本没有问题的，似乎你改完数据库就有问题了"

**结论**: 
- ✅ 用户判断正确
- ✅ 问题确实是在添加`following_count`和`follower_count`字段后出现的
- ✅ 数据库结构本身没有问题
- ❌ 代码层面未同步更新导致崩溃

**根本原因**: 数据库schema变更后，应用层代码（特别是User模型和UserRepository）没有同步更新以处理新字段，导致在读取用户数据时出现内存访问错误或数据绑定失败。

---

---

## ✅ 修复完成

### 修复内容
1. **User模型**添加缺失字段
   - `user.h`: 添加 `followingCount_` 和 `followerCount_` 成员变量
   - `user.h`: 添加 getter/setter 方法
   - `user.cpp`: 在构造函数中初始化为0
   - `user.cpp`: 在`toJson()`中添加这两个字段

2. **UserRepository字段绑定修复**
   - 将`MYSQL_BIND result[17]`改为`result[19]`
   - 添加`int followingCount`和`int followerCount`变量声明
   - 添加`result[17]`和`result[18]`的绑定配置
   - 在`buildUserFromStatement`中设置这两个字段到User对象

### 测试结果
✅ **编译成功**
✅ **服务启动正常**  
✅ **健康检查通过**  
✅ **注册功能正常** - user_b和user_c注册成功
✅ **登录功能正常** - 不再崩溃，可以正常返回错误或成功
✅ **User字段完整** - 返回数据包含`following_count`和`follower_count`

示例输出：
```json
{
  "data": {
    "id": 28,
    "user_id": "USR_2025Q4_odP7lb",
    "username": "user_b",
    "following_count": 0,  // ✅ 新增字段
    "follower_count": 0,   // ✅ 新增字段
    ...
  }
}
```

---

## ⚠️ 新发现问题

### 问题2: 关注API返回400但无详细错误日志

**问题描述**:
- POST /api/v1/follow/28 返回 400 Bad Request
- 响应体为空（Content-Length: 0）
- 日志中只有请求和响应记录，无详细错误信息

**日志记录**:
```
[2025-10-17 13:22:42.268] [info] Request: POST /api/v1/follow/28
[2025-10-17 13:22:47.274] [info] Response: 400 for POST /api/v1/follow/28
```

**可能原因**:
1. `FollowHandler`可能未正确处理请求
2. JWT验证失败但未记录日志
3. 路由匹配问题
4. 响应构建问题

**下一步调查**:
- 检查`FollowHandler::handleFollow`的实现
- 检查JWT验证逻辑和日志
- 验证路由注册是否正确
- 添加更详细的错误日志

---

## ✅ 问题2修复尝试

### 修复内容
发现`FollowHandler`中使用了错误的JWT字段名：
- **问题**: 使用`tokenData["user_id"]`获取用户ID
- **实际**: JWT Token中用户ID存储在`"subject"`字段
- **修复**: 将所有`tokenData["user_id"].asInt64()`改为`std::stoll(tokenData["subject"].asString())`

**JWT Token结构**:
```json
{
  "iss": "shared-parking-auth",
  "sub": "29",  // ← 用户ID在这里（subject）
  "username": "user_c",
  "iat": 1760678738,
  "exp": 1760682338
}
```

### 测试结果
❌ **问题未完全解决**

虽然字段名已修复，但关注API仍然返回400错误，且出现新症状：
- 请求到达服务器
- **响应时间异常长（约5秒）**
- 返回400 Bad Request且无响应体
- 日志中无详细错误信息

**日志记录**:
```
[2025-10-17 13:25:52.587] Request: POST /api/v1/users/28/follow
[2025-10-17 13:25:57.590] Response: 400 for POST /api/v1/users/28/follow
```

---

## 📊 当前状态总结

### ✅ 已修复的问题
1. ✅ **User模型字段缺失** - 已添加`following_count`和`follower_count`
2. ✅ **UserRepository字段绑定** - MYSQL_BIND数组从17个扩展到19个
3. ✅ **服务崩溃问题** - 登录功能恢复正常
4. ✅ **JWT字段名错误** - 修复为使用`"subject"`字段

### ❌ 未解决的问题
1. ❌ **关注API返回400且响应缓慢（5秒）**
   - 可能原因：
     - Service层逻辑错误
     - 数据库查询超时
     - 异常未被正确捕获和记录
     - 需要添加更详细的日志才能定位

### 📝 建议下一步操作
1. **添加详细日志**到`FollowService`和`FollowRepository`
2. **检查数据库连接**和查询性能
3. **验证follows表**的索引和外键约束
4. **测试用户ID的格式**（物理ID vs 逻辑ID）

---

---

## 🔬 问题2深入调查（进行中）

### 调查步骤

1. **添加详细日志**到`FollowService`和`FollowHandler`
2. **修复用户ID查询逻辑** - 支持物理ID和逻辑ID双模式查询
3. **编译并部署新版本** - 确认日志字符串在二进制文件中
4. **重新测试**

### 关键发现

#### ✅ 发现1: 用户ID类型不匹配
- **问题**: API路径`/api/v1/users/28/follow`中的`28`是物理ID
- **Service期望**: `findByUserId()`查询的是逻辑ID字段（`USR_xxx`）
- **修复**: 添加双模式查询逻辑，优先尝试物理ID，失败则尝试逻辑ID

#### ✅ 发现2: GET请求正常，POST请求异常
- **测试结果**:
  - `GET /api/v1/users/28/followers` → ✅ 200 OK（返回正确数据）
  - `POST /api/v1/users/28/follow` → ❌ 400 Bad Request（耗时5秒，无响应体）
  
#### ❌ 发现3: 日志未出现
- **预期**: `handleFollow`方法开头的`Logger::info("FollowHandler::handleFollow called")`应该出现
- **实际**: 日志完全没有出现
- **确认**: 使用`strings`命令确认日志字符串已在二进制文件中
- **结论**: `handleFollow`方法根本未被调用！

### 可能原因分析

1. **路由匹配问题**
   - cpp-httplib的POST路由可能与GET路由有冲突
   - 路径参数`:user_id`可能解析失败

2. **HTTP方法不匹配**
   - 可能有其他中间件拦截了POST请求
   - 可能OPTIONS预检请求导致问题

3. **请求处理超时**
   - 5秒超时后返回400
   - 可能在路由匹配阶段就超时了

### 下一步调查

1. ✅ **测试其他GET路由** - 已确认GET正常
2. ⏳ **检查cpp-httplib的POST路由匹配逻辑**
3. ⏳ **添加路由注册前后的日志**
4. ⏳ **测试简单的POST路由（不带路径参数）**

---

## 🔍 问题2根本原因深度调查（2025-10-17 13:30-13:50）

### 调查背景

**核心问题**: POST `/api/v1/users/28/follow` 返回400且`handleFollow`方法根本未被调用！

**证据**:
- ✅ GET请求正常工作（如`/api/v1/users/28/followers`返回200）
- ❌ POST请求异常（耗时5秒后返回400，无响应体）
- ❌ 添加的日志完全未出现（方法未被调用）
- ✅ 日志字符串在二进制文件中（编译成功）

### 修复尝试1: 正则路由添加结尾锚点

#### 问题分析

发现`auth_handler.cpp`的`registerWildcardRoutes`方法中有正则表达式路由：

```cpp
// 第78-85行
void AuthHandler::registerWildcardRoutes(httplib::Server& server) {
    // 获取用户公开信息 (使用正则表达式，必须放在最后)
    server.Get(R"(/api/v1/users/([^/]+))", [this](...) {
        handleGetUserPublicInfo(...);
    });
}
```

**推测**: 正则表达式`/api/v1/users/([^/]+)`没有结尾锚点，可能干扰了`/api/v1/users/:user_id/follow`的POST路由

#### 修复操作

**修改文件**: `src/api/auth_handler.cpp` 第80行

```cpp
// 修改前
server.Get(R"(/api/v1/users/([^/]+))", [this](...) {

// 修改后（添加$结尾锚点）
server.Get(R"(/api/v1/users/([^/]+)$)", [this](...) {
```

**编译**: ✅ 成功
```bash
cd backend-service/build && make -j4
[100%] Built target knot_image_sharing
```

#### 测试结果

❌ **问题未解决**

- POST `/api/v1/users/31/follow` 仍然返回400
- 耗时仍然5秒
- `handleFollow`方法仍未被调用

**日志**:
```
[2025-10-17 13:35:27.965] [info] Follow routes registered
[2025-10-17 13:35:41.607] [info] Request: POST /api/v1/users/28/follow
[2025-10-17 13:35:46.607] [info] Response: 400 for POST /api/v1/users/28/follow
```

**结论**: 添加`$`锚点未能解决问题，问题比预期更深层。

---

### 修复尝试2: 添加详细日志并重新启动

#### 添加调试日志

**修改文件**: `src/api/follow_handler.cpp`

```cpp
// 第19-26行
void FollowHandler::registerRoutes(httplib::Server& server) {
    Logger::info("FollowHandler: Registering POST /api/v1/users/:user_id/follow");
    
    // POST /api/v1/users/:user_id/follow - 关注用户
    server.Post("/api/v1/users/:user_id/follow", [this](const httplib::Request& req, httplib::Response& res) {
        Logger::info("POST /api/v1/users/:user_id/follow lambda called - path: " + req.path);
        handleFollow(req, res);
    });
    // ... 其他路由
}
```

**编译**: ✅ 成功

#### 服务启动失败 - 库依赖问题

**问题发现**:
```bash
$ ./build/knot_image_sharing config/config.json
./build/knot_image_sharing: /home/kun/anaconda3/lib/libstdc++.so.6: version `GLIBCXX_3.4.30' not found
```

**原因**: Anaconda3的libstdc++版本过旧，与编译的二进制文件不兼容

**解决方案**: 设置正确的库路径
```bash
LD_LIBRARY_PATH=/usr/lib/x86_64-linux-gnu:$LD_LIBRARY_PATH ./build/knot_image_sharing config/config.json
```

#### 正确启动后的测试

**服务启动日志** (13:49:59):
```
[2025-10-17 13:49:59.635] [info] Auth routes registered
[2025-10-17 13:49:59.635] [info] Image routes registered
[2025-10-17 13:49:59.635] [info] LikeHandler routes registered
[2025-10-17 13:49:59.635] [info] FavoriteHandler routes registered
[2025-10-17 13:49:59.635] [info] FollowHandler: Registering POST /api/v1/users/:user_id/follow  ← ✅ 新日志出现
[2025-10-17 13:49:59.635] [info] Follow routes registered
[2025-10-17 13:49:59.635] [info] PostHandler routes registered
[2025-10-17 13:49:59.635] [info] Auth wildcard routes registered
```

**测试请求**: POST `/api/v1/users/31/follow`

**请求日志** (13:50:19):
```
[2025-10-17 13:50:19.488] [info] Request: POST /api/v1/users/31/follow
（等待5秒...）
（没有任何其他日志输出）
（没有"lambda called"日志）
（没有"handleFollow called"日志）
```

**测试结果**:
- ❌ 请求耗时5秒返回400
- ❌ Lambda函数完全未被调用（`Logger::info("POST /api/v1/users/:user_id/follow lambda called")`未出现）
- ❌ `handleFollow`方法未被调用

---

### 关键发现总结

#### 发现1: 路由注册成功但Lambda未执行

**证据**:
1. 路由注册日志正常出现：`"FollowHandler: Registering POST /api/v1/users/:user_id/follow"`
2. 请求日志出现：`"Request: POST /api/v1/users/31/follow"`
3. Lambda内日志**从未出现**：`"POST /api/v1/users/:user_id/follow lambda called"`

**结论**: 
- cpp-httplib的`server.Post()`注册了路由
- 但POST请求到达时，Lambda函数没有被执行
- 这不是Service层或业务逻辑的问题，而是**路由分发层面的问题**

#### 发现2: GET正常但POST异常

**对比测试**:

| 请求 | 方法 | 路由 | 结果 | 耗时 |
|-----|------|------|------|------|
| GET `/api/v1/users/28/followers` | GET | `/api/v1/users/:user_id/followers` | ✅ 200 OK | <1秒 |
| POST `/api/v1/users/31/follow` | POST | `/api/v1/users/:user_id/follow` | ❌ 400 Bad Request | 5秒 |

**测试细节**:
```bash
# GET请求成功
curl -X GET http://localhost:8080/api/v1/users/28/followers -H "Authorization: Bearer $TOKEN"
# 返回: {"success":true,"data":{"total":0,"page":1,...}}

# POST请求失败（完整curl -v输出）
> POST /api/v1/users/31/follow HTTP/1.1
> Host: localhost:8080
> Authorization: Bearer eyJhbGc...
> Content-Type: application/json
（等待5秒...）
< HTTP/1.1 400 Bad Request
< Content-Length: 0
（无响应体）
```

#### 发现3: 路由注册顺序

**http_server.cpp 第127-147行**:
```cpp
authHandler_->registerRoutes(*server_);           // 第1步
imageHandler_->registerRoutes(*server_);          // 第2步
likeHandler_->registerRoutes(*server_);           // 第3步
favoriteHandler_->registerRoutes(*server_);       // 第4步
followHandler_->registerRoutes(*server_);         // 第5步 - 注册POST /api/v1/users/:user_id/follow
postHandler_->registerRoutes(*server_);           // 第6步
authHandler_->registerWildcardRoutes(*server_);   // 第7步 - 正则路由 /api/v1/users/([^/]+)$
```

**时序**:
1. FollowHandler在第5步注册POST路由
2. AuthHandler的正则路由在第7步注册（最后）
3. 正则路由已添加`$`锚点，理论上不应干扰

---

### 可能原因推测

#### 推测1: cpp-httplib的POST路由匹配机制问题

**假设**: cpp-httplib对于带路径参数的POST路由，匹配逻辑可能与GET不同

**证据**:
- 相同路径参数模式的GET路由正常
- POST路由Lambda未被调用
- 5秒超时暗示路由分发器在尝试匹配但失败

**需要验证**:
- cpp-httplib版本（0.11.0）的POST路由匹配源码
- 是否有已知的路径参数POST路由bug

#### 推测2: 正则路由仍在干扰（即使有$锚点）

**假设**: cpp-httplib的正则路由优先级可能高于普通路径参数路由

**证据**:
- 正则路由 `GET R"(/api/v1/users/([^/]+)$)"` 注册在最后
- POST请求路径 `/api/v1/users/31/follow` 可能被正则引擎预处理
- 虽然HTTP方法不同，但路由分发器可能先检查路径再检查方法

**需要验证**:
- 完全移除`registerWildcardRoutes`后测试
- 或将FollowHandler的路由注册移到AuthHandler之前

#### 推测3: 路径参数`:user_id`解析失败

**假设**: POST请求的路径参数解析与GET不同

**证据**:
- Lambda中使用`req.path_params.at("user_id")`
- 如果解析失败，会抛出异常，但Lambda根本未执行
- 可能在Lambda调用前就失败了

**需要验证**:
- 添加路由匹配前的日志（修改cpp-httplib源码或使用pre_routing_handler）
- 测试不带路径参数的POST路由（如`/api/v1/test/follow`）

#### 推测4: 5秒超时的来源

**观察**: 所有失败的POST请求都精确耗时5秒

**可能性**:
1. cpp-httplib的默认路由匹配超时
2. 某个中间件的超时设置
3. Keep-Alive超时（日志显示`timeout=5, max=100`）

**需要检查**:
- `CMakeLists.txt`中的超时定义
- `http_server.cpp`中的超时配置

---

### 下一步调查方向

#### 方向1: 简化测试 - 不带路径参数的POST路由

**目的**: 验证问题是否与路径参数`:user_id`有关

**方案**: 添加测试路由
```cpp
server.Post("/api/v1/test/follow", [](const httplib::Request& req, httplib::Response& res) {
    res.set_content("Test OK", "text/plain");
});
```

#### 方向2: 完全移除正则路由

**目的**: 验证正则路由是否仍在干扰

**方案**: 注释掉`authHandler_->registerWildcardRoutes(*server_);`

#### 方向3: 调整路由注册顺序

**目的**: 验证注册顺序是否影响POST路由

**方案**: 将`followHandler_->registerRoutes`移到`authHandler_->registerRoutes`之前

#### 方向4: 检查cpp-httplib源码

**目的**: 理解POST路由的匹配逻辑

**方案**:
- 查看`httplib.h`中`Post()`方法实现
- 查看路由表的匹配顺序
- 查看路径参数的解析逻辑

---

### 测试环境信息

**编译环境**:
- 操作系统: Ubuntu 20.04 (Linux 6.8.0-86-generic)
- 编译器: GCC 11.4.0
- C++标准: C++17
- cpp-httplib版本: 0.11.0

**运行环境**:
- LD_LIBRARY_PATH: `/usr/lib/x86_64-linux-gnu:$LD_LIBRARY_PATH`
- 服务监听: `0.0.0.0:8080`
- 数据库: MySQL 8.0 (远程: 8.138.115.164:3306)

**测试用户**:
- follow_test_a (id=30, user_id=USR_2025Q4_oLTNtk)
- follow_test_b (id=31, user_id=USR_2025Q4_VA8No4)

---

**报告更新时间**: 2025-10-17 13:50  
**当前状态**: 🔴 POST路由Lambda未被调用，需要进一步调查cpp-httplib路由机制

