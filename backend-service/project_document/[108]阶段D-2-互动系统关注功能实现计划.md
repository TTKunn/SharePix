# 阶段D-2：互动系统关注功能实现计划

**文档编号**: [108]
**创建时间**: 2025-10-11
**项目**: Knot - 图片分享社交平台
**版本**: v2.3.0
**状态**: 📝 计划中
**依赖**: [107]阶段D-1-互动系统点赞收藏功能实现计划（v2.2.0）

---

## 📋 目录

1. [概述](#概述)
   - [背景](#背景)
   - [目标](#目标)
   - [实施范围](#实施范围)
2. [技术设计](#技术设计)
   - [数据库设计](#数据库设计)
   - [架构设计](#架构设计)
   - [API设计](#api设计)
3. [详细任务列表](#详细任务列表)
   - [阶段0：数据库调研](#阶段0数据库调研30分钟)
   - [阶段1：数据库变更](#阶段1数据库变更1小时)
   - [阶段2：Model层](#阶段2model层2小时)
   - [阶段3：Repository层](#阶段3repository层4-5小时)
   - [阶段4：Service层](#阶段4service层4-5小时)
   - [阶段5：Handler层](#阶段5handler层3小时)
   - [阶段6：集成测试](#阶段6集成测试3-4小时)
   - [阶段7：文档更新](#阶段7文档更新1小时)
4. [关键技术点](#关键技术点)
5. [风险和注意事项](#风险和注意事项)
6. [验收标准](#验收标准)
7. [进度跟踪](#进度跟踪)
8. [变更日志](#变更日志)

---

## 概述

### 背景

**已完成的功能（v2.2.0）**：
- ✅ **点赞系统**: 用户可对帖子点赞/取消点赞
- ✅ **收藏系统**: 用户可收藏/取消收藏帖子
- ✅ **多图片帖子系统（v2.0.0）**: 支持1-9张图片的帖子
- ✅ **用户认证系统（v2.1.0）**: 注册、登录、JWT令牌管理

**当前缺失的核心社交功能**：
- ❌ **关注系统**: 用户无法关注其他创作者
- ❌ **粉丝系统**: 创作者无法了解自己的粉丝
- ❌ **关注Feed**: 用户无法查看关注的创作者的最新内容
- ❌ **社交统计**: 用户主页无法显示关注数/粉丝数

根据产品需求文档（`需求分析.md`）和竞品分析：
- 🎯 **小红书模式**: 单向关注机制（A关注B，B不必关注A）
- 🎯 **Feed优化**: 关注用户的内容优先显示
- 🎯 **创作者激励**: 粉丝数是创作者的重要激励指标
- 🎯 **社交图谱**: 为后续推荐算法提供数据基础

本阶段将实现互动系统的**第二步**：**关注/取关功能**，完善社交体系的核心基础设施。

---

### 目标

本阶段的核心目标：

1. **实现关注系统**
   - 用户可以关注其他用户（单向关注）
   - 用户可以取消关注
   - 防止重复关注（幂等性）
   - 防止自我关注

2. **实现粉丝统计**
   - 用户主页显示关注数/粉丝数
   - 实时更新关注统计
   - 使用冗余字段优化查询性能

3. **实现关系查询**
   - 查询关注列表（我关注的人）
   - 查询粉丝列表（关注我的人）
   - 快速检查关注关系（A是否关注B）

4. **保持架构一致性**
   - 严格遵循九层架构
   - 复用点赞/收藏系统的设计模式
   - 与现有Like/Favorite系统风格保持一致

5. **为后续功能打基础**
   - 为关注Feed流提供数据支持
   - 为推荐算法提供社交图谱数据
   - 为通知系统预留扩展点

---

### 实施范围

本阶段将实现**7个核心API接口**：

| 序号 | 功能 | API路径 | 方法 | 认证 | 优先级 | 预计工时 |
|------|------|---------|------|------|--------|---------|
| 1 | 关注用户 | `/api/v1/users/:user_id/follow` | POST | 需要JWT | P0 | 3小时 |
| 2 | 取消关注 | `/api/v1/users/:user_id/follow` | DELETE | 需要JWT | P0 | 1.5小时 |
| 3 | 检查关注关系 | `/api/v1/users/:user_id/follow/status` | GET | 需要JWT | P0 | 1小时 |
| 4 | 获取关注列表 | `/api/v1/users/:user_id/following` | GET | 可选 | P1 | 2.5小时 |
| 5 | 获取粉丝列表 | `/api/v1/users/:user_id/followers` | GET | 可选 | P1 | 2小时 |
| 6 | 获取用户统计信息 | `/api/v1/users/:user_id/stats` | GET | 无需 | P1 | 1.5小时 |
| 7 | 批量检查关注关系 | `/api/v1/users/follow/batch-status` | POST | 需要JWT | P2 | 2小时 |

**实施时间**: 预计3-4个工作日（约24小时）

**本阶段不包含**：
- ❌ 关注Feed流（延后到v2.4.0，依赖本阶段数据）
- ❌ 互相关注检测（可选功能，视时间决定）
- ❌ 关注推荐算法（延后到v3.0）
- ❌ 关注通知（延后到通知系统）

---

## 技术设计

### 数据库设计

#### 1. follows表（关注关系表）

**设计说明**：
- 单向关注机制：follower_id关注followee_id
- 采用简化设计，不使用业务逻辑ID（follow_id），只用物理主键id
- 使用唯一约束(follower_id, followee_id)保证幂等性，防止重复关注
- 使用外键级联删除，用户删除时自动清理关注关系
- 双向索引优化：支持"我关注的人"和"关注我的人"两种查询

**表结构**：

```sql
CREATE TABLE follows (
    id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '物理ID（自增主键）',
    follower_id BIGINT NOT NULL COMMENT '关注者ID（A关注B，A是follower）',
    followee_id BIGINT NOT NULL COMMENT '被关注者ID（A关注B，B是followee）',
    create_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '关注时间',

    -- 外键约束
    CONSTRAINT fk_follows_follower FOREIGN KEY (follower_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_follows_followee FOREIGN KEY (followee_id) REFERENCES users(id) ON DELETE CASCADE,

    -- 唯一约束（防止同一用户重复关注同一用户）
    UNIQUE KEY uk_follower_followee (follower_id, followee_id),

    -- 索引优化
    INDEX idx_follower_create (follower_id, create_time DESC),  -- 查询"我关注的人"
    INDEX idx_followee_create (followee_id, create_time DESC)   -- 查询"关注我的人"
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='关注关系表';
```

**字段说明**：

| 字段名 | 类型 | 约束 | 说明 |
|--------|------|------|------|
| id | BIGINT | PRIMARY KEY, AUTO_INCREMENT | 物理主键 |
| follower_id | BIGINT | NOT NULL, FOREIGN KEY | 关注者ID（主动方） |
| followee_id | BIGINT | NOT NULL, FOREIGN KEY | 被关注者ID（被动方） |
| create_time | TIMESTAMP | NOT NULL, DEFAULT CURRENT_TIMESTAMP | 关注时间 |

**索引说明**：

| 索引名 | 类型 | 字段 | 用途 |
|--------|------|------|------|
| PRIMARY | 主键 | id | 主键索引 |
| uk_follower_followee | 唯一索引 | (follower_id, followee_id) | 防止重复关注 + 快速exists()查询 |
| idx_follower_create | 复合索引 | (follower_id, create_time DESC) | 查询"我关注的人"列表（按时间倒序） |
| idx_followee_create | 复合索引 | (followee_id, create_time DESC) | 查询"我的粉丝"列表（按时间倒序） |

**业务规则检查约束**（在应用层实现）：
- 禁止自我关注：`follower_id != followee_id`（应用层检查）
- 关注操作幂等性：唯一约束自动保证

---

#### 2. users表字段扩展

**新增冗余字段**（用于性能优化）：

```sql
-- 在users表中新增以下字段
ALTER TABLE users ADD COLUMN following_count INT NOT NULL DEFAULT 0 COMMENT '关注数（我关注的人数，冗余字段）';
ALTER TABLE users ADD COLUMN follower_count INT NOT NULL DEFAULT 0 COMMENT '粉丝数（关注我的人数，冗余字段）';
```

**字段说明**：

| 字段名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| following_count | INT | 0 | 关注数（我关注的人数） |
| follower_count | INT | 0 | 粉丝数（关注我的人数） |

**更新策略**：
- 使用SQL原子操作保证一致性：
  ```sql
  -- A关注B时
  UPDATE users SET following_count = following_count + 1 WHERE id = A;
  UPDATE users SET follower_count = follower_count + 1 WHERE id = B;
  ```
- 使用TransactionGuard保证关注记录和计数的原子性
- 避免先SELECT再UPDATE的竞态条件

---

#### 3. 设计决策说明

| 设计点 | 方案 | 理由 |
|--------|------|------|
| **关注模式** | 单向关注（follower → followee） | 符合小红书、Instagram模式，降低社交门槛 |
| **业务ID** | 不使用（只有物理主键id） | 关注关系无需独立的业务逻辑ID，简化设计 |
| **唯一约束** | (follower_id, followee_id) | 防止同一用户重复关注同一用户 |
| **级联删除** | ON DELETE CASCADE | 用户删除时自动清理关注关系，保证数据一致性 |
| **时间戳** | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | 记录关注时间，支持按时间排序 |
| **双向索引** | (follower_id, create_time) + (followee_id, create_time) | 优化"关注列表"和"粉丝列表"两种查询 |
| **冗余计数** | users.following_count, users.follower_count | 避免高频COUNT查询，提升用户主页性能 |
| **自我关注** | 应用层拦截 | 数据库不设置CHECK约束，在Service层检查 |

**与点赞/收藏表的对比**：

| 特性 | likes/favorites表 | follows表 | 差异说明 |
|------|------------------|-----------|---------|
| 关联对象 | user → post | user → user | follows是用户间关系 |
| 索引策略 | 单向索引 | 双向索引 | follows需要支持双向查询 |
| 冗余字段 | posts表 | users表 | follows的计数存在用户表 |
| 业务规则 | 可对自己帖子操作 | 禁止自我关注 | follows有特殊规则 |

---

### 架构设计

#### 1. 九层架构图（文本形式）

```
┌─────────────────────────────────────────────────────────────┐
│                      HTTP客户端                              │
│                  (移动App / Web浏览器)                       │
└───────────────────────────┬─────────────────────────────────┘
                            │ HTTP请求
                            ↓
┌─────────────────────────────────────────────────────────────┐
│   [第2层] HTTP服务器 (http_server.cpp)                      │
│   - 监听端口8080                                             │
│   - 路由分发                                                 │
└───────────────────────────┬─────────────────────────────────┘
                            │
                            ↓
┌─────────────────────────────────────────────────────────────┐
│   [第3层] API接口层 (Handler)                                │
│   ┌──────────────────────────────────────┐                 │
│   │ FollowHandler              ← 新增   │                 │
│   │ - handleFollow()                      │                 │
│   │ - handleUnfollow()                    │                 │
│   │ - handleCheckFollowStatus()           │                 │
│   │ - handleGetFollowingList()            │                 │
│   │ - handleGetFollowerList()             │                 │
│   │ - handleGetUserStats()                │                 │
│   │ - handleBatchCheckFollowStatus()      │                 │
│   └──────────────────────────────────────┘                 │
│   (继承BaseHandler，自动获得JWT验证能力)                      │
└───────────────────────────┬─────────────────────────────────┘
                            │ 调用Service方法
                            ↓
┌─────────────────────────────────────────────────────────────┐
│   [第4层] 业务逻辑层 (Service)                               │
│   ┌──────────────────────────────────────┐                 │
│   │ FollowService              ← 新增   │                 │
│   │ - followUser()                        │                 │
│   │ - unfollowUser()                      │                 │
│   │ - isFollowing()                       │                 │
│   │ - getFollowingList()                  │                 │
│   │ - getFollowerList()                   │                 │
│   │ - getUserStats()                      │                 │
│   │ - batchCheckFollowStatus()            │                 │
│   └──────────────────────────────────────┘                 │
│   (使用TransactionGuard保证事务原子性)                       │
└───────────────────────────┬─────────────────────────────────┘
                            │ 调用Repository方法
                            ↓
┌─────────────────────────────────────────────────────────────┐
│   [第5层] 数据访问层 (Repository)                            │
│   ┌─────────────────────────────────┐                       │
│   │ FollowRepository      ← 新增   │                       │
│   │ - create()                       │                       │
│   │ - deleteByFollowerAndFollowee()  │                       │
│   │ - exists()                       │                       │
│   │ - countFollowing()               │                       │
│   │ - countFollowers()               │                       │
│   │ - findFollowingByUserId()        │                       │
│   │ - findFollowersByUserId()        │                       │
│   │ - batchCheckExists()             │                       │
│   └─────────────────────────────────┘                       │
│   ┌─────────────────────────────────┐                       │
│   │ UserRepository        ← 需修改  │                       │
│   │ - incrementFollowingCount()      │ (新增方法)          │
│   │ - decrementFollowingCount()      │                      │
│   │ - incrementFollowerCount()       │                      │
│   │ - decrementFollowerCount()       │                      │
│   │ - getStatsById()                 │ (新增方法)          │
│   └─────────────────────────────────┘                       │
│   (使用ConnectionGuard管理数据库连接)                        │
└───────────────────────────┬─────────────────────────────────┘
                            │ 使用基础设施
                            ↓
┌─────────────────────────────────────────────────────────────┐
│   [第7层] 基础设施层 (Utils)                                 │
│   ┌──────────────────┐  ┌──────────────────┐               │
│   │ ConnectionGuard  │  │ TransactionGuard │  ← 已有       │
│   │ - RAII资源管理   │  │ - RAII事务管理   │               │
│   └──────────────────┘  └──────────────────┘               │
│   ┌──────────────────┐  ┌──────────────────┐               │
│   │ Logger           │  │ ConfigManager    │  ← 已有       │
│   └──────────────────┘  └──────────────────┘               │
└───────────────────────────┬─────────────────────────────────┘
                            │ 使用Model
                            ↓
┌─────────────────────────────────────────────────────────────┐
│   [第8层] 数据模型层 (Model)                                 │
│   ┌──────────────────────────────────┐                     │
│   │ Follow                 ← 新增   │                     │
│   │ - id_                             │                     │
│   │ - followerId_                     │                     │
│   │ - followeeId_                     │                     │
│   │ - createTime_                     │                     │
│   │ - toJson()                        │                     │
│   └──────────────────────────────────┘                     │
│   ┌──────────────────────────────────┐                     │
│   │ UserStats              ← 新增   │                     │
│   │ - userId_                         │                     │
│   │ - followingCount_                 │                     │
│   │ - followerCount_                  │                     │
│   │ - postCount_                      │                     │
│   │ - likeCount_                      │                     │
│   │ - toJson()                        │                     │
│   └──────────────────────────────────┘                     │
└───────────────────────────┬─────────────────────────────────┘
                            │ 数据持久化
                            ↓
┌─────────────────────────────────────────────────────────────┐
│   [第9层] 数据库层 (MySQL 8.0)                               │
│   - knot_image_sharing数据库                                 │
│   - follows表 (新增)                                         │
│   - users表 (扩展: following_count, follower_count)         │
└─────────────────────────────────────────────────────────────┘
```

---

#### 2. 文件清单

**新增文件**（14个，约2,500行代码）：

| 文件路径 | 说明 | 预计行数 |
|---------|------|---------|
| `src/models/follow.h` | Follow模型类定义 | 90 |
| `src/models/follow.cpp` | Follow模型类实现 | 130 |
| `src/models/user_stats.h` | UserStats模型类定义 | 100 |
| `src/models/user_stats.cpp` | UserStats模型类实现 | 150 |
| `src/database/follow_repository.h` | FollowRepository接口定义 | 130 |
| `src/database/follow_repository.cpp` | FollowRepository实现 | 450 |
| `src/core/follow_service.h` | FollowService接口定义 | 120 |
| `src/core/follow_service.cpp` | FollowService实现 | 400 |
| `src/api/follow_handler.h` | FollowHandler接口定义 | 100 |
| `src/api/follow_handler.cpp` | FollowHandler实现 | 500 |
| `config/migration_social_follows.sql` | 数据库迁移脚本 | 120 |

**修改文件**（3个）：

| 文件路径 | 修改内容 | 预计增加行数 |
|---------|---------|------------|
| `src/database/user_repository.h` | 新增5个方法声明（统计更新方法） | 30 |
| `src/database/user_repository.cpp` | 实现5个原子更新方法 | 180 |
| `src/server/http_server.h` | 新增FollowHandler成员变量 | 3 |
| `src/server/http_server.cpp` | 注册Follow路由 | 15 |

**总代码量**: 约2,800行

---

#### 3. 依赖关系

```
FollowHandler
    ↓ 依赖
FollowService
    ↓ 依赖
FollowRepository + UserRepository
    ↓ 依赖
ConnectionGuard + TransactionGuard
    ↓ 依赖
DatabaseConnectionPool
```

**与点赞/收藏系统的对比**：

| 依赖项 | Like/Favorite系统 | Follow系统 | 差异 |
|--------|------------------|------------|------|
| Repository | LikeRepo + PostRepo | FollowRepo + UserRepo | Follow操作更新用户表 |
| Service方法 | 2个核心方法 | 7个核心方法 | Follow功能更复杂 |
| Handler接口 | 2个API | 7个API | Follow需要列表查询 |

---

### API设计

#### API 1: 关注用户

**基本信息**：

- **路径**: `POST /api/v1/users/:user_id/follow`
- **认证**: 需要JWT Token
- **描述**: 用户关注指定用户

**请求参数**：

| 参数名 | 位置 | 类型 | 必填 | 说明 |
|--------|------|------|------|------|
| user_id | 路径参数 | string | 是 | 被关注用户的业务ID，如：USR_2025Q4_ABC123 |
| Authorization | 请求头 | string | 是 | JWT Token，格式：Bearer {token} |

**请求示例**：

```bash
curl -X POST http://localhost:8080/api/v1/users/USR_2025Q4_ABC123/follow \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

**成功响应**（200 OK）：

```json
{
  "success": true,
  "message": "关注成功",
  "data": {
    "followee_user_id": "USR_2025Q4_ABC123",
    "is_following": true,
    "follower_count": 128
  },
  "timestamp": 1696752600
}
```

**失败响应**：

1. **已经关注过**（409 Conflict）：
```json
{
  "success": false,
  "message": "已经关注过该用户",
  "data": {
    "followee_user_id": "USR_2025Q4_ABC123",
    "is_following": true,
    "follower_count": 127
  },
  "timestamp": 1696752600
}
```

2. **不能关注自己**（400 Bad Request）：
```json
{
  "success": false,
  "message": "不能关注自己",
  "timestamp": 1696752600
}
```

3. **用户不存在**（404 Not Found）：
```json
{
  "success": false,
  "message": "用户不存在",
  "timestamp": 1696752600
}
```

4. **未提供认证令牌**（401 Unauthorized）：
```json
{
  "success": false,
  "message": "未提供认证令牌",
  "timestamp": 1696752600
}
```

**错误码说明**：

| HTTP状态码 | 说明 | 返回消息 |
|-----------|------|---------|
| 200 | 关注成功 | "关注成功" |
| 400 | 参数错误（自我关注） | "不能关注自己" |
| 401 | 未认证或令牌无效 | "未提供认证令牌" / "令牌无效或已过期" |
| 404 | 用户不存在 | "用户不存在" |
| 409 | 已经关注过 | "已经关注过该用户" |
| 500 | 服务器内部错误 | "服务器内部错误" |

---

#### API 2: 取消关注

**基本信息**：

- **路径**: `DELETE /api/v1/users/:user_id/follow`
- **认证**: 需要JWT Token
- **描述**: 用户取消关注指定用户

**请求参数**：

| 参数名 | 位置 | 类型 | 必填 | 说明 |
|--------|------|------|------|------|
| user_id | 路径参数 | string | 是 | 被取关用户的业务ID |
| Authorization | 请求头 | string | 是 | JWT Token |

**请求示例**：

```bash
curl -X DELETE http://localhost:8080/api/v1/users/USR_2025Q4_ABC123/follow \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

**成功响应**（200 OK）：

```json
{
  "success": true,
  "message": "取消关注成功",
  "data": {
    "followee_user_id": "USR_2025Q4_ABC123",
    "is_following": false,
    "follower_count": 126
  },
  "timestamp": 1696752600
}
```

**失败响应**：

1. **未关注该用户**（404 Not Found）：
```json
{
  "success": false,
  "message": "未关注该用户",
  "data": {
    "followee_user_id": "USR_2025Q4_ABC123",
    "is_following": false
  },
  "timestamp": 1696752600
}
```

2. **用户不存在**（404 Not Found）：
```json
{
  "success": false,
  "message": "用户不存在",
  "timestamp": 1696752600
}
```

**错误码说明**：

| HTTP状态码 | 说明 | 返回消息 |
|-----------|------|---------|
| 200 | 取消关注成功 | "取消关注成功" |
| 401 | 未认证或令牌无效 | "未提供认证令牌" / "令牌无效或已过期" |
| 404 | 用户不存在或未关注 | "用户不存在" / "未关注该用户" |
| 500 | 服务器内部错误 | "服务器内部错误" |

---

#### API 3: 检查关注关系

**基本信息**：

- **路径**: `GET /api/v1/users/:user_id/follow/status`
- **认证**: 需要JWT Token
- **描述**: 检查当前用户是否关注指定用户

**请求参数**：

| 参数名 | 位置 | 类型 | 必填 | 说明 |
|--------|------|------|------|------|
| user_id | 路径参数 | string | 是 | 被检查用户的业务ID |
| Authorization | 请求头 | string | 是 | JWT Token |

**请求示例**：

```bash
curl -X GET http://localhost:8080/api/v1/users/USR_2025Q4_ABC123/follow/status \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

**成功响应**（200 OK）：

```json
{
  "success": true,
  "message": "查询成功",
  "data": {
    "user_id": "USR_2025Q4_ABC123",
    "is_following": true,
    "is_followed_by": false
  },
  "timestamp": 1696752600
}
```

**字段说明**：
- `is_following`: 我是否关注该用户（true/false）
- `is_followed_by`: 该用户是否关注我（true/false）

**错误码说明**：

| HTTP状态码 | 说明 | 返回消息 |
|-----------|------|---------|
| 200 | 查询成功 | "查询成功" |
| 401 | 未认证或令牌无效 | "未提供认证令牌" / "令牌无效或已过期" |
| 404 | 用户不存在 | "用户不存在" |
| 500 | 服务器内部错误 | "服务器内部错误" |

---

#### API 4: 获取关注列表

**基本信息**：

- **路径**: `GET /api/v1/users/:user_id/following`
- **认证**: 可选（未登录也可查看）
- **描述**: 获取指定用户的关注列表（我关注的人）

**请求参数**：

| 参数名 | 位置 | 类型 | 必填 | 说明 |
|--------|------|------|------|------|
| user_id | 路径参数 | string | 是 | 用户业务ID |
| page | 查询参数 | int | 否 | 页码（默认1） |
| page_size | 查询参数 | int | 否 | 每页数量（默认20，最大100） |
| Authorization | 请求头 | string | 否 | JWT Token（可选） |

**请求示例**：

```bash
# 未登录查看
curl -X GET "http://localhost:8080/api/v1/users/USR_2025Q4_ABC123/following?page=1&page_size=20"

# 登录用户查看（会额外返回关注状态）
curl -X GET "http://localhost:8080/api/v1/users/USR_2025Q4_ABC123/following?page=1&page_size=20" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

**成功响应**（200 OK）：

```json
{
  "success": true,
  "message": "查询成功",
  "data": {
    "total": 156,
    "page": 1,
    "page_size": 20,
    "users": [
      {
        "user_id": "USR_2025Q4_XYZ789",
        "username": "photographer_bob",
        "real_name": "Bob Zhang",
        "avatar_url": "https://cdn.example.com/avatar/xyz789.jpg",
        "bio": "摄影爱好者",
        "follower_count": 1024,
        "is_following": true,
        "followed_at": 1696700000
      },
      {
        "user_id": "USR_2025Q4_ABC456",
        "username": "artist_alice",
        "real_name": "Alice Wang",
        "avatar_url": "https://cdn.example.com/avatar/abc456.jpg",
        "bio": "插画师",
        "follower_count": 2048,
        "is_following": false,
        "followed_at": 1696600000
      }
    ]
  },
  "timestamp": 1696752600
}
```

**字段说明**：
- `is_following`: 当前登录用户是否关注该用户（仅登录时返回）
- `followed_at`: 关注时间戳

**错误码说明**：

| HTTP状态码 | 说明 | 返回消息 |
|-----------|------|---------|
| 200 | 查询成功 | "查询成功" |
| 400 | 参数错误 | "参数错误：page_size不能超过100" |
| 404 | 用户不存在 | "用户不存在" |
| 500 | 服务器内部错误 | "服务器内部错误" |

---

#### API 5: 获取粉丝列表

**基本信息**：

- **路径**: `GET /api/v1/users/:user_id/followers`
- **认证**: 可选（未登录也可查看）
- **描述**: 获取指定用户的粉丝列表（关注我的人）

**请求参数**：

| 参数名 | 位置 | 类型 | 必填 | 说明 |
|--------|------|------|------|------|
| user_id | 路径参数 | string | 是 | 用户业务ID |
| page | 查询参数 | int | 否 | 页码（默认1） |
| page_size | 查询参数 | int | 否 | 每页数量（默认20，最大100） |
| Authorization | 请求头 | string | 否 | JWT Token（可选） |

**请求示例**：

```bash
curl -X GET "http://localhost:8080/api/v1/users/USR_2025Q4_ABC123/followers?page=1&page_size=20"
```

**成功响应**（200 OK）：

```json
{
  "success": true,
  "message": "查询成功",
  "data": {
    "total": 512,
    "page": 1,
    "page_size": 20,
    "users": [
      {
        "user_id": "USR_2025Q4_FAN001",
        "username": "fan_charlie",
        "real_name": "Charlie Li",
        "avatar_url": "https://cdn.example.com/avatar/fan001.jpg",
        "bio": "摄影新手",
        "follower_count": 50,
        "is_following": false,
        "followed_at": 1696750000
      }
    ]
  },
  "timestamp": 1696752600
}
```

**字段说明**：
- `is_following`: 当前登录用户是否关注该粉丝（仅登录时返回）
- `followed_at`: 该粉丝关注我的时间戳

**错误码说明**：与API 4相同

---

#### API 6: 获取用户统计信息

**基本信息**：

- **路径**: `GET /api/v1/users/:user_id/stats`
- **认证**: 无需认证
- **描述**: 获取用户的统计信息（关注数、粉丝数、帖子数等）

**请求参数**：

| 参数名 | 位置 | 类型 | 必填 | 说明 |
|--------|------|------|------|------|
| user_id | 路径参数 | string | 是 | 用户业务ID |

**请求示例**：

```bash
curl -X GET "http://localhost:8080/api/v1/users/USR_2025Q4_ABC123/stats"
```

**成功响应**（200 OK）：

```json
{
  "success": true,
  "message": "查询成功",
  "data": {
    "user_id": "USR_2025Q4_ABC123",
    "following_count": 156,
    "follower_count": 512,
    "post_count": 89,
    "total_likes": 3420
  },
  "timestamp": 1696752600
}
```

**字段说明**：
- `following_count`: 关注数（我关注的人数）
- `follower_count`: 粉丝数（关注我的人数）
- `post_count`: 帖子总数
- `total_likes`: 获赞总数（所有帖子的点赞数总和）

**错误码说明**：

| HTTP状态码 | 说明 | 返回消息 |
|-----------|------|---------|
| 200 | 查询成功 | "查询成功" |
| 404 | 用户不存在 | "用户不存在" |
| 500 | 服务器内部错误 | "服务器内部错误" |

---

#### API 7: 批量检查关注关系

**基本信息**：

- **路径**: `POST /api/v1/users/follow/batch-status`
- **认证**: 需要JWT Token
- **描述**: 批量检查当前用户是否关注指定的多个用户（用于Feed流优化）

**请求参数**：

| 参数名 | 位置 | 类型 | 必填 | 说明 |
|--------|------|------|------|------|
| user_ids | 请求体 | array | 是 | 用户业务ID数组（最多100个） |
| Authorization | 请求头 | string | 是 | JWT Token |

**请求示例**：

```bash
curl -X POST "http://localhost:8080/api/v1/users/follow/batch-status" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." \
  -H "Content-Type: application/json" \
  -d '{
    "user_ids": [
      "USR_2025Q4_ABC123",
      "USR_2025Q4_XYZ789",
      "USR_2025Q4_DEF456"
    ]
  }'
```

**成功响应**（200 OK）：

```json
{
  "success": true,
  "message": "查询成功",
  "data": {
    "USR_2025Q4_ABC123": true,
    "USR_2025Q4_XYZ789": false,
    "USR_2025Q4_DEF456": true
  },
  "timestamp": 1696752600
}
```

**字段说明**：
- 返回一个Map，key为用户ID，value为是否关注（true/false）
- 不存在的用户ID会被忽略，不出现在返回结果中

**错误码说明**：

| HTTP状态码 | 说明 | 返回消息 |
|-----------|------|---------|
| 200 | 查询成功 | "查询成功" |
| 400 | 参数错误 | "user_ids不能为空" / "user_ids不能超过100个" |
| 401 | 未认证或令牌无效 | "未提供认证令牌" / "令牌无效或已过期" |
| 500 | 服务器内部错误 | "服务器内部错误" |

---

## 详细任务列表

### 阶段0：数据库调研（30分钟）

**目标**：理解现有数据库结构，设计follows表和users表扩展方案

**任务清单**：

- [x] ✅ 阅读`config/database.sql`，了解users表结构
- [x] ✅ 阅读`[107]阶段D-1-互动系统点赞收藏功能实现计划.md`，了解likes/favorites表设计
- [x] ✅ 对比社交平台的关注系统设计（单向 vs 双向关注）
- [ ] ⏳ 设计follows表的索引策略（双向查询优化）
- [ ] ⏳ 设计users表的冗余字段（following_count, follower_count）
- [ ] ⏳ 确认外键级联删除策略
- [ ] ⏳ 评估并发场景下的数据一致性问题

**输出物**：
- follows表DDL
- users表ALTER语句
- 索引设计方案

**验收标准**：
- [ ] follows表设计文档完成
- [ ] 索引策略明确（双向索引）
- [ ] 数据一致性方案确定（TransactionGuard）

---

### 阶段1：数据库变更（1小时）

**目标**：创建follows表，扩展users表，编写数据库迁移脚本

**任务清单**：

- [ ] ⏳ 编写`config/migration_social_follows.sql`
  - [ ] 创建follows表
  - [ ] 添加外键约束
  - [ ] 创建唯一索引和复合索引
  - [ ] 扩展users表（添加following_count, follower_count）
- [ ] ⏳ 在测试数据库上执行迁移脚本
- [ ] ⏳ 验证表结构正确性
  - [ ] 检查外键约束
  - [ ] 检查唯一约束
  - [ ] 检查索引创建
- [ ] ⏳ 插入测试数据（3-5条关注关系）
- [ ] ⏳ 测试级联删除功能
  - [ ] 删除用户A，验证follows表相关记录自动删除
  - [ ] 验证被关注用户的follower_count更新

**输出物**：
- `config/migration_social_follows.sql`
- 测试报告

**验收标准**：
- [ ] 迁移脚本执行成功，无SQL错误
- [ ] 外键约束工作正常
- [ ] 唯一约束防止重复关注
- [ ] 级联删除测试通过

---

### 阶段2：Model层（2小时）

**目标**：实现Follow和UserStats模型类

**任务清单**：

#### 2.1 实现Follow模型（1小时）

- [ ] ⏳ 创建`src/models/follow.h`
  - [ ] 定义Follow类
  - [ ] 定义私有成员变量（id_, followerId_, followeeId_, createTime_）
  - [ ] 定义Getters/Setters
  - [ ] 声明toJson()和fromJson()方法
- [ ] ⏳ 创建`src/models/follow.cpp`
  - [ ] 实现构造函数
  - [ ] 实现toJson()：转换为JSON对象
  - [ ] 实现fromJson()：从JSON创建对象
- [ ] ⏳ 编写单元测试（可选）
  - [ ] 测试toJson()序列化
  - [ ] 测试fromJson()反序列化
  - [ ] 测试边界条件

#### 2.2 实现UserStats模型（1小时）

- [ ] ⏳ 创建`src/models/user_stats.h`
  - [ ] 定义UserStats类
  - [ ] 定义私有成员变量（userId_, followingCount_, followerCount_, postCount_, totalLikes_）
  - [ ] 定义Getters/Setters
  - [ ] 声明toJson()方法
- [ ] ⏳ 创建`src/models/user_stats.cpp`
  - [ ] 实现构造函数
  - [ ] 实现toJson()：转换为JSON对象
- [ ] ⏳ 编写单元测试（可选）

**输出物**：
- `src/models/follow.{h,cpp}`
- `src/models/user_stats.{h,cpp}`

**验收标准**：
- [ ] Follow模型编译通过
- [ ] UserStats模型编译通过
- [ ] toJson()/fromJson()功能正常
- [ ] 代码风格与Like/Favorite模型一致

---

### 阶段3：Repository层（4-5小时）

**目标**：实现FollowRepository和扩展UserRepository

**任务清单**：

#### 3.1 实现FollowRepository（3-4小时）

- [ ] ⏳ 创建`src/database/follow_repository.h`
  - [ ] 定义FollowRepository类
  - [ ] 声明CRUD方法：
    - [ ] `bool create(MYSQL* conn, int followerId, int followeeId)`
    - [ ] `bool deleteByFollowerAndFollowee(MYSQL* conn, int followerId, int followeeId)`
    - [ ] `bool exists(MYSQL* conn, int followerId, int followeeId)`
    - [ ] `int countFollowing(MYSQL* conn, int userId)`
    - [ ] `int countFollowers(MYSQL* conn, int userId)`
    - [ ] `std::vector<Follow> findFollowingByUserId(MYSQL* conn, int userId, int limit, int offset)`
    - [ ] `std::vector<Follow> findFollowersByUserId(MYSQL* conn, int userId, int limit, int offset)`
    - [ ] `std::map<int, bool> batchCheckExists(MYSQL* conn, int followerId, const std::vector<int>& followeeIds)`
- [ ] ⏳ 创建`src/database/follow_repository.cpp`
  - [ ] 实现create()：插入关注记录（使用预编译语句）
    ```cpp
    INSERT INTO follows (follower_id, followee_id) VALUES (?, ?)
    ```
  - [ ] 实现deleteByFollowerAndFollowee()：删除关注记录
    ```cpp
    DELETE FROM follows WHERE follower_id = ? AND followee_id = ?
    ```
  - [ ] 实现exists()：检查关注关系是否存在
    ```cpp
    SELECT 1 FROM follows WHERE follower_id = ? AND followee_id = ? LIMIT 1
    ```
  - [ ] 实现countFollowing()：统计关注数
    ```cpp
    SELECT COUNT(*) FROM follows WHERE follower_id = ?
    ```
  - [ ] 实现countFollowers()：统计粉丝数
    ```cpp
    SELECT COUNT(*) FROM follows WHERE followee_id = ?
    ```
  - [ ] 实现findFollowingByUserId()：查询关注列表（带分页）
    ```cpp
    SELECT f.id, f.follower_id, f.followee_id, f.create_time,
           u.user_id, u.username, u.real_name, u.avatar_url, u.bio, u.follower_count
    FROM follows f
    INNER JOIN users u ON f.followee_id = u.id
    WHERE f.follower_id = ?
    ORDER BY f.create_time DESC
    LIMIT ? OFFSET ?
    ```
  - [ ] 实现findFollowersByUserId()：查询粉丝列表（带分页）
    ```cpp
    SELECT f.id, f.follower_id, f.followee_id, f.create_time,
           u.user_id, u.username, u.real_name, u.avatar_url, u.bio, u.follower_count
    FROM follows f
    INNER JOIN users u ON f.follower_id = u.id
    WHERE f.followee_id = ?
    ORDER BY f.create_time DESC
    LIMIT ? OFFSET ?
    ```
  - [ ] 实现batchCheckExists()：批量检查关注关系
    ```cpp
    SELECT followee_id FROM follows
    WHERE follower_id = ? AND followee_id IN (?, ?, ...)
    ```
  - [ ] 实现buildFollowFromStatement()：从SQL结果构建Follow对象

#### 3.2 扩展UserRepository（1小时）

- [ ] ⏳ 修改`src/database/user_repository.h`
  - [ ] 新增方法声明：
    - [ ] `bool incrementFollowingCount(MYSQL* conn, int userId)`
    - [ ] `bool decrementFollowingCount(MYSQL* conn, int userId)`
    - [ ] `bool incrementFollowerCount(MYSQL* conn, int userId)`
    - [ ] `bool decrementFollowerCount(MYSQL* conn, int userId)`
    - [ ] `std::optional<UserStats> getStatsById(MYSQL* conn, int userId)`
- [ ] ⏳ 修改`src/database/user_repository.cpp`
  - [ ] 实现incrementFollowingCount()：原子递增
    ```cpp
    UPDATE users SET following_count = following_count + 1 WHERE id = ?
    ```
  - [ ] 实现decrementFollowingCount()：原子递减
    ```cpp
    UPDATE users SET following_count = following_count - 1 WHERE id = ? AND following_count > 0
    ```
  - [ ] 实现incrementFollowerCount()：原子递增
  - [ ] 实现decrementFollowerCount()：原子递减
  - [ ] 实现getStatsById()：查询用户统计信息
    ```cpp
    SELECT u.user_id, u.following_count, u.follower_count,
           COUNT(DISTINCT p.id) as post_count,
           SUM(p.like_count) as total_likes
    FROM users u
    LEFT JOIN posts p ON u.id = p.user_id
    WHERE u.id = ?
    GROUP BY u.id
    ```

**输出物**：
- `src/database/follow_repository.{h,cpp}`
- 修改后的`src/database/user_repository.{h,cpp}`

**验收标准**：
- [ ] 所有Repository方法编译通过
- [ ] 使用ConnectionGuard管理连接
- [ ] 所有SQL查询使用预编译语句（防止SQL注入）
- [ ] 错误处理完善（记录日志）
- [ ] 代码风格与LikeRepository一致

---

### 阶段4：Service层（4-5小时）

**目标**：实现FollowService业务逻辑层

**任务清单**：

#### 4.1 创建FollowService（4-5小时）

- [ ] ⏳ 创建`src/core/follow_service.h`
  - [ ] 定义FollowResult结构体
    ```cpp
    struct FollowResult {
        bool success;
        std::string message;
        int followingCount;
        int followerCount;
        bool isFollowing;
        int statusCode;
    };
    ```
  - [ ] 定义FollowService类
  - [ ] 声明业务方法：
    - [ ] `FollowResult followUser(int followerId, const std::string& followeeUserId)`
    - [ ] `FollowResult unfollowUser(int followerId, const std::string& followeeUserId)`
    - [ ] `bool isFollowing(int followerId, const std::string& followeeUserId)`
    - [ ] `std::vector<UserInfo> getFollowingList(int userId, int page, int pageSize)`
    - [ ] `std::vector<UserInfo> getFollowerList(int userId, int page, int pageSize)`
    - [ ] `UserStats getUserStats(const std::string& userId)`
    - [ ] `std::map<std::string, bool> batchCheckFollowStatus(int followerId, const std::vector<std::string>& followeeUserIds)`

- [ ] ⏳ 创建`src/core/follow_service.cpp`
  - [ ] **实现followUser()（核心方法）**：
    ```cpp
    1. 获取数据库连接（ConnectionGuard）
    2. 将followeeUserId转换为物理ID
    3. 检查目标用户是否存在
    4. 检查是否尝试关注自己（返回400错误）
    5. 开启事务（TransactionGuard）
    6. 检查是否已关注（调用followRepo_->exists()）
    7. 如果已关注，返回409错误
    8. 插入关注记录（调用followRepo_->create()）
    9. 更新关注者的following_count（调用userRepo_->incrementFollowingCount()）
    10. 更新被关注者的follower_count（调用userRepo_->incrementFollowerCount()）
    11. 提交事务
    12. 返回成功结果（包含最新follower_count）
    ```
  - [ ] **实现unfollowUser()（核心方法）**：
    ```cpp
    1. 获取数据库连接
    2. 将followeeUserId转换为物理ID
    3. 检查目标用户是否存在
    4. 开启事务
    5. 检查是否已关注（调用followRepo_->exists()）
    6. 如果未关注，返回404错误
    7. 删除关注记录（调用followRepo_->deleteByFollowerAndFollowee()）
    8. 更新关注者的following_count（调用userRepo_->decrementFollowingCount()）
    9. 更新被关注者的follower_count（调用userRepo_->decrementFollowerCount()）
    10. 提交事务
    11. 返回成功结果
    ```
  - [ ] 实现isFollowing()：检查关注关系
  - [ ] 实现getFollowingList()：查询关注列表（带分页）
  - [ ] 实现getFollowerList()：查询粉丝列表（带分页）
  - [ ] 实现getUserStats()：查询用户统计信息
  - [ ] 实现batchCheckFollowStatus()：批量检查关注关系

**输出物**：
- `src/core/follow_service.{h,cpp}`

**验收标准**：
- [ ] Service层编译通过
- [ ] 使用TransactionGuard保证事务原子性
- [ ] 关注/取关操作同时更新冗余计数
- [ ] 业务规则检查完善（防止自我关注、重复关注）
- [ ] 错误处理完善（记录日志，返回明确错误码）
- [ ] 代码风格与LikeService一致

---

### 阶段5：Handler层（3小时）

**目标**：实现FollowHandler API接口层

**任务清单**：

- [ ] ⏳ 创建`src/api/follow_handler.h`
  - [ ] 定义FollowHandler类（继承BaseHandler）
  - [ ] 声明7个API处理方法：
    - [ ] `void handleFollow(const httplib::Request& req, httplib::Response& res)`
    - [ ] `void handleUnfollow(const httplib::Request& req, httplib::Response& res)`
    - [ ] `void handleCheckFollowStatus(const httplib::Request& req, httplib::Response& res)`
    - [ ] `void handleGetFollowingList(const httplib::Request& req, httplib::Response& res)`
    - [ ] `void handleGetFollowerList(const httplib::Request& req, httplib::Response& res)`
    - [ ] `void handleGetUserStats(const httplib::Request& req, httplib::Response& res)`
    - [ ] `void handleBatchCheckFollowStatus(const httplib::Request& req, httplib::Response& res)`
  - [ ] 声明registerRoutes()方法

- [ ] ⏳ 创建`src/api/follow_handler.cpp`
  - [ ] 实现handleFollow()：
    ```cpp
    1. 提取路径参数user_id
    2. JWT验证（调用validateToken()）
    3. 调用followService_->followUser()
    4. 构建JSON响应
    5. 设置HTTP状态码
    ```
  - [ ] 实现handleUnfollow()
  - [ ] 实现handleCheckFollowStatus()
  - [ ] 实现handleGetFollowingList()：
    ```cpp
    1. 提取路径参数user_id
    2. 提取查询参数page, page_size
    3. 可选JWT验证（用于返回is_following状态）
    4. 调用followService_->getFollowingList()
    5. 构建JSON响应（包含用户列表和分页信息）
    ```
  - [ ] 实现handleGetFollowerList()
  - [ ] 实现handleGetUserStats()
  - [ ] 实现handleBatchCheckFollowStatus()
  - [ ] 实现registerRoutes()：注册所有路由
    ```cpp
    server.Post("/api/v1/users/:user_id/follow", [this](...) { handleFollow(...); });
    server.Delete("/api/v1/users/:user_id/follow", [this](...) { handleUnfollow(...); });
    server.Get("/api/v1/users/:user_id/follow/status", [this](...) { handleCheckFollowStatus(...); });
    server.Get("/api/v1/users/:user_id/following", [this](...) { handleGetFollowingList(...); });
    server.Get("/api/v1/users/:user_id/followers", [this](...) { handleGetFollowerList(...); });
    server.Get("/api/v1/users/:user_id/stats", [this](...) { handleGetUserStats(...); });
    server.Post("/api/v1/users/follow/batch-status", [this](...) { handleBatchCheckFollowStatus(...); });
    ```

- [ ] ⏳ 修改`src/server/http_server.h`
  - [ ] 添加FollowHandler成员变量
    ```cpp
    std::unique_ptr<FollowHandler> followHandler_;
    ```

- [ ] ⏳ 修改`src/server/http_server.cpp`
  - [ ] 初始化FollowHandler
  - [ ] 注册Follow路由
    ```cpp
    followHandler_->registerRoutes(*server_);
    ```

**输出物**：
- `src/api/follow_handler.{h,cpp}`
- 修改后的`src/server/http_server.{h,cpp}`

**验收标准**：
- [ ] Handler层编译通过
- [ ] 所有API接口注册成功
- [ ] JWT验证正确（继承BaseHandler）
- [ ] JSON响应格式统一
- [ ] HTTP状态码使用正确
- [ ] 代码风格与LikeHandler一致

---

### 阶段6：集成测试（3-4小时）

**目标**：编写完整的集成测试，验证关注功能

**任务清单**：

#### 6.1 准备测试环境（30分钟）

- [ ] ⏳ 编译项目（确保无编译错误）
  ```bash
  cd backend-service
  rm -rf build && mkdir build
  cd build
  cmake ..
  make -j4
  ```
- [ ] ⏳ 启动测试服务器
  ```bash
  ./build/knot_image_sharing config/config.json
  ```
- [ ] ⏳ 准备测试账号（注册3个测试用户）
  - [ ] 用户A（user_alice）
  - [ ] 用户B（user_bob）
  - [ ] 用户C（user_charlie）

#### 6.2 API功能测试（2小时）

使用curl或Postman进行API测试：

- [ ] ⏳ **测试1：关注用户**
  - [ ] 用户A关注用户B（应成功，返回200）
  - [ ] 验证B的follower_count增加1
  - [ ] 验证A的following_count增加1

- [ ] ⏳ **测试2：重复关注（幂等性）**
  - [ ] 用户A再次关注用户B（应返回409）
  - [ ] 验证follower_count没有变化

- [ ] ⏳ **测试3：自我关注拦截**
  - [ ] 用户A尝试关注自己（应返回400）

- [ ] ⏳ **测试4：检查关注关系**
  - [ ] 查询A是否关注B（应返回true）
  - [ ] 查询B是否关注A（应返回false）

- [ ] ⏳ **测试5：取消关注**
  - [ ] 用户A取消关注用户B（应成功，返回200）
  - [ ] 验证B的follower_count减少1
  - [ ] 验证A的following_count减少1

- [ ] ⏳ **测试6：取消未关注的用户**
  - [ ] 用户A再次取消关注用户B（应返回404）

- [ ] ⏳ **测试7：关注列表查询**
  - [ ] 用户A关注用户B和用户C
  - [ ] 查询A的关注列表（应返回[B, C]）
  - [ ] 测试分页功能（page=1, page_size=10）

- [ ] ⏳ **测试8：粉丝列表查询**
  - [ ] 用户A和用户C都关注用户B
  - [ ] 查询B的粉丝列表（应返回[A, C]）

- [ ] ⏳ **测试9：用户统计信息**
  - [ ] 查询用户B的统计信息
  - [ ] 验证following_count, follower_count, post_count正确

- [ ] ⏳ **测试10：批量检查关注关系**
  - [ ] 用户A批量检查[B, C]的关注状态
  - [ ] 验证返回正确的Map

#### 6.3 数据一致性测试（1小时）

- [ ] ⏳ **测试11：并发关注**
  - [ ] 使用多线程模拟10个用户同时关注用户B
  - [ ] 验证follower_count准确无误
  - [ ] 验证无重复关注记录

- [ ] ⏳ **测试12：事务回滚**
  - [ ] 模拟关注操作中途失败（断开数据库连接）
  - [ ] 验证关注记录未创建
  - [ ] 验证follower_count未更新

- [ ] ⏳ **测试13：级联删除**
  - [ ] 删除用户A
  - [ ] 验证A的所有关注记录被删除
  - [ ] 验证被A关注的用户的follower_count正确减少

#### 6.4 性能测试（30分钟）

- [ ] ⏳ **测试14：批量关注性能**
  - [ ] 用户A连续关注100个用户
  - [ ] 测量平均响应时间（目标：<100ms）

- [ ] ⏳ **测试15：关注列表查询性能**
  - [ ] 查询关注1000个用户的列表（分页）
  - [ ] 测量响应时间（目标：<200ms）

**输出物**：
- 测试报告（包含测试用例、测试结果、问题记录）
- 性能测试数据

**验收标准**：
- [ ] 所有功能测试通过（14/14）
- [ ] 数据一致性测试通过
- [ ] 并发测试无死锁、无数据竞争
- [ ] 性能测试达标

---

### 阶段7：文档更新（1小时）

**目标**：更新项目文档，记录新功能

**任务清单**：

- [ ] ⏳ 更新`[000]API文档.md`
  - [ ] 添加"关注系统API"章节
  - [ ] 记录7个API接口的完整文档
  - [ ] 更新版本历史（v2.3.0）

- [ ] ⏳ 更新`[001]数据库设计文档.md`
  - [ ] 添加follows表结构说明
  - [ ] 更新users表字段说明
  - [ ] 更新表关系图（ER图）

- [ ] ⏳ 更新`CLAUDE.md`
  - [ ] 更新"当前状态"（添加关注系统）
  - [ ] 更新"功能模块统计"
  - [ ] 更新"代码规模"统计

- [ ] ⏳ 更新`README.md`
  - [ ] 更新功能列表
  - [ ] 更新版本历史

- [ ] ⏳ 创建本文档的"完成报告"
  - [ ] 记录实际完成时间
  - [ ] 记录遇到的问题和解决方案
  - [ ] 记录性能测试数据
  - [ ] 记录后续优化建议

**输出物**：
- 更新后的项目文档（4个文件）
- 完成报告（Markdown）

**验收标准**：
- [ ] 所有文档更新完成
- [ ] API文档详细准确
- [ ] 数据库设计文档包含ER图
- [ ] 版本历史记录完整

---

## 关键技术点

### 1. 单向关注机制设计

**概念定义**：
- **follower（关注者）**: 主动方，执行关注操作的用户
- **followee（被关注者）**: 被动方，被关注的用户

**数据流示例**：
```
用户A关注用户B：
1. follows表插入：(follower_id=A, followee_id=B)
2. users表更新：A的following_count +1
3. users表更新：B的follower_count +1
```

**双向查询优化**：
- 查询"我关注的人"：`WHERE follower_id = A` → 使用索引 idx_follower_create
- 查询"关注我的人"：`WHERE followee_id = A` → 使用索引 idx_followee_create

---

### 2. 防止自我关注

**实现位置**：Service层（不在数据库层）

**检查逻辑**：
```cpp
if (followerId == followeeId) {
    return {false, "不能关注自己", 0, 0, false, 400};
}
```

**设计理由**：
- 数据库CHECK约束不支持跨列比较
- 应用层检查更灵活（可自定义错误消息）
- 与业务逻辑解耦

---

### 3. 冗余计数的原子更新

**问题**：
- 关注操作需要同时更新3个地方：follows表 + A的following_count + B的follower_count
- 必须保证原子性，否则数据不一致

**解决方案**：使用TransactionGuard

```cpp
TransactionGuard trans(conn);

// 1. 插入关注记录
followRepo_->create(conn, followerId, followeeId);

// 2. 原子更新关注数
userRepo_->incrementFollowingCount(conn, followerId);

// 3. 原子更新粉丝数
userRepo_->incrementFollowerCount(conn, followeeId);

trans.commit();  // 提交事务
```

**SQL原子更新**：
```sql
-- 避免先SELECT再UPDATE的竞态条件
UPDATE users SET following_count = following_count + 1 WHERE id = ?;
```

---

### 4. 批量查询优化

**场景**：Feed流展示100个帖子，需要检查当前用户是否关注这些帖子的作者

**naive方案**（N次查询）：
```cpp
for (auto& post : posts) {
    post.is_following = followRepo_->exists(conn, currentUserId, post.authorId);
}
// 问题：100个帖子 = 100次SQL查询
```

**优化方案**（1次查询）：
```cpp
// 1. 提取所有作者ID
std::vector<int> authorIds = extractAuthorIds(posts);

// 2. 批量查询
std::map<int, bool> followMap = followRepo_->batchCheckExists(conn, currentUserId, authorIds);

// 3. 填充结果
for (auto& post : posts) {
    post.is_following = followMap[post.authorId];
}
// 优点：1次SQL查询（使用IN子句）
```

**SQL实现**：
```sql
SELECT followee_id FROM follows
WHERE follower_id = ? AND followee_id IN (?, ?, ?, ..., ?)
```

---

### 5. 分页查询性能优化

**问题**：查询"我关注的1000个用户"时，OFFSET大导致性能下降

**优化方案1**：使用游标分页（基于create_time）
```sql
-- 第一页
SELECT * FROM follows WHERE follower_id = ? ORDER BY create_time DESC LIMIT 20;

-- 第二页（使用上一页的最后一个create_time）
SELECT * FROM follows
WHERE follower_id = ? AND create_time < ?
ORDER BY create_time DESC LIMIT 20;
```

**优化方案2**：添加复合索引
```sql
INDEX idx_follower_create (follower_id, create_time DESC)
-- 覆盖索引，避免回表查询
```

---

### 6. 级联删除的数据一致性

**场景**：用户A被删除时，需要清理所有关注关系

**自动清理**（外键级联删除）：
```sql
FOREIGN KEY (follower_id) REFERENCES users(id) ON DELETE CASCADE
FOREIGN KEY (followee_id) REFERENCES users(id) ON DELETE CASCADE
```

**数据一致性问题**：
- 删除用户A后，follows表的记录自动删除
- 但其他用户的follower_count没有更新

**解决方案**：应用层触发器（在UserService.deleteUser()中）
```cpp
void UserService::deleteUser(int userId) {
    TransactionGuard trans(conn);

    // 1. 查询A的粉丝列表
    auto followers = followRepo_->findFollowersByUserId(conn, userId);
    for (auto& follower : followers) {
        userRepo_->decrementFollowingCount(conn, follower.getId());
    }

    // 2. 查询A关注的人列表
    auto following = followRepo_->findFollowingByUserId(conn, userId);
    for (auto& followee : following) {
        userRepo_->decrementFollowerCount(conn, followee.getId());
    }

    // 3. 删除用户（自动触发级联删除）
    userRepo_->deleteById(conn, userId);

    trans.commit();
}
```

---

## 风险和注意事项

### 1. 数据一致性风险

**风险描述**：
- 关注操作涉及3个数据更新点：follows表 + 2个用户的计数字段
- 高并发场景下可能出现数据不一致

**防范措施**：
- ✅ 使用TransactionGuard保证事务原子性
- ✅ 使用SQL原子更新（UPDATE ... SET count = count + 1）
- ✅ 添加数据库唯一约束（防止重复关注）
- ⚠️ 定期运行数据一致性检查脚本（对比follows表COUNT和冗余字段）

**一致性检查SQL**：
```sql
-- 检查following_count是否一致
SELECT u.id, u.username, u.following_count, COUNT(f.id) as actual_count
FROM users u
LEFT JOIN follows f ON u.id = f.follower_id
GROUP BY u.id
HAVING u.following_count != COUNT(f.id);

-- 检查follower_count是否一致
SELECT u.id, u.username, u.follower_count, COUNT(f.id) as actual_count
FROM users u
LEFT JOIN follows f ON u.id = f.followee_id
GROUP BY u.id
HAVING u.follower_count != COUNT(f.id);
```

---

### 2. 性能瓶颈风险

**风险点1**：关注列表查询（JOIN查询）

**问题**：
```sql
SELECT * FROM follows f
INNER JOIN users u ON f.followee_id = u.id
WHERE f.follower_id = ?
ORDER BY f.create_time DESC
LIMIT 20 OFFSET 100;
```
- OFFSET越大，性能越差（MySQL需要扫描前100+20行）

**优化方案**：
- ✅ 使用复合索引(follower_id, create_time DESC)
- ⚠️ 限制最大OFFSET（如：最多查询前1000个关注）
- 🔮 未来优化：使用游标分页（基于create_time）

**风险点2**：批量检查关注关系（IN查询）

**问题**：
```sql
SELECT followee_id FROM follows
WHERE follower_id = ? AND followee_id IN (?, ?, ..., ?)  -- 100个ID
```
- IN子句过长可能导致性能下降

**优化方案**：
- ✅ 限制批量查询最多100个ID
- ✅ 使用唯一索引加速查询
- 🔮 未来优化：使用Redis缓存关注关系

---

### 3. 存储空间风险

**风险描述**：
- 假设平均每用户关注100人
- 100万用户 = 1亿条关注记录
- 每条记录约32字节（id+follower_id+followee_id+create_time）
- 总存储：1亿 * 32字节 = 3.2GB

**防范措施**：
- ✅ 定期清理僵尸账号的关注关系
- ✅ 使用BIGINT类型（支持更大规模）
- ⚠️ 监控数据库存储空间
- 🔮 未来优化：按时间分区（冷热数据分离）

---

### 4. 并发冲突风险

**风险场景**：
- 用户A同时在手机和网页端点击"关注B"
- 两个请求几乎同时到达服务器

**可能的问题**：
- 重复插入关注记录
- follower_count被重复递增

**防范措施**：
- ✅ 数据库唯一约束（uk_follower_followee）防止重复插入
- ✅ 唯一约束冲突时，Service层捕获异常，返回409错误
- ✅ 使用事务保证原子性

**异常处理代码**：
```cpp
try {
    followRepo_->create(conn, followerId, followeeId);
} catch (const std::exception& e) {
    // 捕获唯一约束冲突
    if (strstr(e.what(), "Duplicate entry")) {
        return {false, "已经关注过该用户", 0, 0, true, 409};
    }
    throw;  // 其他异常继续抛出
}
```

---

### 5. 代码复杂度风险

**风险描述**：
- Follow系统比Like/Favorite系统复杂得多
- 7个API接口 vs 2个API接口
- 双向查询 vs 单向查询
- 用户间关系 vs 用户-帖子关系

**防范措施**：
- ✅ 复用Like/Favorite系统的设计模式
- ✅ 详细的代码注释（Doxygen格式）
- ✅ 统一的错误处理机制
- ✅ 完善的单元测试和集成测试

---

## 验收标准

### 功能验收

- [ ] ✅ 用户可以成功关注其他用户
- [ ] ✅ 用户可以成功取消关注
- [ ] ✅ 防止重复关注（幂等性）
- [ ] ✅ 防止自我关注
- [ ] ✅ 关注数/粉丝数实时更新
- [ ] ✅ 关注列表查询正常（带分页）
- [ ] ✅ 粉丝列表查询正常（带分页）
- [ ] ✅ 用户统计信息准确
- [ ] ✅ 批量检查关注关系正常

### 数据一致性验收

- [ ] ✅ 关注操作后，follows表、following_count、follower_count三者一致
- [ ] ✅ 取消关注后，计数正确减少
- [ ] ✅ 并发场景下无数据竞争
- [ ] ✅ 事务回滚后数据恢复一致
- [ ] ✅ 用户删除后，关注关系自动清理

### 性能验收

- [ ] ✅ 关注/取消关注响应时间 < 100ms（单次操作）
- [ ] ✅ 关注列表查询响应时间 < 200ms（分页20条）
- [ ] ✅ 批量检查100个用户关注状态响应时间 < 300ms
- [ ] ✅ 并发100个关注请求，无死锁

### 代码质量验收

- [ ] ✅ 代码编译通过，无警告
- [ ] ✅ 所有SQL查询使用预编译语句
- [ ] ✅ 使用ConnectionGuard和TransactionGuard
- [ ] ✅ 错误处理完善，日志记录完整
- [ ] ✅ 代码风格与现有代码一致
- [ ] ✅ Doxygen注释完整

### 文档验收

- [ ] ✅ API文档详细准确（7个接口）
- [ ] ✅ 数据库设计文档更新（follows表、ER图）
- [ ] ✅ CLAUDE.md和README.md更新
- [ ] ✅ 测试报告完整（功能测试、性能测试）

---

## 进度跟踪

### 时间规划

| 阶段 | 任务 | 预计工时 | 实际工时 | 完成度 | 负责人 | 状态 |
|------|------|----------|----------|--------|--------|------|
| 阶段0 | 数据库调研 | 0.5小时 | - | 0% | Claude | ⏳ 待开始 |
| 阶段1 | 数据库变更 | 1小时 | - | 0% | Claude | ⏳ 待开始 |
| 阶段2 | Model层 | 2小时 | - | 0% | Claude | ⏳ 待开始 |
| 阶段3 | Repository层 | 4.5小时 | - | 0% | Claude | ⏳ 待开始 |
| 阶段4 | Service层 | 4.5小时 | - | 0% | Claude | ⏳ 待开始 |
| 阶段5 | Handler层 | 3小时 | - | 0% | Claude | ⏳ 待开始 |
| 阶段6 | 集成测试 | 3.5小时 | - | 0% | Claude | ⏳ 待开始 |
| 阶段7 | 文档更新 | 1小时 | - | 0% | Claude | ⏳ 待开始 |
| **总计** | **全部任务** | **20小时** | **0小时** | **0%** | - | ⏳ 待开始 |

### 里程碑

| 里程碑 | 目标 | 预计完成时间 | 实际完成时间 | 状态 |
|--------|------|-------------|-------------|------|
| M1 | 数据库设计完成 | Day 1 | - | ⏳ 待开始 |
| M2 | Model + Repository完成 | Day 2 | - | ⏳ 待开始 |
| M3 | Service + Handler完成 | Day 3 | - | ⏳ 待开始 |
| M4 | 集成测试通过 | Day 4 | - | ⏳ 待开始 |
| M5 | 文档更新，正式发布 | Day 4 | - | ⏳ 待开始 |

---

## 变更日志

| 日期 | 版本 | 变更内容 | 变更人 |
|------|------|---------|--------|
| 2025-10-11 | v1.0.0 | 创建关注功能实现计划文档 | Claude |

---

## 后续工作展望

### v2.4.0：关注Feed流（依赖v2.3.0）

**功能**：
- 查看关注用户的最新帖子（关注Feed）
- Feed流按时间倒序排列
- 支持下拉刷新

**技术挑战**：
- 性能优化：查询关注的100个用户的最新帖子
- 缓存策略：使用Redis缓存用户的关注列表

---

### v3.0.0：推荐算法

**功能**：
- 基于关注图谱的用户推荐
- 基于标签相似度的帖子推荐
- 热门创作者推荐

**技术挑战**：
- 社交图谱分析（共同关注、二度人脉）
- 协同过滤算法
- 离线计算 + 实时查询

---

### v4.0.0：通知系统

**功能**：
- 新粉丝通知
- 关注的用户发布新帖子通知
- 点赞/评论通知

**技术挑战**：
- 消息队列（RabbitMQ/Kafka）
- WebSocket实时推送
- 通知聚合（防止刷屏）

---

**文档结束**
