# 用户头像上传功能 - 实施方案

**文档编号**: [120]
**创建时间**: 2025-10-18
**版本**: v1.0.0
**目标版本**: v2.6.0
**状态**: 📋 待实施

---

## 📋 任务概述

为Knot图片分享系统补充完整的用户头像上传功能，实现文件直接上传、自动压缩裁剪、旧文件删除等核心特性。

### 功能概述

用户可以通过API直接上传头像图片文件，系统将自动：
1. 验证文件格式和大小（支持JPEG/PNG/GIF/WebP，最大5MB）
2. 裁剪为正方形（居中裁剪）
3. 缩放到标准尺寸（200x200）
4. 压缩保存（JPEG 80%质量）
5. 删除旧头像文件（节省存储空间）
6. 返回完整头像URL（带服务器前缀）

### 实施范围

| 序号 | 模块 | 文件 | 工作内容 | 优先级 | 预计耗时 |
|------|------|------|----------|--------|----------|
| 1 | 基础设施 | 存储目录 | 创建`/uploads/avatars/`目录 | P0 | 5分钟 |
| 2 | 工具层 | `avatar_processor.h/cpp` | 头像处理工具类 | P0 | 2小时 |
| 3 | Repository层 | `user_repository.h/cpp` | 添加`updateAvatarUrl()`方法 | P0 | 30分钟 |
| 4 | Service层 | `auth_service.h/cpp` | 添加`uploadAvatar()`方法 | P0 | 1小时 |
| 5 | Handler层 | `auth_handler.h/cpp` | 添加`handleUploadAvatar()`方法 | P0 | 1.5小时 |
| 6 | 测试与文档 | 各类文档 | API测试、文档更新 | P1 | 1小时 |

**总工作量**: 约6-7小时

---

## 🎯 当前功能现状分析

### ✅ 已实现的部分

#### 1. 数据库层面（已完成）
- ✅ `users`表已有`avatar_url`字段（VARCHAR(255) NULL）
- ✅ 支持存储头像URL路径

#### 2. Model层（已完成）
- ✅ User类已包含`avatarUrl_`成员变量
- ✅ `getAvatarUrl()` / `setAvatarUrl()` 方法已实现
- ✅ `toJson()`方法通过`UrlHelper::toFullUrl()`自动添加服务器URL前缀
- ✅ `fromJson()`方法支持解析`avatar_url`字段

#### 3. Repository层（已完成）
- ✅ `createUser()` - 支持插入头像URL
- ✅ `updateUser()` - 支持更新头像URL
- ✅ `updateUserProfile()` - 支持通过修改用户信息API更新头像URL

#### 4. Service层（已完成）
- ✅ `updateUserProfile()` - 支持通过字符串形式的URL更新头像
- ✅ 空值保护：如果`avatarUrl`参数为空，保持原有值

#### 5. Handler层（已完成）
- ✅ `PUT /api/v1/users/profile` - 支持通过JSON传递`avatar_url`字段
- ✅ 响应中自动包含完整的头像URL（带服务器前缀）

#### 6. URL辅助工具（已完成）
- ✅ `UrlHelper::toFullUrl()` - 自动为相对路径添加服务器URL前缀
- ✅ 在所有返回用户信息的地方都已应用

#### 7. 存储目录（部分完成）
- ✅ `/uploads/images/` - 帖子原图
- ✅ `/uploads/thumbnails/` - 帖子缩略图
- ⏳ `/uploads/avatars/` - **待创建**

### ❌ 缺失的部分（需要实现）

#### 1. 头像上传API（核心缺失）
```plaintext
❌ POST /api/v1/users/avatar
   - 接收multipart/form-data格式的文件上传
   - JWT认证
   - 文件大小验证（最大5MB）
   - 格式验证（JPEG/PNG/GIF/WebP）
```

**当前问题**：只能通过`PUT /api/v1/users/profile`手动传递完整URL字符串，**无法直接上传图片文件**。

#### 2. 头像处理工具类（未实现）
```plaintext
❌ src/utils/avatar_processor.h
❌ src/utils/avatar_processor.cpp
```

需要功能：
- 图片裁剪为正方形（居中裁剪）
- 缩放到标准尺寸（200x200）
- JPEG压缩（80%质量）
- 自动删除旧头像文件
- 文件验证（格式、大小）

#### 3. Repository层头像专用方法（未实现）
```cpp
❌ bool updateAvatarUrl(int userId, const std::string& avatarUrl);
```

说明：虽然有`updateUserProfile()`，但头像上传场景需要单独的轻量级更新方法。

#### 4. Service层头像上传方法（未实现）
```cpp
❌ struct UploadAvatarResult {
    bool success;
    std::string message;
    std::string avatarUrl;
    int width;
    int height;
    long long fileSize;
};

❌ UploadAvatarResult uploadAvatar(int userId, const std::string& tempFilePath);
```

#### 5. Handler层头像上传处理（未实现）
```cpp
❌ void handleUploadAvatar(const httplib::Request& req, httplib::Response& res);
```

---

## 📐 技术设计

### API设计

**接口**: `POST /api/v1/users/avatar`

**请求头**:
```http
Authorization: Bearer {access_token}
Content-Type: multipart/form-data
```

**请求参数**:
| 参数名 | 类型 | 必填 | 说明 | 限制 |
|--------|------|------|------|------|
| avatar | File | 是 | 头像图片文件 | 最大5MB，支持JPEG/PNG/GIF/WebP |

**成功响应** (200):
```json
{
  "success": true,
  "message": "头像上传成功",
  "data": {
    "avatar_url": "http://43.142.157.145:8080/uploads/avatars/USR_2025Q4_abc123_1729584000.jpg",
    "width": 200,
    "height": 200,
    "file_size": 45678
  },
  "timestamp": 1729584000
}
```

**错误响应**:
| 状态码 | 说明 | message示例 |
|--------|------|-------------|
| 400 | 未提供文件 | "请上传头像文件" |
| 400 | 文件格式不支持 | "不支持的文件格式，仅支持JPEG/PNG/GIF/WebP" |
| 400 | 文件过大 | "文件大小超过限制（最大5MB）" |
| 401 | 未授权 | "未提供认证令牌" / "令牌无效或已过期" |
| 500 | 服务器错误 | "头像处理失败" / "数据库更新失败" |

### 技术参数

| 参数 | 值 | 说明 |
|------|-----|------|
| 头像尺寸 | 200x200 | 固定正方形 |
| JPEG质量 | 80% | 压缩质量 |
| 最大文件大小 | 5MB | 上传限制 |
| 支持格式 | JPEG, PNG, GIF, WebP | 图片格式白名单 |
| 存储路径 | `/uploads/avatars/` | 相对路径 |
| 文件命名 | `{USER_ID}_{timestamp}.jpg` | 例：USR_2025Q4_abc123_1729584000.jpg |

### 文件处理流程

```
用户上传文件（multipart/form-data）
       ↓
Handler层接收文件 + JWT验证
       ↓
保存临时文件（/tmp/avatar_xxxxx）
       ↓
Service层：调用AvatarProcessor处理
       ↓
AvatarProcessor工作流程：
  1. 加载图片（stb_image）
  2. 验证格式和大小
  3. 居中裁剪为正方形
  4. 缩放到200x200（stb_image_resize）
  5. 保存为JPEG 80%质量（stb_image_write）
       ↓
获取旧头像URL → 删除旧文件
       ↓
Repository层：更新数据库avatar_url字段
       ↓
删除临时文件
       ↓
返回新头像URL（带服务器前缀）
```

### 数据库设计

**无需修改数据库结构**，复用现有`users`表的`avatar_url`字段：

```sql
-- users表（已存在）
CREATE TABLE users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL UNIQUE,
    username VARCHAR(50) NOT NULL UNIQUE,
    avatar_url VARCHAR(255) NULL COMMENT '头像URL',  -- 复用此字段
    ...
);
```

**存储值示例**：
```
/uploads/avatars/USR_2025Q4_abc123_1729584000.jpg
```

**返回给客户端**：
```
http://43.142.157.145:8080/uploads/avatars/USR_2025Q4_abc123_1729584000.jpg
```

---

## 📝 详细实施步骤

### 阶段0：前置准备（5分钟）

#### 任务0.1：创建存储目录

**执行命令**：
```bash
cd /home/kun/projects/SharePix/backend-service
mkdir -p uploads/avatars
chmod 755 uploads/avatars
```

**验证**：
```bash
ls -la uploads/
# 应显示：drwxr-xr-x  avatars
```

---

### 阶段1：工具层 - 头像处理器（2小时）

#### 任务1.1：创建 `src/utils/avatar_processor.h`

**文件路径**：`/home/kun/projects/SharePix/backend-service/src/utils/avatar_processor.h`

**完整代码**：
```cpp
/**
 * @file avatar_processor.h
 * @brief 头像处理工具类定义
 * @author Knot Team
 * @date 2025-10-18
 */

#pragma once

#include <string>
#include <utility>

/**
 * @brief 头像处理结果结构体
 */
struct AvatarProcessResult {
    bool success;              // 处理是否成功
    std::string message;       // 错误信息（如果失败）
    std::string avatarPath;    // 头像路径（相对路径，例：/uploads/avatars/USR_xxx_1234567890.jpg）
    int width;                 // 图片宽度（固定200）
    int height;                // 图片高度（固定200）
    long long fileSize;        // 文件大小（字节）
    
    AvatarProcessResult() : success(false), width(0), height(0), fileSize(0) {}
};

/**
 * @brief 头像处理工具类
 * 
 * 专门用于处理用户头像上传，包括裁剪、压缩、保存
 * 技术栈：stb_image, stb_image_resize, stb_image_write
 */
class AvatarProcessor {
public:
    /**
     * @brief 处理头像图片（裁剪为正方形 + 缩放 + 压缩）
     * 
     * 处理流程：
     * 1. 加载图片
     * 2. 验证格式和大小
     * 3. 如果不是正方形，居中裁剪为正方形
     * 4. 缩放到200x200
     * 5. 保存为JPEG（80%质量）
     * 
     * @param inputPath 输入图片路径（临时文件）
     * @param userId 用户逻辑ID（用于生成文件名，例：USR_2025Q4_abc123）
     * @param outputDir 输出目录（例：uploads/avatars/）
     * @return AvatarProcessResult 处理结果
     */
    static AvatarProcessResult processAvatar(
        const std::string& inputPath,
        const std::string& userId,
        const std::string& outputDir
    );
    
    /**
     * @brief 删除旧头像文件
     * 
     * @param avatarUrl 旧头像URL（相对路径，例：/uploads/avatars/USR_xxx_1234567890.jpg）
     * @return bool 成功返回true，失败或文件不存在返回false
     */
    static bool deleteOldAvatar(const std::string& avatarUrl);
    
    /**
     * @brief 验证头像文件格式和大小
     * 
     * @param filePath 文件路径
     * @param maxSize 最大文件大小（字节），默认5MB
     * @return std::pair<bool, std::string> {是否有效, 错误信息}
     */
    static std::pair<bool, std::string> validateAvatarFile(
        const std::string& filePath,
        long long maxSize = 5 * 1024 * 1024
    );

private:
    // 常量定义
    static constexpr int AVATAR_SIZE = 200;        // 头像尺寸（200x200）
    static constexpr int JPEG_QUALITY = 80;        // JPEG压缩质量（80%）
    static constexpr long long MAX_FILE_SIZE = 5 * 1024 * 1024;  // 最大文件大小（5MB）
    
    /**
     * @brief 裁剪图片为正方形（居中裁剪）
     * 
     * @param inputData 输入图片数据
     * @param width 原图宽度
     * @param height 原图高度
     * @param channels 通道数
     * @param outSize 输出正方形边长（返回值）
     * @return unsigned char* 裁剪后的图片数据（需要手动释放）
     */
    static unsigned char* cropToSquare(
        unsigned char* inputData,
        int width,
        int height,
        int channels,
        int& outSize
    );
};
```

**关键点**：
- 使用`AvatarProcessResult`结构体统一返回结果
- 文件命名格式：`{userId}_{timestamp}.jpg`
- 支持格式验证、大小验证、裁剪、缩放、压缩
- 自动删除旧头像文件

---

#### 任务1.2：实现 `src/utils/avatar_processor.cpp`

**文件路径**：`/home/kun/projects/SharePix/backend-service/src/utils/avatar_processor.cpp`

**完整代码**：
```cpp
/**
 * @file avatar_processor.cpp
 * @brief 头像处理工具类实现
 * @author Knot Team
 * @date 2025-10-18
 */

#include "avatar_processor.h"
#include "logger.h"

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#define STB_IMAGE_RESIZE_IMPLEMENTATION
#include "stb_image_resize.h"

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"

#include <ctime>
#include <cstdio>
#include <sys/stat.h>
#include <unistd.h>
#include <cstring>

// 处理头像图片
AvatarProcessResult AvatarProcessor::processAvatar(
    const std::string& inputPath,
    const std::string& userId,
    const std::string& outputDir
) {
    AvatarProcessResult result;
    
    try {
        Logger::info("开始处理头像: userId=" + userId + ", inputPath=" + inputPath);
        
        // 1. 验证文件
        auto [valid, errorMsg] = validateAvatarFile(inputPath);
        if (!valid) {
            result.message = errorMsg;
            Logger::error("头像文件验证失败: " + errorMsg);
            return result;
        }
        
        // 2. 加载图片
        int width, height, channels;
        unsigned char* imageData = stbi_load(inputPath.c_str(), &width, &height, &channels, 0);
        
        if (!imageData) {
            result.message = "无法加载图片文件";
            Logger::error("stbi_load失败: " + inputPath);
            return result;
        }
        
        Logger::info("图片加载成功: " + std::to_string(width) + "x" + std::to_string(height) + ", channels=" + std::to_string(channels));
        
        // 3. 裁剪为正方形（如果需要）
        unsigned char* squareData = nullptr;
        int squareSize = 0;
        
        if (width != height) {
            squareData = cropToSquare(imageData, width, height, channels, squareSize);
            stbi_image_free(imageData);  // 释放原图数据
            
            if (!squareData) {
                result.message = "图片裁剪失败";
                Logger::error("cropToSquare失败");
                return result;
            }
            
            Logger::info("图片裁剪成功: " + std::to_string(squareSize) + "x" + std::to_string(squareSize));
        } else {
            squareData = imageData;
            squareSize = width;
        }
        
        // 4. 缩放到200x200
        unsigned char* resizedData = (unsigned char*)malloc(AVATAR_SIZE * AVATAR_SIZE * channels);
        if (!resizedData) {
            result.message = "内存分配失败";
            Logger::error("malloc失败");
            if (squareData != imageData) free(squareData);
            return result;
        }
        
        int resizeResult = stbir_resize_uint8(
            squareData, squareSize, squareSize, 0,
            resizedData, AVATAR_SIZE, AVATAR_SIZE, 0,
            channels
        );
        
        // 释放正方形数据
        if (squareData != imageData) {
            free(squareData);
        }
        
        if (!resizeResult) {
            result.message = "图片缩放失败";
            Logger::error("stbir_resize_uint8失败");
            free(resizedData);
            return result;
        }
        
        Logger::info("图片缩放成功: " + std::to_string(AVATAR_SIZE) + "x" + std::to_string(AVATAR_SIZE));
        
        // 5. 生成输出文件名
        std::time_t now = std::time(nullptr);
        std::string filename = userId + "_" + std::to_string(now) + ".jpg";
        std::string outputPath = outputDir + filename;
        
        // 6. 保存为JPEG
        int writeResult = stbi_write_jpg(
            outputPath.c_str(),
            AVATAR_SIZE,
            AVATAR_SIZE,
            channels,
            resizedData,
            JPEG_QUALITY
        );
        
        free(resizedData);  // 释放缩放后的数据
        
        if (!writeResult) {
            result.message = "保存图片失败";
            Logger::error("stbi_write_jpg失败: " + outputPath);
            return result;
        }
        
        // 7. 获取文件大小
        struct stat fileStat;
        if (stat(outputPath.c_str(), &fileStat) == 0) {
            result.fileSize = fileStat.st_size;
        }
        
        // 8. 填充结果
        result.success = true;
        result.message = "头像处理成功";
        result.avatarPath = "/uploads/avatars/" + filename;
        result.width = AVATAR_SIZE;
        result.height = AVATAR_SIZE;
        
        Logger::info("头像处理完成: " + result.avatarPath + ", fileSize=" + std::to_string(result.fileSize));
        
        return result;
        
    } catch (const std::exception& e) {
        result.message = "头像处理异常: " + std::string(e.what());
        Logger::error(result.message);
        return result;
    }
}

// 删除旧头像文件
bool AvatarProcessor::deleteOldAvatar(const std::string& avatarUrl) {
    if (avatarUrl.empty() || avatarUrl.find("/uploads/avatars/") == std::string::npos) {
        return false;  // 不是头像文件路径，不处理
    }
    
    // 构建完整文件路径
    std::string filePath = "." + avatarUrl;  // 相对于项目根目录
    
    if (unlink(filePath.c_str()) == 0) {
        Logger::info("旧头像已删除: " + avatarUrl);
        return true;
    } else {
        Logger::warning("删除旧头像失败: " + avatarUrl + " (文件可能不存在)");
        return false;
    }
}

// 验证头像文件
std::pair<bool, std::string> AvatarProcessor::validateAvatarFile(
    const std::string& filePath,
    long long maxSize
) {
    // 1. 检查文件是否存在
    struct stat fileStat;
    if (stat(filePath.c_str(), &fileStat) != 0) {
        return {false, "文件不存在"};
    }
    
    // 2. 检查文件大小
    if (fileStat.st_size > maxSize) {
        return {false, "文件大小超过限制（最大5MB）"};
    }
    
    if (fileStat.st_size == 0) {
        return {false, "文件为空"};
    }
    
    // 3. 检查文件格式（通过stb_image尝试加载）
    int width, height, channels;
    if (!stbi_info(filePath.c_str(), &width, &height, &channels)) {
        return {false, "不支持的文件格式，仅支持JPEG/PNG/GIF/WebP"};
    }
    
    // 4. 检查图片尺寸合法性
    if (width <= 0 || height <= 0) {
        return {false, "无效的图片尺寸"};
    }
    
    if (width > 10000 || height > 10000) {
        return {false, "图片尺寸过大（最大10000x10000）"};
    }
    
    return {true, ""};
}

// 裁剪图片为正方形（居中裁剪）
unsigned char* AvatarProcessor::cropToSquare(
    unsigned char* inputData,
    int width,
    int height,
    int channels,
    int& outSize
) {
    if (!inputData || width <= 0 || height <= 0 || channels <= 0) {
        return nullptr;
    }
    
    // 计算正方形边长（取较小值）
    int size = (width < height) ? width : height;
    outSize = size;
    
    // 计算裁剪起始位置（居中）
    int offsetX = (width - size) / 2;
    int offsetY = (height - size) / 2;
    
    // 分配输出内存
    unsigned char* outputData = (unsigned char*)malloc(size * size * channels);
    if (!outputData) {
        return nullptr;
    }
    
    // 逐行复制像素数据
    for (int y = 0; y < size; y++) {
        int srcY = offsetY + y;
        int srcOffset = (srcY * width + offsetX) * channels;
        int dstOffset = (y * size) * channels;
        
        memcpy(
            outputData + dstOffset,
            inputData + srcOffset,
            size * channels
        );
    }
    
    return outputData;
}
```

**关键实现点**：
1. **验证文件**：检查大小、格式、尺寸合法性
2. **加载图片**：使用`stbi_load()`加载任意格式
3. **裁剪为正方形**：居中裁剪（取短边）
4. **缩放**：使用`stbir_resize_uint8()`缩放到200x200
5. **保存**：使用`stbi_write_jpg()`保存为JPEG（80%质量）
6. **内存管理**：及时释放stb分配的内存
7. **错误处理**：每一步都有详细的日志和错误信息

---

#### 任务1.3：更新CMakeLists.txt

**文件路径**：`/home/kun/projects/SharePix/backend-service/CMakeLists.txt`

**在源文件列表中添加**：
```cmake
# 在 set(SOURCES ...) 中添加
src/utils/avatar_processor.cpp
```

**示例位置**：
```cmake
set(SOURCES
    src/main.cpp
    src/server/http_server.cpp
    src/utils/logger.cpp
    src/utils/config_manager.cpp
    src/utils/id_generator.cpp
    src/utils/image_processor.cpp
    src/utils/avatar_processor.cpp  # ← 新增
    ...
)
```

---

### 阶段2：Repository层（30分钟）

#### 任务2.1：修改 `src/database/user_repository.h`

**文件路径**：`/home/kun/projects/SharePix/backend-service/src/database/user_repository.h`

**在类定义中添加方法声明**（在`updateUserProfile()`方法之后）：

```cpp
/**
 * @brief 更新用户头像URL（轻量级更新方法）
 * 
 * 专用于头像上传场景，仅更新avatar_url字段
 * 
 * @param userId 用户物理ID
 * @param avatarUrl 新的头像URL（相对路径，例：/uploads/avatars/USR_xxx_1234567890.jpg）
 * @return true 更新成功，false 更新失败
 */
bool updateAvatarUrl(int userId, const std::string& avatarUrl);
```

**插入位置参考**：
```cpp
class UserRepository {
public:
    // ... 其他方法 ...
    
    bool updateUserProfile(int userId,
                          const std::string& realName,
                          const std::string& email,
                          const std::string& phone,
                          const std::string& avatarUrl,
                          const std::string& bio,
                          const std::string& gender,
                          const std::string& location);
    
    bool updateAvatarUrl(int userId, const std::string& avatarUrl);  // ← 新增
    
    // ... 其他方法 ...
};
```

---

#### 任务2.2：实现 `src/database/user_repository.cpp`

**文件路径**：`/home/kun/projects/SharePix/backend-service/src/database/user_repository.cpp`

**在文件末尾添加方法实现**：

```cpp
// 更新用户头像URL
bool UserRepository::updateAvatarUrl(int userId, const std::string& avatarUrl) {
    try {
        Logger::info("更新用户头像URL: userId=" + std::to_string(userId));
        
        // 1. 使用ConnectionGuard自动管理连接
        ConnectionGuard connGuard(DatabaseConnectionPool::getInstance());
        if (!connGuard.isValid()) {
            Logger::error("获取数据库连接失败");
            return false;
        }
        
        MYSQL* conn = connGuard.get();
        
        // 2. 准备SQL语句
        const char* query = "UPDATE users SET avatar_url = ?, update_time = CURRENT_TIMESTAMP WHERE id = ?";
        
        // 3. 创建预编译语句
        MYSQL_STMT* stmt = mysql_stmt_init(conn);
        if (!stmt) {
            Logger::error("mysql_stmt_init失败");
            return false;
        }
        
        // 4. 预编译SQL
        if (mysql_stmt_prepare(stmt, query, strlen(query)) != 0) {
            Logger::error("mysql_stmt_prepare失败: " + std::string(mysql_stmt_error(stmt)));
            mysql_stmt_close(stmt);
            return false;
        }
        
        // 5. 绑定参数
        MYSQL_BIND bind[2];
        memset(bind, 0, sizeof(bind));
        
        // avatar_url (可为空)
        bool avatar_is_null = avatarUrl.empty();
        
        bind[0].buffer_type = MYSQL_TYPE_STRING;
        bind[0].buffer = (char*)avatarUrl.c_str();
        bind[0].buffer_length = avatarUrl.length();
        bind[0].is_null = &avatar_is_null;
        
        // userId
        bind[1].buffer_type = MYSQL_TYPE_LONG;
        bind[1].buffer = (char*)&userId;
        bind[1].is_null = nullptr;
        
        if (mysql_stmt_bind_param(stmt, bind) != 0) {
            Logger::error("mysql_stmt_bind_param失败: " + std::string(mysql_stmt_error(stmt)));
            mysql_stmt_close(stmt);
            return false;
        }
        
        // 6. 执行更新
        if (mysql_stmt_execute(stmt) != 0) {
            Logger::error("mysql_stmt_execute失败: " + std::string(mysql_stmt_error(stmt)));
            mysql_stmt_close(stmt);
            return false;
        }
        
        // 7. 检查影响行数
        my_ulonglong affected = mysql_stmt_affected_rows(stmt);
        mysql_stmt_close(stmt);
        
        if (affected == 0) {
            Logger::warning("更新头像URL失败: 用户不存在, userId=" + std::to_string(userId));
            return false;
        }
        
        Logger::info("头像URL更新成功: userId=" + std::to_string(userId));
        return true;
        
    } catch (const std::exception& e) {
        Logger::error("updateAvatarUrl异常: " + std::string(e.what()));
        return false;
    }
}
```

**关键点**：
- 使用`ConnectionGuard`自动管理连接
- 使用预编译语句防止SQL注入
- 支持空值处理（允许删除头像）
- 自动更新`update_time`字段
- 检查影响行数确保用户存在

---

#### 任务2.3：编译测试

```bash
cd /home/kun/projects/SharePix/backend-service/build
make -j4
```

**预期结果**：编译成功，无错误

---

### 阶段3：Service层（1小时）

#### 任务3.1：修改 `src/core/auth_service.h`

**文件路径**：`/home/kun/projects/SharePix/backend-service/src/core/auth_service.h`

**在文件顶部添加结构体定义**（在`UsernameCheckResult`之后）：

```cpp
/**
 * @brief 头像上传结果结构体
 */
struct UploadAvatarResult {
    bool success;              // 上传是否成功
    std::string message;       // 错误信息（如果失败）
    std::string avatarUrl;     // 头像URL（相对路径）
    int width;                 // 图片宽度（固定200）
    int height;                // 图片高度（固定200）
    long long fileSize;        // 文件大小（字节）
    
    UploadAvatarResult() : success(false), width(0), height(0), fileSize(0) {}
};
```

**在类定义中添加方法声明**（在`getUserPublicInfo()`之后）：

```cpp
/**
 * @brief 上传用户头像（v2.6.0）
 * 
 * 处理流程：
 * 1. 获取用户信息（获取userId逻辑ID）
 * 2. 调用AvatarProcessor处理图片
 * 3. 删除旧头像文件
 * 4. 更新数据库中的avatar_url字段
 * 5. 返回结果（包含新头像URL）
 * 
 * @param userId 用户物理ID
 * @param tempFilePath 临时文件路径
 * @return UploadAvatarResult 上传结果
 */
UploadAvatarResult uploadAvatar(int userId, const std::string& tempFilePath);
```

---

#### 任务3.2：实现 `src/core/auth_service.cpp`

**文件路径**：`/home/kun/projects/SharePix/backend-service/src/core/auth_service.cpp`

**在文件顶部添加头文件**：
```cpp
#include "../utils/avatar_processor.h"
```

**在文件末尾添加方法实现**：

```cpp
// 上传用户头像
UploadAvatarResult AuthService::uploadAvatar(int userId, const std::string& tempFilePath) {
    UploadAvatarResult result;
    
    try {
        Logger::info("开始上传头像: userId=" + std::to_string(userId) + ", tempFilePath=" + tempFilePath);
        
        // 1. 获取用户信息（获取user_id逻辑ID）
        auto existingUser = userRepo_->findById(userId);
        if (!existingUser.has_value()) {
            result.message = "用户不存在";
            Logger::error(result.message + ", userId=" + std::to_string(userId));
            return result;
        }
        
        std::string userIdStr = existingUser->getUserId();
        
        // 2. 调用AvatarProcessor处理图片
        std::string avatarDir = "uploads/avatars/";
        auto processResult = AvatarProcessor::processAvatar(tempFilePath, userIdStr, avatarDir);
        
        if (!processResult.success) {
            result.message = processResult.message;
            Logger::error("头像处理失败: " + result.message);
            return result;
        }
        
        Logger::info("头像处理成功: " + processResult.avatarPath);
        
        // 3. 获取旧头像URL，删除旧文件
        std::string oldAvatarUrl = existingUser->getAvatarUrl();
        if (!oldAvatarUrl.empty()) {
            AvatarProcessor::deleteOldAvatar(oldAvatarUrl);
        }
        
        // 4. 更新数据库中的avatar_url字段
        bool updateSuccess = userRepo_->updateAvatarUrl(userId, processResult.avatarPath);
        
        if (!updateSuccess) {
            result.message = "更新数据库失败";
            Logger::error(result.message);
            
            // 回滚：删除新上传的头像文件
            AvatarProcessor::deleteOldAvatar(processResult.avatarPath);
            
            return result;
        }
        
        Logger::info("数据库更新成功: userId=" + std::to_string(userId));
        
        // 5. 填充结果
        result.success = true;
        result.message = "头像上传成功";
        result.avatarUrl = processResult.avatarPath;
        result.width = processResult.width;
        result.height = processResult.height;
        result.fileSize = processResult.fileSize;
        
        Logger::info("头像上传完成: userId=" + std::to_string(userId) + ", avatarUrl=" + result.avatarUrl);
        
        return result;
        
    } catch (const std::exception& e) {
        result.message = "头像上传异常: " + std::string(e.what());
        Logger::error(result.message);
        return result;
    }
}
```

**关键点**：
1. **获取用户逻辑ID**：用于生成文件名
2. **调用AvatarProcessor**：处理图片（裁剪+缩放+压缩）
3. **删除旧头像**：节省存储空间
4. **事务性回滚**：如果数据库更新失败，删除新上传的文件
5. **详细日志**：记录每个步骤的执行情况

---

#### 任务3.3：编译测试

```bash
cd /home/kun/projects/SharePix/backend-service/build
make -j4
```

**预期结果**：编译成功，无错误

---

### 阶段4：Handler层（1.5小时）

#### 任务4.1：修改 `src/api/auth_handler.h`

**文件路径**：`/home/kun/projects/SharePix/backend-service/src/api/auth_handler.h`

**在类定义的private部分添加方法声明**（在`handleCheckUsername()`之后）：

```cpp
/**
 * @brief 处理头像上传请求
 *
 * POST /api/v1/users/avatar
 */
void handleUploadAvatar(const httplib::Request& req, httplib::Response& res);
```

---

#### 任务4.2：实现 `src/api/auth_handler.cpp` - 路由注册

**文件路径**：`/home/kun/projects/SharePix/backend-service/src/api/auth_handler.cpp`

**在`registerRoutes()`方法中添加路由**（在用户信息相关路由之后）：

```cpp
void AuthHandler::registerRoutes(httplib::Server& server) {
    // ... 现有路由 ...
    
    // 检查用户名可用性
    server.Get("/api/v1/users/check-username", [this](const httplib::Request& req, httplib::Response& res) {
        handleCheckUsername(req, res);
    });
    
    // 上传用户头像 (v2.6.0)
    server.Post("/api/v1/users/avatar", [this](const httplib::Request& req, httplib::Response& res) {
        handleUploadAvatar(req, res);
    });
    
    Logger::info("Auth routes registered");
}
```

---

#### 任务4.3：实现 `src/api/auth_handler.cpp` - 处理方法

**在文件末尾添加方法实现**：

```cpp
// 处理头像上传请求
void AuthHandler::handleUploadAvatar(const httplib::Request& req, httplib::Response& res) {
    Logger::info("处理头像上传请求");
    
    // 1. 提取并验证JWT令牌
    std::string authHeader = req.get_header_value("Authorization");
    if (authHeader.empty() || authHeader.substr(0, 7) != "Bearer ") {
        sendJsonResponse(res, 401, false, "未提供认证令牌");
        return;
    }
    
    std::string token = authHeader.substr(7);
    
    // 2. 验证令牌
    TokenValidationResult validation = authService_->validateToken(token);
    
    if (!validation.valid) {
        sendJsonResponse(res, 401, false, validation.message);
        return;
    }
    
    // 3. 检查是否有文件上传
    if (!req.has_file("avatar")) {
        sendJsonResponse(res, 400, false, "请上传头像文件");
        Logger::warning("未提供头像文件");
        return;
    }
    
    // 4. 获取上传的文件
    const auto& file = req.get_file_value("avatar");
    
    Logger::info("接收到头像文件: filename=" + file.filename + 
                 ", content_type=" + file.content_type + 
                 ", size=" + std::to_string(file.content.size()));
    
    // 5. 验证文件大小（5MB限制）
    if (file.content.size() > 5 * 1024 * 1024) {
        sendJsonResponse(res, 400, false, "文件大小超过限制（最大5MB）");
        Logger::warning("文件过大: " + std::to_string(file.content.size()) + " bytes");
        return;
    }
    
    if (file.content.empty()) {
        sendJsonResponse(res, 400, false, "文件为空");
        Logger::warning("空文件");
        return;
    }
    
    // 6. 保存临时文件
    std::string tempDir = "/tmp/";
    std::string tempFilename = "avatar_" + std::to_string(validation.userId) + "_" + std::to_string(std::time(nullptr));
    std::string tempFilePath = tempDir + tempFilename;
    
    FILE* tempFile = fopen(tempFilePath.c_str(), "wb");
    if (!tempFile) {
        sendJsonResponse(res, 500, false, "无法创建临时文件");
        Logger::error("fopen失败: " + tempFilePath);
        return;
    }
    
    size_t written = fwrite(file.content.data(), 1, file.content.size(), tempFile);
    fclose(tempFile);
    
    if (written != file.content.size()) {
        sendJsonResponse(res, 500, false, "临时文件写入失败");
        Logger::error("fwrite失败: written=" + std::to_string(written) + ", expected=" + std::to_string(file.content.size()));
        unlink(tempFilePath.c_str());
        return;
    }
    
    Logger::info("临时文件已保存: " + tempFilePath);
    
    // 7. 调用Service层处理头像上传
    UploadAvatarResult result = authService_->uploadAvatar(validation.userId, tempFilePath);
    
    // 8. 删除临时文件
    unlink(tempFilePath.c_str());
    Logger::info("临时文件已删除: " + tempFilePath);
    
    // 9. 返回结果
    if (!result.success) {
        sendJsonResponse(res, 400, false, result.message);
        return;
    }
    
    // 10. 构建响应数据
    Json::Value data;
    data["avatar_url"] = UrlHelper::toFullUrl(result.avatarUrl);  // 添加服务器URL前缀
    data["width"] = result.width;
    data["height"] = result.height;
    data["file_size"] = static_cast<Json::Int64>(result.fileSize);
    
    sendJsonResponse(res, 200, true, result.message, data);
    Logger::info("头像上传成功: userId=" + std::to_string(validation.userId) + ", avatarUrl=" + result.avatarUrl);
}
```

**关键点**：
1. **JWT验证**：确保用户已登录
2. **文件检查**：使用`req.has_file("avatar")`检查文件是否存在
3. **大小验证**：前置验证，避免处理超大文件
4. **临时文件**：保存到`/tmp/`目录，处理完后立即删除
5. **URL前缀**：使用`UrlHelper::toFullUrl()`添加服务器URL
6. **错误处理**：每一步都有详细的错误处理和日志

---

#### 任务4.4：编译测试

```bash
cd /home/kun/projects/SharePix/backend-service/build
make -j4
```

**预期结果**：编译成功，无错误

---

### 阶段5：集成测试（1小时）

#### 任务5.1：启动服务器

```bash
cd /home/kun/projects/SharePix/backend-service
./build/knot_image_sharing config/config.json
```

**验证启动成功**：
```
[INFO] AvatarProcessor initialized
[INFO] Auth routes registered (including POST /api/v1/users/avatar)
[INFO] HTTP Server started on 0.0.0.0:8080
```

---

#### 任务5.2：使用Apifox测试

**测试用例1：成功上传头像**

**接口**：`POST http://43.142.157.145:8080/api/v1/users/avatar`

**请求头**：
```
Authorization: Bearer {有效的access_token}
Content-Type: multipart/form-data
```

**请求Body**（Form-data）：
| Key | Type | Value |
|-----|------|-------|
| avatar | File | [选择一张图片文件] |

**预期响应**（200）：
```json
{
  "success": true,
  "message": "头像上传成功",
  "data": {
    "avatar_url": "http://43.142.157.145:8080/uploads/avatars/USR_2025Q4_abc123_1729584000.jpg",
    "width": 200,
    "height": 200,
    "file_size": 45678
  },
  "timestamp": 1729584000
}
```

**测试用例2：未提供文件**

**接口**：`POST http://43.142.157.145:8080/api/v1/users/avatar`

**请求头**：
```
Authorization: Bearer {有效的access_token}
Content-Type: multipart/form-data
```

**请求Body**：（空）

**预期响应**（400）：
```json
{
  "success": false,
  "message": "请上传头像文件",
  "data": null,
  "timestamp": 1729584000
}
```

**测试用例3：文件过大**

**接口**：`POST http://43.142.157.145:8080/api/v1/users/avatar`

**请求头**：
```
Authorization: Bearer {有效的access_token}
Content-Type: multipart/form-data
```

**请求Body**（Form-data）：
| Key | Type | Value |
|-----|------|-------|
| avatar | File | [选择一张>5MB的图片] |

**预期响应**（400）：
```json
{
  "success": false,
  "message": "文件大小超过限制（最大5MB）",
  "data": null,
  "timestamp": 1729584000
}
```

**测试用例4：未授权**

**接口**：`POST http://43.142.157.145:8080/api/v1/users/avatar`

**请求头**：
```
Content-Type: multipart/form-data
```

**请求Body**（Form-data）：
| Key | Type | Value |
|-----|------|-------|
| avatar | File | [选择一张图片文件] |

**预期响应**（401）：
```json
{
  "success": false,
  "message": "未提供认证令牌",
  "data": null,
  "timestamp": 1729584000
}
```

**测试用例5：不支持的格式**

**接口**：`POST http://43.142.157.145:8080/api/v1/users/avatar`

**请求头**：
```
Authorization: Bearer {有效的access_token}
Content-Type: multipart/form-data
```

**请求Body**（Form-data）：
| Key | Type | Value |
|-----|------|-------|
| avatar | File | [选择一个.txt或.pdf文件] |

**预期响应**（400）：
```json
{
  "success": false,
  "message": "不支持的文件格式，仅支持JPEG/PNG/GIF/WebP",
  "data": null,
  "timestamp": 1729584000
}
```

---

#### 任务5.3：验证文件系统

**检查头像文件是否生成**：
```bash
ls -lh /home/kun/projects/SharePix/backend-service/uploads/avatars/
```

**预期输出**：
```
-rw-r--r-- 1 kun kun 44K Oct 18 10:30 USR_2025Q4_abc123_1729584000.jpg
```

**检查文件尺寸和质量**：
```bash
file /home/kun/projects/SharePix/backend-service/uploads/avatars/USR_2025Q4_abc123_1729584000.jpg
```

**预期输出**：
```
JPEG image data, JFIF standard 1.01, resolution (DPI), density 72x72, segment length 16, baseline, precision 8, 200x200, components 3
```

---

#### 任务5.4：验证数据库

**查询用户头像URL**：
```sql
SELECT id, user_id, username, avatar_url, update_time 
FROM users 
WHERE id = {测试用户ID};
```

**预期结果**：
```
id  | user_id              | username | avatar_url                                      | update_time
----|----------------------|----------|-------------------------------------------------|-------------------
123 | USR_2025Q4_abc123    | testuser | /uploads/avatars/USR_2025Q4_abc123_1729584000.jpg | 2025-10-18 10:30:00
```

---

#### 任务5.5：验证旧头像删除

**步骤**：
1. 上传第一张头像 → 记录文件名：`USR_xxx_1729584000.jpg`
2. 上传第二张头像 → 记录文件名：`USR_xxx_1729584100.jpg`
3. 检查文件系统

**预期结果**：
```bash
ls -lh uploads/avatars/
# 仅显示最新的头像文件
-rw-r--r-- 1 kun kun 42K Oct 18 10:32 USR_2025Q4_abc123_1729584100.jpg
```

旧文件`USR_xxx_1729584000.jpg`应已被删除。

---

#### 任务5.6：验证GET用户信息接口

**接口**：`GET http://43.142.157.145:8080/api/v1/users/profile`

**请求头**：
```
Authorization: Bearer {有效的access_token}
```

**预期响应**（200）：
```json
{
  "success": true,
  "message": "获取用户信息成功",
  "data": {
    "id": 123,
    "user_id": "USR_2025Q4_abc123",
    "username": "testuser",
    "avatar_url": "http://43.142.157.145:8080/uploads/avatars/USR_2025Q4_abc123_1729584100.jpg",  // ← 完整URL
    ...
  },
  "timestamp": 1729584000
}
```

**验证点**：`avatar_url`字段应包含服务器URL前缀。

---

### 阶段6：文档更新（30分钟）

#### 任务6.1：更新API文档

**文件路径**：`/home/kun/projects/SharePix/backend-service/project_document/[000]API文档.md`

**在"用户信息管理"章节添加新接口**：

```markdown
## 5. 上传用户头像 (v2.6.0)

### 接口信息
- **接口名称**: 上传用户头像
- **接口路径**: `/api/v1/users/avatar`
- **请求方式**: POST
- **接口说明**: 用户上传头像图片，系统自动裁剪、压缩、生成200x200正方形头像
- **认证要求**: 需要JWT令牌（Bearer Token）

### 请求参数

#### 请求头
| 参数名 | 类型 | 必填 | 说明 | 示例 |
|--------|------|------|------|------|
| Authorization | string | 是 | JWT访问令牌 | Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9... |
| Content-Type | string | 是 | 内容类型 | multipart/form-data |

#### 请求Body (Form-data)
| 参数名 | 类型 | 必填 | 说明 | 限制 |
|--------|------|------|------|------|
| avatar | File | 是 | 头像图片文件 | 最大5MB，支持JPEG/PNG/GIF/WebP |

### 响应参数

#### 成功响应 (200)
| 参数路径 | 类型 | 说明 | 示例 |
|----------|------|------|------|
| success | boolean | 请求是否成功 | true |
| message | string | 响应消息 | "头像上传成功" |
| data.avatar_url | string | 头像完整URL | "http://43.142.157.145:8080/uploads/avatars/USR_2025Q4_abc123_1729584000.jpg" |
| data.width | integer | 图片宽度 | 200 |
| data.height | integer | 图片高度 | 200 |
| data.file_size | integer | 文件大小（字节） | 45678 |
| timestamp | integer | 时间戳 | 1729584000 |

#### 成功响应示例
```json
{
  "success": true,
  "message": "头像上传成功",
  "data": {
    "avatar_url": "http://43.142.157.145:8080/uploads/avatars/USR_2025Q4_abc123_1729584000.jpg",
    "width": 200,
    "height": 200,
    "file_size": 45678
  },
  "timestamp": 1729584000
}
```

#### 错误响应

| HTTP状态码 | message | 说明 |
|-----------|---------|------|
| 400 | 请上传头像文件 | 未提供文件 |
| 400 | 文件为空 | 上传的文件内容为空 |
| 400 | 文件大小超过限制（最大5MB） | 文件过大 |
| 400 | 不支持的文件格式，仅支持JPEG/PNG/GIF/WebP | 文件格式不支持 |
| 400 | 图片尺寸过大（最大10000x10000） | 图片尺寸超出限制 |
| 400 | 头像处理失败 | 图片处理过程中出错 |
| 401 | 未提供认证令牌 | 缺少Authorization头 |
| 401 | 令牌无效或已过期 | Token验证失败 |
| 500 | 无法创建临时文件 | 服务器临时目录写入失败 |
| 500 | 数据库更新失败 | 数据库操作失败 |

#### 错误响应示例
```json
{
  "success": false,
  "message": "文件大小超过限制（最大5MB）",
  "data": null,
  "timestamp": 1729584000
}
```

### 功能说明

#### 自动处理流程
1. **格式验证**：检查文件格式是否为JPEG/PNG/GIF/WebP
2. **大小验证**：检查文件大小是否≤5MB
3. **裁剪**：如果图片不是正方形，自动居中裁剪
4. **缩放**：缩放到200x200标准尺寸
5. **压缩**：保存为JPEG格式（80%质量）
6. **删除旧头像**：自动删除旧的头像文件
7. **更新数据库**：更新users表的avatar_url字段

#### 文件命名规则
```
{用户逻辑ID}_{时间戳}.jpg
示例：USR_2025Q4_abc123_1729584000.jpg
```

#### 存储路径
```
相对路径：/uploads/avatars/USR_2025Q4_abc123_1729584000.jpg
完整URL：http://43.142.157.145:8080/uploads/avatars/USR_2025Q4_abc123_1729584000.jpg
```

### 调用示例

#### cURL示例
```bash
curl -X POST "http://43.142.157.145:8080/api/v1/users/avatar" \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." \
  -F "avatar=@/path/to/avatar.jpg"
```

#### JavaScript (fetch)示例
```javascript
const formData = new FormData();
formData.append('avatar', fileInput.files[0]);

fetch('http://43.142.157.145:8080/api/v1/users/avatar', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${accessToken}`
  },
  body: formData
})
.then(response => response.json())
.then(data => {
  if (data.success) {
    console.log('头像上传成功:', data.data.avatar_url);
  }
});
```

#### Python (requests)示例
```python
import requests

url = "http://43.142.157.145:8080/api/v1/users/avatar"
headers = {
    "Authorization": f"Bearer {access_token}"
}
files = {
    "avatar": open("/path/to/avatar.jpg", "rb")
}

response = requests.post(url, headers=headers, files=files)
data = response.json()

if data["success"]:
    print(f"头像上传成功: {data['data']['avatar_url']}")
```

### 注意事项

1. **文件格式**：仅支持JPEG、PNG、GIF、WebP格式
2. **文件大小**：最大5MB，建议压缩后再上传
3. **图片尺寸**：系统会自动裁剪和缩放，建议上传正方形图片
4. **旧头像**：上传新头像后，旧头像文件会被自动删除
5. **URL前缀**：返回的`avatar_url`包含服务器URL前缀，可直接使用
6. **认证要求**：必须提供有效的JWT令牌
7. **并发上传**：同一用户的多次上传会依次处理，不会造成冲突

### 相关接口

- **获取当前用户信息**: `GET /api/v1/users/profile` - 可查看上传后的头像URL
- **修改用户信息**: `PUT /api/v1/users/profile` - 也可通过此接口传递头像URL字符串（不推荐）
```

---

#### 任务6.2：更新CLAUDE.md

**文件路径**：`/home/kun/projects/SharePix/CLAUDE.md`

**更新"当前状态"部分**：
```markdown
**当前版本**: v2.6.0

**当前状态**:
- ✅ 用户认证系统（注册、登录、JWT令牌管理、密码修改）
- ✅ 用户信息管理系统（v2.1.0 - 获取/修改用户信息、用户名检查、公开信息查询）
- ✅ **用户头像上传（v2.6.0 - 文件上传、自动裁剪压缩、旧文件删除）**
- ✅ 多图片帖子系统（v2.0.0 - 1-9张图片发布、编辑、删除）
- ✅ 图片管理系统（图片压缩、缩略图生成、Feed推荐）
- ✅ 标签系统（帖子标签关联、标签管理）
- ✅ 分享系统（v2.3.0 - 短链接生成、三端Deep Link、帖子分享）
- ✅ Feed流优化（v2.5.0 - 批量查询、可选认证、作者信息、互动状态）
- ⏳ 社交互动系统（点赞、收藏、关注、评论 - 规划中）
```

**添加API版本历史**：
```markdown
### v2.6.0 (2025-10-18) - 用户头像上传
**新增功能：**
- ✅ 用户头像上传API
  - POST /api/v1/users/avatar - 上传头像文件（multipart/form-data）
- ✅ 头像自动处理
  - 居中裁剪为正方形
  - 缩放到200x200标准尺寸
  - JPEG压缩（80%质量）
  - 自动删除旧头像文件

**技术实现：**
- 新增工具类：AvatarProcessor（头像处理器）
- Repository层：updateAvatarUrl()方法
- Service层：uploadAvatar()方法
- Handler层：handleUploadAvatar()方法

**技术亮点：**
- 使用stb_image库进行跨格式图片处理
- 支持JPEG/PNG/GIF/WebP格式
- 事务性回滚：数据库更新失败时自动删除新上传的文件
- 文件大小限制5MB，图片尺寸限制10000x10000

**文档：** `[120]用户头像上传功能-实施方案.md`
```

---

#### 任务6.3：更新README.md

**文件路径**：`/home/kun/projects/SharePix/backend-service/README.md`

**在"功能模块统计"表格中添加**：
```markdown
| 功能模块 | 状态 | API数量 | 数据表 |
|---------|------|---------|--------|
| 用户认证 | ✅ 已完成 | 6个 | users |
| 用户信息管理 | ✅ 已完成 (v2.1.0) | 4个 | users |
| 用户头像上传 | ✅ 已完成 (v2.6.0) | 1个 | users |
| 多图片帖子 | ✅ 已完成 (v2.0.0) | 8个 | posts, images |
| 标签系统 | ✅ 已完成 | 4个 | tags, post_tags |
| 分享系统 | ✅ 已完成 (v2.3.0) | 2个 | share_links |
| Feed流优化 | ✅ 已完成 (v2.5.0) | - | - |
| 社交互动 | ⏳ 规划中 | 预计12个 | likes, favorites, follows, comments |
```

---

## 📊 验收标准

### 功能验收

- [ ] 用户可以成功上传头像（JPEG/PNG/GIF/WebP格式）
- [ ] 系统自动裁剪为正方形（居中裁剪）
- [ ] 系统自动缩放到200x200
- [ ] 系统自动压缩保存为JPEG（80%质量）
- [ ] 上传新头像后，旧头像文件被自动删除
- [ ] 返回的avatar_url包含服务器URL前缀
- [ ] GET /api/v1/users/profile接口返回最新的头像URL
- [ ] 文件大小超过5MB时返回错误提示
- [ ] 不支持的文件格式返回错误提示
- [ ] 未提供JWT令牌时返回401错误

### 技术验收

- [ ] AvatarProcessor类正确实现图片处理逻辑
- [ ] Repository层的updateAvatarUrl()方法正确更新数据库
- [ ] Service层的uploadAvatar()方法正确处理业务逻辑
- [ ] Handler层的handleUploadAvatar()方法正确处理HTTP请求
- [ ] 临时文件在处理完后被正确删除
- [ ] 数据库更新失败时，新上传的文件被正确回滚删除
- [ ] 所有错误情况都有详细的日志记录
- [ ] 编译无警告无错误

### 性能验收

- [ ] 单次头像上传处理时间 < 2秒（1MB图片）
- [ ] 并发10个头像上传请求，成功率100%
- [ ] 内存泄漏检测通过（valgrind）
- [ ] 压缩后的文件大小 < 100KB（典型值）

### 文档验收

- [ ] [000]API文档.md已更新
- [ ] CLAUDE.md已更新（API版本历史、当前状态）
- [ ] README.md已更新（功能模块统计）
- [ ] 本文档标记为已完成

---

## 🎯 后续优化建议

### 1. 支持头像删除（v2.7.0）
```
DELETE /api/v1/users/avatar
// 将avatar_url设置为NULL，删除文件
```

### 2. 支持Base64上传（v2.7.0）
```json
POST /api/v1/users/avatar
{
  "avatar": "data:image/jpeg;base64,/9j/4AAQSkZJRgABA..."
}
```

### 3. 支持多尺寸头像（v2.8.0）
- 小尺寸：50x50（用于列表展示）
- 中尺寸：100x100（用于评论区）
- 大尺寸：200x200（用于个人主页）

### 4. 支持CDN加速（v3.0.0）
- 集成阿里云OSS或七牛云
- 自动同步头像到CDN
- 返回CDN URL

### 5. 支持头像审核（v3.0.0）
- 接入阿里云内容安全API
- 自动检测违规图片
- 异步审核，先上传后审核

---

## 📌 常见问题（FAQ）

### Q1: 为什么头像固定为200x200？
**A**: 为了统一UI风格和节省存储空间。200x200是常见的头像尺寸，既清晰又不占用过多空间。

### Q2: 为什么只支持JPEG/PNG/GIF/WebP？
**A**: 这些是Web端最常用的图片格式，stb_image库原生支持。不支持BMP、TIFF等格式是为了避免用户上传过大的未压缩文件。

### Q3: 可以不裁剪，保留原始比例吗？
**A**: 不建议。头像需要在各种场景下展示（圆形、方形），保持正方形可以避免变形。

### Q4: 旧头像删除失败会影响新头像上传吗？
**A**: 不会。删除旧头像是非关键操作，即使失败也不会影响新头像的上传和数据库更新。

### Q5: 为什么选择JPEG而不是PNG？
**A**: JPEG压缩率更高，适合照片类头像。80%质量已足够清晰，文件大小通常只有PNG的1/5。

### Q6: 可以通过PUT /api/v1/users/profile更新头像吗？
**A**: 可以，但不推荐。通过该接口只能传递URL字符串，无法享受自动裁剪压缩等功能。建议使用POST /api/v1/users/avatar。

### Q7: 上传头像后需要刷新token吗？
**A**: 不需要。头像URL存储在数据库中，JWT令牌不包含头像信息。

### Q8: 支持动画GIF吗？
**A**: 理论支持加载GIF，但会被转换为静态JPEG。如需支持动画，需要修改代码跳过GIF的压缩步骤。

---

## 📅 时间规划

| 日期 | 阶段 | 工作内容 | 预计耗时 | 负责人 |
|------|------|----------|----------|--------|
| Day 1上午 | 阶段0-1 | 创建目录 + 工具层开发 | 2小时 | 开发 |
| Day 1下午 | 阶段2-3 | Repository层 + Service层 | 1.5小时 | 开发 |
| Day 1晚上 | 阶段4 | Handler层开发 | 1.5小时 | 开发 |
| Day 2上午 | 阶段5 | 集成测试 | 1小时 | 测试 |
| Day 2下午 | 阶段6 | 文档更新 + 验收 | 0.5小时 | 文档 |

**总计**: 约6.5小时（分2天完成）

---

## ✅ 完成检查清单

### 开发阶段
- [ ] 阶段0：创建存储目录 (5分钟)
- [ ] 阶段1：实现AvatarProcessor工具类 (2小时)
- [ ] 阶段2：Repository层 - updateAvatarUrl() (30分钟)
- [ ] 阶段3：Service层 - uploadAvatar() (1小时)
- [ ] 阶段4：Handler层 - handleUploadAvatar() (1.5小时)

### 测试阶段
- [ ] 阶段5：集成测试 (1小时)
  - [ ] 测试用例1：成功上传头像
  - [ ] 测试用例2：未提供文件
  - [ ] 测试用例3：文件过大
  - [ ] 测试用例4：未授权
  - [ ] 测试用例5：不支持的格式
  - [ ] 验证文件系统
  - [ ] 验证数据库
  - [ ] 验证旧头像删除
  - [ ] 验证GET用户信息接口

### 文档阶段
- [ ] 阶段6：文档更新 (30分钟)
  - [ ] 更新[000]API文档.md
  - [ ] 更新CLAUDE.md
  - [ ] 更新README.md
  - [ ] 标记本文档为已完成

### 验收阶段
- [ ] 功能验收（10项）
- [ ] 技术验收（8项）
- [ ] 性能验收（4项）
- [ ] 文档验收（4项）

---

## 📖 参考资料

### 技术文档
- [stb_image 文档](https://github.com/nothings/stb)
- [cpp-httplib multipart/form-data](https://github.com/yhirose/cpp-httplib#multipartform-data)
- [JPEG压缩质量参考](https://stackoverflow.com/questions/418181/recommended-compression-quality-settings)

### 相关文档
- `[106]用户信息管理功能完善-实施计划.md` - 用户信息管理基础
- `[102]阶段C-图片管理模块.md` - ImageProcessor实现参考
- `[110]v2.4.0-图片URL自动前缀功能.md` - UrlHelper使用指南

---

**文档结束**

*创建人：Claude*
*创建时间：2025-10-18*
*最后更新：2025-10-18*

