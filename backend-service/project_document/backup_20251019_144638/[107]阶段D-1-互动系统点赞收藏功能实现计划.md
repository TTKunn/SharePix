# 阶段D-1：互动系统点赞收藏功能实现计划

**文档编号**: [107]
**创建时间**: 2025-10-10
**项目**: Knot - 图片分享社交平台
**版本**: v2.2.0
**状态**: 📝 计划中

---

## 📋 目录

1. [概述](#概述)
   - [背景](#背景)
   - [目标](#目标)
   - [实施范围](#实施范围)
2. [技术设计](#技术设计)
   - [数据库设计](#数据库设计)
   - [架构设计](#架构设计)
   - [API设计](#api设计)
3. [详细任务列表](#详细任务列表)
   - [阶段0：数据库调研](#阶段0数据库调研30分钟)
   - [阶段1：数据库变更](#阶段1数据库变更1小时)
   - [阶段2：Model层](#阶段2model层2小时)
   - [阶段3：Repository层](#阶段3repository层3-4小时)
   - [阶段4：Service层](#阶段4service层3-4小时)
   - [阶段5：Handler层](#阶段5handler层2-3小时)
   - [阶段6：集成测试](#阶段6集成测试2-3小时)
   - [阶段7：文档更新](#阶段7文档更新1小时)
4. [关键技术点](#关键技术点)
5. [风险和注意事项](#风险和注意事项)
6. [验收标准](#验收标准)
7. [进度跟踪](#进度跟踪)
8. [变更日志](#变更日志)

---

## 概述

### 背景

当前Knot图片分享系统已完成以下核心功能：

- ✅ **用户认证系统（v2.1.0）**: 注册、登录、JWT令牌管理、用户信息管理
- ✅ **多图片帖子系统（v2.0.0）**: 支持1-9张图片的帖子发布、编辑、删除
- ✅ **标签系统**: 帖子标签关联、标签管理
- ✅ **图片管理系统**: 图片压缩、缩略图生成、Feed推荐

然而，作为一个图片分享社交平台，缺少最核心的**社交互动功能**：

- ❌ 用户无法对喜欢的帖子点赞
- ❌ 用户无法收藏优质内容
- ❌ 用户无法关注其他创作者
- ❌ 用户无法评论交流

根据产品需求文档（`需求分析.md`），互动系统是MVP的核心功能之一，用户需要：
- 🎨 **创作者需求**: 获得点赞/收藏反馈，了解作品受欢迎程度
- 🔍 **消费者需求**: 简单高效的轻社交互动方式（点赞/收藏/关注）

本阶段将实现互动系统的**第一步**：**点赞和收藏功能**，为后续的关注、评论系统打下坚实基础。

---

### 目标

本阶段的核心目标：

1. **实现点赞系统**
   - 用户可以对帖子点赞/取消点赞
   - 帖子显示实时点赞数
   - 防止重复点赞（幂等性）

2. **实现收藏系统**
   - 用户可以收藏/取消收藏帖子
   - 帖子显示实时收藏数
   - 防止重复收藏（幂等性）

3. **保持架构一致性**
   - 严格遵循现有九层架构
   - 复用BaseHandler、ConnectionGuard、TransactionGuard等基础设施
   - 与现有Post系统风格保持一致

4. **为后续功能打基础**
   - 建立互动系统的代码结构和设计模式
   - 为关注、评论系统提供参考实现
   - 验证并发安全性和性能优化方案

---

### 实施范围

本阶段将实现**4个核心API接口**：

| 序号 | 功能 | API路径 | 方法 | 认证 | 优先级 | 预计工时 |
|------|------|---------|------|------|--------|---------|
| 1 | 点赞帖子 | `/api/v1/posts/:post_id/like` | POST | 需要JWT | P0 | 2小时 |
| 2 | 取消点赞 | `/api/v1/posts/:post_id/like` | DELETE | 需要JWT | P0 | 1小时 |
| 3 | 收藏帖子 | `/api/v1/posts/:post_id/favorite` | POST | 需要JWT | P0 | 1.5小时 |
| 4 | 取消收藏 | `/api/v1/posts/:post_id/favorite` | DELETE | 需要JWT | P0 | 0.5小时 |

**实施时间**: 预计2-3个工作日（约18.5小时）

**本阶段不包含**：
- ❌ 关注系统（延后到阶段D-2）
- ❌ 评论系统（延后到v1.1）
- ❌ 通知系统（延后到v1.1）
- ❌ 我的点赞/收藏列表API（可选功能，视时间决定是否加入）

---

## 技术设计

### 数据库设计

#### 1. likes表（点赞表）

**设计说明**：
- 采用简化设计，不使用业务逻辑ID（like_id），只用物理主键id
- 使用唯一约束(user_id, post_id)保证幂等性，防止重复点赞
- 使用外键级联删除，用户或帖子删除时自动清理点赞记录
- 优化索引设计，支持高频查询场景

**表结构**：

```sql
CREATE TABLE likes (
    id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '物理ID（自增主键）',
    user_id BIGINT NOT NULL COMMENT '点赞用户ID',
    post_id BIGINT NOT NULL COMMENT '被点赞帖子ID（关联posts表的物理ID）',
    create_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '点赞时间',

    -- 外键约束
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,

    -- 唯一约束（防止同一用户重复点赞同一帖子）
    UNIQUE KEY uk_user_post (user_id, post_id),

    -- 索引优化
    INDEX idx_post_id (post_id),                          -- 查询某帖子的点赞数
    INDEX idx_user_create (user_id, create_time DESC)    -- 查询某用户的点赞历史
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='点赞表';
```

**字段说明**：

| 字段名 | 类型 | 约束 | 说明 |
|--------|------|------|------|
| id | BIGINT | PRIMARY KEY, AUTO_INCREMENT | 物理主键 |
| user_id | BIGINT | NOT NULL, FOREIGN KEY | 点赞用户ID |
| post_id | BIGINT | NOT NULL, FOREIGN KEY | 被点赞帖子ID |
| create_time | TIMESTAMP | NOT NULL, DEFAULT CURRENT_TIMESTAMP | 点赞时间 |

**索引说明**：

| 索引名 | 类型 | 字段 | 用途 |
|--------|------|------|------|
| PRIMARY | 主键 | id | 主键索引 |
| uk_user_post | 唯一索引 | (user_id, post_id) | 防止重复点赞 + 快速exists()查询 |
| idx_post_id | 普通索引 | post_id | 按帖子统计点赞数 |
| idx_user_create | 复合索引 | (user_id, create_time DESC) | 查询用户点赞历史（时间倒序） |

---

#### 2. favorites表（收藏表）

**设计说明**：
- 与likes表结构完全一致，只是表名和注释不同
- 同样采用简化设计，保证幂等性和性能

**表结构**：

```sql
CREATE TABLE favorites (
    id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '物理ID（自增主键）',
    user_id BIGINT NOT NULL COMMENT '收藏用户ID',
    post_id BIGINT NOT NULL COMMENT '被收藏帖子ID（关联posts表的物理ID）',
    create_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '收藏时间',

    -- 外键约束
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,

    -- 唯一约束（防止同一用户重复收藏同一帖子）
    UNIQUE KEY uk_user_post (user_id, post_id),

    -- 索引优化
    INDEX idx_post_id (post_id),                          -- 查询某帖子的收藏数
    INDEX idx_user_create (user_id, create_time DESC)    -- 查询某用户的收藏列表
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='收藏表';
```

---

#### 3. 已有posts表字段说明

**冗余字段**（用于性能优化）：

posts表已存在以下冗余字段，用于快速显示统计数据：

```sql
-- posts表中的相关字段
like_count INT NOT NULL DEFAULT 0 COMMENT '点赞数（冗余字段）',
favorite_count INT NOT NULL DEFAULT 0 COMMENT '收藏数（冗余字段）',
```

**更新策略**：
- 使用SQL原子操作保证一致性：`UPDATE posts SET like_count = like_count + 1 WHERE id = ?`
- 使用TransactionGuard保证点赞记录和计数的原子性
- 避免先SELECT再UPDATE的竞态条件

---

#### 4. 设计决策说明

| 设计点 | 方案 | 理由 |
|--------|------|------|
| **业务ID** | 不使用（只有物理主键id） | 点赞/收藏无需独立的业务逻辑ID，简化设计 |
| **唯一约束** | (user_id, post_id) | 防止同一用户重复点赞/收藏同一帖子 |
| **级联删除** | ON DELETE CASCADE | 用户或帖子删除时自动清理关联记录，保证数据一致性 |
| **时间戳** | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | 记录点赞/收藏时间，支持按时间排序 |
| **复合索引** | (user_id, create_time DESC) | 优化"我的点赞/收藏"列表查询，按时间倒序 |
| **冗余计数** | posts.like_count, posts.favorite_count | 避免高频COUNT查询，提升Feed流性能 |

---

### 架构设计

#### 1. 九层架构图（文本形式）

```
┌─────────────────────────────────────────────────────────────┐
│                      HTTP客户端                              │
│                  (移动App / Web浏览器)                       │
└───────────────────────────┬─────────────────────────────────┘
                            │ HTTP请求
                            ↓
┌─────────────────────────────────────────────────────────────┐
│   [第2层] HTTP服务器 (http_server.cpp)                      │
│   - 监听端口8080                                             │
│   - 路由分发                                                 │
└───────────────────────────┬─────────────────────────────────┘
                            │
                            ↓
┌─────────────────────────────────────────────────────────────┐
│   [第3层] API接口层 (Handler)                                │
│   ┌──────────────────┐  ┌──────────────────┐               │
│   │ LikeHandler      │  │ FavoriteHandler  │  ← 新增       │
│   │ - handleLike()   │  │ - handleFavorite()│               │
│   │ - handleUnlike() │  │ - handleUnfavorite()│             │
│   └──────────────────┘  └──────────────────┘               │
│   (继承BaseHandler，自动获得JWT验证能力)                      │
└───────────────────────────┬─────────────────────────────────┘
                            │ 调用Service方法
                            ↓
┌─────────────────────────────────────────────────────────────┐
│   [第4层] 业务逻辑层 (Service)                               │
│   ┌──────────────────┐  ┌──────────────────┐               │
│   │ LikeService      │  │ FavoriteService  │  ← 新增       │
│   │ - likePost()     │  │ - favoritePost() │               │
│   │ - unlikePost()   │  │ - unfavoritePost()│              │
│   │ - hasLiked()     │  │ - hasFavorited() │               │
│   └──────────────────┘  └──────────────────┘               │
│   (使用TransactionGuard保证事务原子性)                       │
└───────────────────────────┬─────────────────────────────────┘
                            │ 调用Repository方法
                            ↓
┌─────────────────────────────────────────────────────────────┐
│   [第5层] 数据访问层 (Repository)                            │
│   ┌─────────────────────┐  ┌─────────────────────┐         │
│   │ LikeRepository      │  │ FavoriteRepository  │ ← 新增  │
│   │ - create()          │  │ - create()          │         │
│   │ - deleteByUserPost()│  │ - deleteByUserPost()│         │
│   │ - exists()          │  │ - exists()          │         │
│   └─────────────────────┘  └─────────────────────┘         │
│   ┌─────────────────────┐                                   │
│   │ PostRepository      │  ← 需修改                        │
│   │ - incrementLikeCount()    (新增方法)                    │
│   │ - decrementLikeCount()                                  │
│   │ - incrementFavoriteCount()                              │
│   │ - decrementFavoriteCount()                              │
│   └─────────────────────┘                                   │
│   (使用ConnectionGuard管理数据库连接)                        │
└───────────────────────────┬─────────────────────────────────┘
                            │ 使用基础设施
                            ↓
┌─────────────────────────────────────────────────────────────┐
│   [第7层] 基础设施层 (Utils)                                 │
│   ┌──────────────────┐  ┌──────────────────┐               │
│   │ ConnectionGuard  │  │ TransactionGuard │  ← 已有       │
│   │ - RAII资源管理   │  │ - RAII事务管理   │               │
│   └──────────────────┘  └──────────────────┘               │
│   ┌──────────────────┐  ┌──────────────────┐               │
│   │ Logger           │  │ ConfigManager    │  ← 已有       │
│   └──────────────────┘  └──────────────────┘               │
└───────────────────────────┬─────────────────────────────────┘
                            │ 使用Model
                            ↓
┌─────────────────────────────────────────────────────────────┐
│   [第8层] 数据模型层 (Model)                                 │
│   ┌──────────────────┐  ┌──────────────────┐               │
│   │ Like             │  │ Favorite         │  ← 新增       │
│   │ - id_            │  │ - id_            │               │
│   │ - userId_        │  │ - userId_        │               │
│   │ - postId_        │  │ - postId_        │               │
│   │ - createTime_    │  │ - createTime_    │               │
│   │ - toJson()       │  │ - toJson()       │               │
│   └──────────────────┘  └──────────────────┘               │
└───────────────────────────┬─────────────────────────────────┘
                            │ 数据持久化
                            ↓
┌─────────────────────────────────────────────────────────────┐
│   [第9层] 数据库层 (MySQL 8.0)                               │
│   - knot_image_sharing数据库                                 │
│   - likes表, favorites表 (新增)                              │
│   - posts表 (已有，字段：like_count, favorite_count)         │
└─────────────────────────────────────────────────────────────┘
```

---

#### 2. 文件清单

**新增文件**（12个，约2,000行代码）：

| 文件路径 | 说明 | 预计行数 |
|---------|------|---------|
| `src/models/like.h` | Like模型类定义 | 80 |
| `src/models/like.cpp` | Like模型类实现 | 120 |
| `src/models/favorite.h` | Favorite模型类定义 | 80 |
| `src/models/favorite.cpp` | Favorite模型类实现 | 120 |
| `src/database/like_repository.h` | LikeRepository接口定义 | 100 |
| `src/database/like_repository.cpp` | LikeRepository实现 | 300 |
| `src/database/favorite_repository.h` | FavoriteRepository接口定义 | 100 |
| `src/database/favorite_repository.cpp` | FavoriteRepository实现 | 300 |
| `src/core/like_service.h` | LikeService接口定义 | 80 |
| `src/core/like_service.cpp` | LikeService实现 | 250 |
| `src/core/favorite_service.h` | FavoriteService接口定义 | 80 |
| `src/core/favorite_service.cpp` | FavoriteService实现 | 250 |
| `src/api/like_handler.h` | LikeHandler接口定义 | 60 |
| `src/api/like_handler.cpp` | LikeHandler实现 | 200 |
| `src/api/favorite_handler.h` | FavoriteHandler接口定义 | 60 |
| `src/api/favorite_handler.cpp` | FavoriteHandler实现 | 200 |
| `config/migration_social_likes_favorites.sql` | 数据库迁移脚本 | 150 |

**修改文件**（2个）：

| 文件路径 | 修改内容 | 预计增加行数 |
|---------|---------|------------|
| `src/database/post_repository.h` | 新增4个方法声明（increment/decrementLikeCount等） | 20 |
| `src/database/post_repository.cpp` | 实现4个原子更新方法 | 120 |
| `src/server/http_server.h` | 新增LikeHandler和FavoriteHandler成员变量 | 5 |
| `src/server/http_server.cpp` | 注册Like和Favorite路由 | 10 |

**总代码量**: 约2,300行

---

#### 3. 依赖关系

```
LikeHandler
    ↓ 依赖
LikeService
    ↓ 依赖
LikeRepository + PostRepository
    ↓ 依赖
ConnectionGuard + TransactionGuard
    ↓ 依赖
DatabaseConnectionPool

FavoriteHandler（同理）
```

---

### API设计

#### API 1: 点赞帖子

**基本信息**：

- **路径**: `POST /api/v1/posts/:post_id/like`
- **认证**: 需要JWT Token
- **描述**: 用户对指定帖子点赞

**请求参数**：

| 参数名 | 位置 | 类型 | 必填 | 说明 |
|--------|------|------|------|------|
| post_id | 路径参数 | string | 是 | 帖子业务ID，如：POST_2025Q4_ABC123 |
| Authorization | 请求头 | string | 是 | JWT Token，格式：Bearer {token} |

**请求示例**：

```bash
curl -X POST http://localhost:8080/api/v1/posts/POST_2025Q4_ABC123/like \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

**成功响应**（200 OK）：

```json
{
  "success": true,
  "message": "点赞成功",
  "data": {
    "post_id": "POST_2025Q4_ABC123",
    "like_count": 42,
    "has_liked": true
  },
  "timestamp": 1696752600
}
```

**失败响应**：

1. **已经点赞过**（409 Conflict）：
```json
{
  "success": false,
  "message": "已经点赞过该帖子",
  "data": {
    "post_id": "POST_2025Q4_ABC123",
    "like_count": 41,
    "has_liked": true
  },
  "timestamp": 1696752600
}
```

2. **帖子不存在**（404 Not Found）：
```json
{
  "success": false,
  "message": "帖子不存在",
  "timestamp": 1696752600
}
```

3. **未提供认证令牌**（401 Unauthorized）：
```json
{
  "success": false,
  "message": "未提供认证令牌",
  "timestamp": 1696752600
}
```

4. **令牌无效或过期**（401 Unauthorized）：
```json
{
  "success": false,
  "message": "令牌无效或已过期",
  "timestamp": 1696752600
}
```

**错误码说明**：

| HTTP状态码 | 说明 | 返回消息 |
|-----------|------|---------|
| 200 | 点赞成功 | "点赞成功" |
| 400 | post_id格式错误 | "帖子ID格式错误" |
| 401 | 未认证或令牌无效 | "未提供认证令牌" / "令牌无效或已过期" |
| 404 | 帖子不存在 | "帖子不存在" |
| 409 | 已经点赞过 | "已经点赞过该帖子" |
| 500 | 服务器内部错误 | "服务器内部错误" |

---

#### API 2: 取消点赞

**基本信息**：

- **路径**: `DELETE /api/v1/posts/:post_id/like`
- **认证**: 需要JWT Token
- **描述**: 用户取消对指定帖子的点赞

**请求参数**：

| 参数名 | 位置 | 类型 | 必填 | 说明 |
|--------|------|------|------|------|
| post_id | 路径参数 | string | 是 | 帖子业务ID |
| Authorization | 请求头 | string | 是 | JWT Token |

**请求示例**：

```bash
curl -X DELETE http://localhost:8080/api/v1/posts/POST_2025Q4_ABC123/like \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

**成功响应**（200 OK）：

```json
{
  "success": true,
  "message": "取消点赞成功",
  "data": {
    "post_id": "POST_2025Q4_ABC123",
    "like_count": 40,
    "has_liked": false
  },
  "timestamp": 1696752600
}
```

**失败响应**：

1. **未点赞过该帖子**（400 Bad Request）：
```json
{
  "success": false,
  "message": "您未点赞过该帖子",
  "data": {
    "post_id": "POST_2025Q4_ABC123",
    "has_liked": false
  },
  "timestamp": 1696752600
}
```

2. **帖子不存在**（404 Not Found）：
```json
{
  "success": false,
  "message": "帖子不存在",
  "timestamp": 1696752600
}
```

**错误码说明**：

| HTTP状态码 | 说明 | 返回消息 |
|-----------|------|---------|
| 200 | 取消点赞成功 | "取消点赞成功" |
| 400 | 未点赞过该帖子 | "您未点赞过该帖子" |
| 401 | 未认证或令牌无效 | "未提供认证令牌" / "令牌无效或已过期" |
| 404 | 帖子不存在 | "帖子不存在" |
| 500 | 服务器内部错误 | "服务器内部错误" |

---

#### API 3: 收藏帖子

**基本信息**：

- **路径**: `POST /api/v1/posts/:post_id/favorite`
- **认证**: 需要JWT Token
- **描述**: 用户收藏指定帖子

**请求参数**：

| 参数名 | 位置 | 类型 | 必填 | 说明 |
|--------|------|------|------|------|
| post_id | 路径参数 | string | 是 | 帖子业务ID |
| Authorization | 请求头 | string | 是 | JWT Token |

**请求示例**：

```bash
curl -X POST http://localhost:8080/api/v1/posts/POST_2025Q4_ABC123/favorite \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

**成功响应**（200 OK）：

```json
{
  "success": true,
  "message": "收藏成功",
  "data": {
    "post_id": "POST_2025Q4_ABC123",
    "favorite_count": 15,
    "has_favorited": true
  },
  "timestamp": 1696752600
}
```

**失败响应**：

1. **已经收藏过**（409 Conflict）：
```json
{
  "success": false,
  "message": "已经收藏过该帖子",
  "data": {
    "post_id": "POST_2025Q4_ABC123",
    "favorite_count": 14,
    "has_favorited": true
  },
  "timestamp": 1696752600
}
```

2. **帖子不存在**（404 Not Found）：
```json
{
  "success": false,
  "message": "帖子不存在",
  "timestamp": 1696752600
}
```

**错误码说明**：

| HTTP状态码 | 说明 | 返回消息 |
|-----------|------|---------|
| 200 | 收藏成功 | "收藏成功" |
| 400 | post_id格式错误 | "帖子ID格式错误" |
| 401 | 未认证或令牌无效 | "未提供认证令牌" / "令牌无效或已过期" |
| 404 | 帖子不存在 | "帖子不存在" |
| 409 | 已经收藏过 | "已经收藏过该帖子" |
| 500 | 服务器内部错误 | "服务器内部错误" |

---

#### API 4: 取消收藏

**基本信息**：

- **路径**: `DELETE /api/v1/posts/:post_id/favorite`
- **认证**: 需要JWT Token
- **描述**: 用户取消收藏指定帖子

**请求参数**：

| 参数名 | 位置 | 类型 | 必填 | 说明 |
|--------|------|------|------|------|
| post_id | 路径参数 | string | 是 | 帖子业务ID |
| Authorization | 请求头 | string | 是 | JWT Token |

**请求示例**：

```bash
curl -X DELETE http://localhost:8080/api/v1/posts/POST_2025Q4_ABC123/favorite \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

**成功响应**（200 OK）：

```json
{
  "success": true,
  "message": "取消收藏成功",
  "data": {
    "post_id": "POST_2025Q4_ABC123",
    "favorite_count": 13,
    "has_favorited": false
  },
  "timestamp": 1696752600
}
```

**失败响应**：

1. **未收藏过该帖子**（400 Bad Request）：
```json
{
  "success": false,
  "message": "您未收藏过该帖子",
  "data": {
    "post_id": "POST_2025Q4_ABC123",
    "has_favorited": false
  },
  "timestamp": 1696752600
}
```

**错误码说明**：

| HTTP状态码 | 说明 | 返回消息 |
|-----------|------|---------|
| 200 | 取消收藏成功 | "取消收藏成功" |
| 400 | 未收藏过该帖子 | "您未收藏过该帖子" |
| 401 | 未认证或令牌无效 | "未提供认证令牌" / "令牌无效或已过期" |
| 404 | 帖子不存在 | "帖子不存在" |
| 500 | 服务器内部错误 | "服务器内部错误" |

---

## 详细任务列表

### 阶段0：数据库调研（30分钟）

**目标**: 确认当前数据库状态，确保迁移脚本安全执行

---

#### 任务0.1: 连接生产数据库，查看posts表结构

**执行**:
```bash
mysql -h 8.138.115.164 -u root -p'Xzk200411.' -e "USE knot_image_sharing; DESC posts;"
```

**验证**:
- ✅ 确认posts表存在
- ✅ 确认like_count字段存在（INT类型，默认值0）
- ✅ 确认favorite_count字段存在（INT类型，默认值0）
- ✅ 记录当前posts表的字段列表

**预期输出**:
```
Field             | Type          | Null | Key | Default           | Extra
------------------|---------------|------|-----|-------------------|-------
id                | bigint        | NO   | PRI | NULL              | auto_increment
post_id           | varchar(36)   | NO   | UNI | NULL              |
user_id           | bigint        | NO   | MUL | NULL              |
title             | varchar(255)  | NO   |     | NULL              |
description       | text          | YES  |     | NULL              |
image_count       | int           | NO   |     | 0                 |
like_count        | int           | NO   |     | 0                 |  ← 确认存在
favorite_count    | int           | NO   |     | 0                 |  ← 确认存在
view_count        | int           | NO   |     | 0                 |
status            | enum(...)     | NO   | MUL | APPROVED          |
create_time       | timestamp     | NO   | MUL | CURRENT_TIMESTAMP |
update_time       | timestamp     | NO   |     | CURRENT_TIMESTAMP |
```

---

#### 任务0.2: 检查是否已存在likes和favorites表

**执行**:
```bash
mysql -h 8.138.115.164 -u root -p'Xzk200411.' -e "USE knot_image_sharing; SHOW TABLES LIKE 'likes';"
mysql -h 8.138.115.164 -u root -p'Xzk200411.' -e "USE knot_image_sharing; SHOW TABLES LIKE 'favorites';"
```

**验证**:
- ✅ 确认likes表不存在（Empty set，避免迁移冲突）
- ✅ 确认favorites表不存在（Empty set）

**预期输出**:
```
Empty set (0.00 sec)
```

**如果表已存在**:
- ⚠️ 停止迁移，先检查表结构是否符合预期
- ⚠️ 如果结构不符，需要先删除旧表或重命名备份

---

#### 任务0.3: 备份当前数据库

**执行**:
```bash
cd /home/kun/projects/Knot/backend-service
mysqldump -h 8.138.115.164 -u root -p'Xzk200411.' knot_image_sharing > backup_before_social_$(date +%Y%m%d_%H%M%S).sql
```

**验证**:
```bash
ls -lh backup_before_social_*.sql
# 检查备份文件大小 > 0（如果有数据，应该至少几KB）
```

**预期输出**:
```
-rw-rw-r-- 1 kun kun 125K Oct 10 10:00 backup_before_social_20251010_100000.sql
```

**备份说明**:
- 备份文件保存在backend-service根目录
- 文件名包含时间戳，便于识别
- 如果迁移失败，可以使用此备份恢复：
  ```bash
  mysql -h 8.138.115.164 -u root -p'Xzk200411.' knot_image_sharing < backup_before_social_20251010_100000.sql
  ```

---

### 阶段1：数据库变更（1小时）

**目标**: 创建likes和favorites表

---

#### 任务1.1: 创建数据库迁移脚本

**执行**:
```bash
# 创建脚本文件
touch /home/kun/projects/Knot/backend-service/config/migration_social_likes_favorites.sql
```

**文件内容**:
```sql
-- ============================================================================
-- Knot Image Sharing Service - 数据库迁移脚本
-- 互动系统：点赞和收藏功能
-- ============================================================================
-- 创建时间: 2025-10-10
-- 版本: v2.2.0
-- 说明: 此脚本创建likes和favorites表，支持点赞和收藏功能
-- ============================================================================

USE knot_image_sharing;

-- ============================================================================
-- 第一步：验证前置条件
-- ============================================================================

SELECT '开始执行互动系统数据库迁移...' AS status;

-- 验证posts表存在
SELECT
    CASE
        WHEN COUNT(*) > 0 THEN '✅ posts表存在'
        ELSE '❌ posts表不存在，请先创建posts表'
    END AS check_result
FROM information_schema.TABLES
WHERE TABLE_SCHEMA = 'knot_image_sharing'
AND TABLE_NAME = 'posts';

-- 验证like_count和favorite_count字段存在
SELECT
    CASE
        WHEN COUNT(*) = 2 THEN '✅ posts表包含like_count和favorite_count字段'
        ELSE '❌ posts表缺少必要字段'
    END AS check_result
FROM information_schema.COLUMNS
WHERE TABLE_SCHEMA = 'knot_image_sharing'
AND TABLE_NAME = 'posts'
AND COLUMN_NAME IN ('like_count', 'favorite_count');

-- ============================================================================
-- 第二步：创建likes表（点赞表）
-- ============================================================================

SELECT '创建likes表...' AS status;

CREATE TABLE IF NOT EXISTS likes (
    id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '物理ID（自增主键）',
    user_id BIGINT NOT NULL COMMENT '点赞用户ID',
    post_id BIGINT NOT NULL COMMENT '被点赞帖子ID（关联posts表的物理ID）',
    create_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '点赞时间',

    -- 外键约束
    CONSTRAINT fk_likes_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_likes_post FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,

    -- 唯一约束（防止同一用户重复点赞同一帖子）
    UNIQUE KEY uk_user_post (user_id, post_id),

    -- 索引优化
    INDEX idx_post_id (post_id),
    INDEX idx_user_create (user_id, create_time DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='点赞表';

SELECT CONCAT('✅ likes表创建完成，当前记录数：', COUNT(*), '条') AS status FROM likes;

-- ============================================================================
-- 第三步：创建favorites表（收藏表）
-- ============================================================================

SELECT '创建favorites表...' AS status;

CREATE TABLE IF NOT EXISTS favorites (
    id BIGINT AUTO_INCREMENT PRIMARY KEY COMMENT '物理ID（自增主键）',
    user_id BIGINT NOT NULL COMMENT '收藏用户ID',
    post_id BIGINT NOT NULL COMMENT '被收藏帖子ID（关联posts表的物理ID）',
    create_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '收藏时间',

    -- 外键约束
    CONSTRAINT fk_favorites_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_favorites_post FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,

    -- 唯一约束（防止同一用户重复收藏同一帖子）
    UNIQUE KEY uk_user_post (user_id, post_id),

    -- 索引优化
    INDEX idx_post_id (post_id),
    INDEX idx_user_create (user_id, create_time DESC)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='收藏表';

SELECT CONCAT('✅ favorites表创建完成，当前记录数：', COUNT(*), '条') AS status FROM favorites;

-- ============================================================================
-- 第四步：验证表结构
-- ============================================================================

SELECT '验证表结构...' AS status;

-- 显示likes表结构
SELECT '========================================' AS separator;
SELECT 'likes表结构' AS title;
SELECT '========================================' AS separator;
DESCRIBE likes;

-- 显示favorites表结构
SELECT '========================================' AS separator;
SELECT 'favorites表结构' AS title;
SELECT '========================================' AS separator;
DESCRIBE favorites;

-- 验证索引
SELECT '========================================' AS separator;
SELECT 'likes表索引' AS title;
SELECT '========================================' AS separator;
SHOW INDEX FROM likes;

SELECT '========================================' AS separator;
SELECT 'favorites表索引' AS title;
SELECT '========================================' AS separator;
SHOW INDEX FROM favorites;

-- 验证外键约束
SELECT '========================================' AS separator;
SELECT '外键约束验证' AS title;
SELECT '========================================' AS separator;
SELECT
    TABLE_NAME AS '表名',
    CONSTRAINT_NAME AS '约束名',
    REFERENCED_TABLE_NAME AS '引用表'
FROM information_schema.KEY_COLUMN_USAGE
WHERE TABLE_SCHEMA = 'knot_image_sharing'
AND TABLE_NAME IN ('likes', 'favorites')
AND REFERENCED_TABLE_NAME IS NOT NULL;

-- ============================================================================
-- 第五步：显示所有表
-- ============================================================================

SELECT '========================================' AS separator;
SELECT '当前数据库所有表' AS title;
SELECT '========================================' AS separator;
SHOW TABLES;

-- ============================================================================
-- 完成
-- ============================================================================

SELECT '========================================' AS separator;
SELECT '✅ 互动系统数据库迁移完成！' AS status;
SELECT '========================================' AS separator;
SELECT '新增表：likes, favorites' AS note;
SELECT '索引数量：likes表4个，favorites表4个' AS note;
SELECT '外键约束：likes表2个，favorites表2个' AS note;
SELECT '========================================' AS separator;
```

**验证**:
```bash
cat /home/kun/projects/Knot/backend-service/config/migration_social_likes_favorites.sql | wc -l
# 应该约150行
```

---

#### 任务1.2: 执行数据库迁移

**执行**:
```bash
cd /home/kun/projects/Knot/backend-service
mysql -h 8.138.115.164 -u root -p'Xzk200411.' < config/migration_social_likes_favorites.sql
```

**验证**:
```bash
mysql -h 8.138.115.164 -u root -p'Xzk200411.' -e "USE knot_image_sharing; SHOW TABLES;"
```

**预期输出**:
```
Tables_in_knot_image_sharing
------------------------------
favorites             ← 新增
image_tags_backup
images
images_backup
likes                 ← 新增
post_tags
posts
tags
users
```

---

#### 任务1.3: 验证表结构和索引

**执行**:
```bash
# 验证likes表结构
mysql -h 8.138.115.164 -u root -p'Xzk200411.' -e "USE knot_image_sharing; DESC likes;"

# 验证likes表索引
mysql -h 8.138.115.164 -u root -p'Xzk200411.' -e "USE knot_image_sharing; SHOW INDEX FROM likes;"

# 验证favorites表结构
mysql -h 8.138.115.164 -u root -p'Xzk200411.' -e "USE knot_image_sharing; DESC favorites;"

# 验证外键约束
mysql -h 8.138.115.164 -u root -p'Xzk200411.' -e "
USE knot_image_sharing;
SELECT
    TABLE_NAME,
    CONSTRAINT_NAME,
    REFERENCED_TABLE_NAME
FROM information_schema.KEY_COLUMN_USAGE
WHERE TABLE_SCHEMA = 'knot_image_sharing'
AND TABLE_NAME IN ('likes', 'favorites')
AND REFERENCED_TABLE_NAME IS NOT NULL;
"
```

**预期输出**（likes表结构）:
```
Field       | Type      | Null | Key | Default           | Extra
------------|-----------|------|-----|-------------------|-------
id          | bigint    | NO   | PRI | NULL              | auto_increment
user_id     | bigint    | NO   | MUL | NULL              |
post_id     | bigint    | NO   | MUL | NULL              |
create_time | timestamp | NO   |     | CURRENT_TIMESTAMP |
```

**预期输出**（索引）:
```
Table | Non_unique | Key_name       | Seq_in_index | Column_name | Index_type
------|------------|----------------|--------------|-------------|------------
likes | 0          | PRIMARY        | 1            | id          | BTREE
likes | 0          | uk_user_post   | 1            | user_id     | BTREE
likes | 0          | uk_user_post   | 2            | post_id     | BTREE
likes | 1          | idx_post_id    | 1            | post_id     | BTREE
likes | 1          | idx_user_create| 1            | user_id     | BTREE
likes | 1          | idx_user_create| 2            | create_time | BTREE
```

**预期输出**（外键约束）:
```
TABLE_NAME | CONSTRAINT_NAME      | REFERENCED_TABLE_NAME
-----------|----------------------|----------------------
likes      | fk_likes_user        | users
likes      | fk_likes_post        | posts
favorites  | fk_favorites_user    | users
favorites  | fk_favorites_post    | posts
```

---

### 阶段2：Model层（2小时）

**目标**: 创建Like和Favorite模型类

---

#### 任务2.1: 创建 `src/models/like.h`

**执行**:
```bash
touch /home/kun/projects/Knot/backend-service/src/models/like.h
```

**文件内容**:
```cpp
/**
 * @file like.h
 * @brief 点赞模型定义
 * @author Knot Team
 * @date 2025-10-10
 */

#pragma once

#include <string>
#include <ctime>
#include <json/json.h>

/**
 * @brief 点赞模型类
 *
 * 表示用户对帖子的点赞行为
 */
class Like {
public:
    /**
     * @brief 默认构造函数
     */
    Like();

    /**
     * @brief 带参数的构造函数
     * @param id 物理ID（自增主键）
     * @param userId 点赞用户ID
     * @param postId 被点赞帖子ID
     */
    Like(int64_t id, int64_t userId, int64_t postId);

    /**
     * @brief 析构函数
     */
    ~Like() = default;

    // Getters
    int64_t getId() const { return id_; }
    int64_t getUserId() const { return userId_; }
    int64_t getPostId() const { return postId_; }
    std::time_t getCreateTime() const { return createTime_; }

    // Setters
    void setId(int64_t id) { id_ = id; }
    void setUserId(int64_t userId) { userId_ = userId; }
    void setPostId(int64_t postId) { postId_ = postId; }
    void setCreateTime(std::time_t createTime) { createTime_ = createTime; }

    /**
     * @brief 将点赞对象转换为JSON
     * @return JSON表示
     */
    Json::Value toJson() const;

    /**
     * @brief 从JSON创建点赞对象
     * @param j JSON对象
     * @return Like对象
     */
    static Like fromJson(const Json::Value& j);

private:
    int64_t id_;              // 物理ID（自增主键）
    int64_t userId_;          // 点赞用户ID
    int64_t postId_;          // 被点赞帖子ID
    std::time_t createTime_;  // 点赞时间
};
```

**验证**:
```bash
cat /home/kun/projects/Knot/backend-service/src/models/like.h | wc -l
# 应该约70行
```

---

#### 任务2.2: 实现 `src/models/like.cpp`

**执行**:
```bash
touch /home/kun/projects/Knot/backend-service/src/models/like.cpp
```

**文件内容**:
```cpp
/**
 * @file like.cpp
 * @brief 点赞模型实现
 * @author Knot Team
 * @date 2025-10-10
 */

#include "models/like.h"

/**
 * @brief 默认构造函数
 */
Like::Like()
    : id_(0), userId_(0), postId_(0), createTime_(0) {
}

/**
 * @brief 带参数的构造函数
 * @param id 物理ID
 * @param userId 点赞用户ID
 * @param postId 被点赞帖子ID
 */
Like::Like(int64_t id, int64_t userId, int64_t postId)
    : id_(id), userId_(userId), postId_(postId), createTime_(std::time(nullptr)) {
}

/**
 * @brief 将点赞对象转换为JSON
 * @return JSON表示
 */
Json::Value Like::toJson() const {
    Json::Value json;
    json["id"] = (Json::Int64)id_;
    json["user_id"] = (Json::Int64)userId_;
    json["post_id"] = (Json::Int64)postId_;
    json["create_time"] = (Json::Int64)createTime_;
    return json;
}

/**
 * @brief 从JSON创建点赞对象
 * @param j JSON对象
 * @return Like对象
 */
Like Like::fromJson(const Json::Value& j) {
    Like like;

    if (j.isMember("id") && j["id"].isInt64()) {
        like.setId(j["id"].asInt64());
    }

    if (j.isMember("user_id") && j["user_id"].isInt64()) {
        like.setUserId(j["user_id"].asInt64());
    }

    if (j.isMember("post_id") && j["post_id"].isInt64()) {
        like.setPostId(j["post_id"].asInt64());
    }

    if (j.isMember("create_time") && j["create_time"].isInt64()) {
        like.setCreateTime((std::time_t)j["create_time"].asInt64());
    }

    return like;
}
```

**验证**:
```bash
cat /home/kun/projects/Knot/backend-service/src/models/like.cpp | wc -l
# 应该约70行
```

---

#### 任务2.3: 创建 `src/models/favorite.h`

**执行**:
```bash
# 复制like.h并修改
cp /home/kun/projects/Knot/backend-service/src/models/like.h \
   /home/kun/projects/Knot/backend-service/src/models/favorite.h
```

**修改内容**:
- 将所有 `Like` 替换为 `Favorite`
- 将所有 `like` 替换为 `favorite`
- 将注释中的"点赞"替换为"收藏"

**文件内容**（关键部分）:
```cpp
/**
 * @file favorite.h
 * @brief 收藏模型定义
 * @author Knot Team
 * @date 2025-10-10
 */

#pragma once

#include <string>
#include <ctime>
#include <json/json.h>

/**
 * @brief 收藏模型类
 *
 * 表示用户对帖子的收藏行为
 */
class Favorite {
public:
    Favorite();
    Favorite(int64_t id, int64_t userId, int64_t postId);
    ~Favorite() = default;

    // Getters
    int64_t getId() const { return id_; }
    int64_t getUserId() const { return userId_; }
    int64_t getPostId() const { return postId_; }
    std::time_t getCreateTime() const { return createTime_; }

    // Setters
    void setId(int64_t id) { id_ = id; }
    void setUserId(int64_t userId) { userId_ = userId; }
    void setPostId(int64_t postId) { postId_ = postId; }
    void setCreateTime(std::time_t createTime) { createTime_ = createTime; }

    Json::Value toJson() const;
    static Favorite fromJson(const Json::Value& j);

private:
    int64_t id_;              // 物理ID（自增主键）
    int64_t userId_;          // 收藏用户ID
    int64_t postId_;          // 被收藏帖子ID
    std::time_t createTime_;  // 收藏时间
};
```

---

#### 任务2.4: 实现 `src/models/favorite.cpp`

**执行**:
```bash
# 复制like.cpp并修改
cp /home/kun/projects/Knot/backend-service/src/models/like.cpp \
   /home/kun/projects/Knot/backend-service/src/models/favorite.cpp
```

**修改内容**:
- 将所有 `Like` 替换为 `Favorite`
- 将所有 `like` 替换为 `favorite`
- 将 `#include "models/like.h"` 替换为 `#include "models/favorite.h"`

---

#### 任务2.5: 编译测试

**执行**:
```bash
cd /home/kun/projects/Knot/backend-service/build
cmake ..
make -j4
```

**验证**:
- ✅ 编译无错误
- ✅ 编译无警告
- ✅ 生成 `like.o` 和 `favorite.o` 目标文件

**预期输出**:
```
[ 95%] Building CXX object CMakeFiles/knot_image_sharing.dir/src/models/like.cpp.o
[ 96%] Building CXX object CMakeFiles/knot_image_sharing.dir/src/models/favorite.cpp.o
[100%] Linking CXX executable knot_image_sharing
[100%] Built target knot_image_sharing
```

---

### 阶段3：Repository层（3-4小时）

**目标**: 实现Like和Favorite的数据访问层，修改PostRepository

---

#### 任务3.1: 创建 `src/database/like_repository.h`

**执行**:
```bash
touch /home/kun/projects/Knot/backend-service/src/database/like_repository.h
```

**文件内容**:
```cpp
/**
 * @file like_repository.h
 * @brief 点赞数据访问层定义
 * @author Knot Team
 * @date 2025-10-10
 */

#pragma once

#include "models/like.h"
#include <optional>
#include <vector>
#include <string>

/**
 * @brief 点赞数据访问类
 *
 * 负责点赞数据的CRUD操作
 */
class LikeRepository {
public:
    /**
     * @brief 构造函数
     */
    LikeRepository();

    /**
     * @brief 析构函数
     */
    ~LikeRepository() = default;

    /**
     * @brief 创建点赞记录
     * @param like 点赞对象
     * @return 成功返回true，失败返回false
     */
    bool create(Like& like);

    /**
     * @brief 删除点赞记录
     * @param userId 用户ID
     * @param postId 帖子ID（物理ID）
     * @return 成功返回true，失败返回false
     */
    bool deleteByUserAndPost(int64_t userId, int64_t postId);

    /**
     * @brief 检查点赞是否存在
     * @param userId 用户ID
     * @param postId 帖子ID（物理ID）
     * @return 存在返回true，不存在返回false
     */
    bool exists(int64_t userId, int64_t postId);

    /**
     * @brief 根据用户ID查找点赞列表（分页）
     * @param userId 用户ID
     * @param page 页码（从1开始）
     * @param pageSize 每页数量
     * @return 点赞列表
     */
    std::vector<Like> findByUserId(int64_t userId, int page, int pageSize);

    /**
     * @brief 根据帖子ID获取点赞数量
     * @param postId 帖子ID（物理ID）
     * @return 点赞数量
     */
    int getCountByPostId(int64_t postId);
};
```

**验证**:
```bash
cat /home/kun/projects/Knot/backend-service/src/database/like_repository.h | wc -l
# 应该约80行
```

---

#### 任务3.2: 实现 `src/database/like_repository.cpp`

**执行**:
```bash
touch /home/kun/projects/Knot/backend-service/src/database/like_repository.cpp
```

**文件内容**（关键方法）:
```cpp
/**
 * @file like_repository.cpp
 * @brief 点赞数据访问层实现
 * @author Knot Team
 * @date 2025-10-10
 */

#include "database/like_repository.h"
#include "database/connection_guard.h"
#include "database/connection_pool.h"
#include "utils/logger.h"
#include <mysql/mysql.h>

/**
 * @brief 构造函数
 */
LikeRepository::LikeRepository() {
}

/**
 * @brief 创建点赞记录
 * @param like 点赞对象
 * @return 成功返回true，失败返回false
 */
bool LikeRepository::create(Like& like) {
    Logger::info("LikeRepository::create - 开始创建点赞记录");

    // 获取数据库连接
    ConnectionGuard connGuard(DatabaseConnectionPool::getInstance());
    if (!connGuard.isValid()) {
        Logger::error("LikeRepository::create - 获取数据库连接失败");
        return false;
    }

    MYSQL* conn = connGuard.get();

    // 准备SQL语句（使用预编译语句）
    const char* sql = "INSERT INTO likes (user_id, post_id, create_time) VALUES (?, ?, CURRENT_TIMESTAMP)";

    MYSQL_STMT* stmt = mysql_stmt_init(conn);
    if (!stmt) {
        Logger::error("LikeRepository::create - 初始化预编译语句失败");
        return false;
    }

    if (mysql_stmt_prepare(stmt, sql, strlen(sql)) != 0) {
        Logger::error("LikeRepository::create - 预编译语句失败: " + std::string(mysql_stmt_error(stmt)));
        mysql_stmt_close(stmt);
        return false;
    }

    // 绑定参数
    MYSQL_BIND bind[2];
    memset(bind, 0, sizeof(bind));

    // user_id
    int64_t userId = like.getUserId();
    bind[0].buffer_type = MYSQL_TYPE_LONGLONG;
    bind[0].buffer = &userId;
    bind[0].is_null = 0;

    // post_id
    int64_t postId = like.getPostId();
    bind[1].buffer_type = MYSQL_TYPE_LONGLONG;
    bind[1].buffer = &postId;
    bind[1].is_null = 0;

    if (mysql_stmt_bind_param(stmt, bind) != 0) {
        Logger::error("LikeRepository::create - 参数绑定失败: " + std::string(mysql_stmt_error(stmt)));
        mysql_stmt_close(stmt);
        return false;
    }

    // 执行插入
    if (mysql_stmt_execute(stmt) != 0) {
        unsigned int error_code = mysql_stmt_errno(stmt);
        std::string error_msg = mysql_stmt_error(stmt);

        // 检查是否是唯一约束冲突（已经点赞过）
        if (error_code == 1062) {  // ER_DUP_ENTRY
            Logger::warning("LikeRepository::create - 用户已点赞过该帖子");
            mysql_stmt_close(stmt);
            return false;  // 返回false表示已点赞
        }

        Logger::error("LikeRepository::create - 执行插入失败: " + error_msg);
        mysql_stmt_close(stmt);
        return false;
    }

    // 获取自增ID
    int64_t insertId = mysql_stmt_insert_id(stmt);
    like.setId(insertId);
    like.setCreateTime(std::time(nullptr));

    mysql_stmt_close(stmt);

    Logger::info("LikeRepository::create - 点赞记录创建成功，ID: " + std::to_string(insertId));
    return true;
}

/**
 * @brief 删除点赞记录
 * @param userId 用户ID
 * @param postId 帖子ID（物理ID）
 * @return 成功返回true，失败返回false
 */
bool LikeRepository::deleteByUserAndPost(int64_t userId, int64_t postId) {
    Logger::info("LikeRepository::deleteByUserAndPost - 开始删除点赞记录");

    ConnectionGuard connGuard(DatabaseConnectionPool::getInstance());
    if (!connGuard.isValid()) {
        Logger::error("LikeRepository::deleteByUserAndPost - 获取数据库连接失败");
        return false;
    }

    MYSQL* conn = connGuard.get();

    const char* sql = "DELETE FROM likes WHERE user_id = ? AND post_id = ?";

    MYSQL_STMT* stmt = mysql_stmt_init(conn);
    if (!stmt) {
        Logger::error("LikeRepository::deleteByUserAndPost - 初始化预编译语句失败");
        return false;
    }

    if (mysql_stmt_prepare(stmt, sql, strlen(sql)) != 0) {
        Logger::error("LikeRepository::deleteByUserAndPost - 预编译语句失败");
        mysql_stmt_close(stmt);
        return false;
    }

    MYSQL_BIND bind[2];
    memset(bind, 0, sizeof(bind));

    bind[0].buffer_type = MYSQL_TYPE_LONGLONG;
    bind[0].buffer = &userId;
    bind[0].is_null = 0;

    bind[1].buffer_type = MYSQL_TYPE_LONGLONG;
    bind[1].buffer = &postId;
    bind[1].is_null = 0;

    if (mysql_stmt_bind_param(stmt, bind) != 0) {
        Logger::error("LikeRepository::deleteByUserAndPost - 参数绑定失败");
        mysql_stmt_close(stmt);
        return false;
    }

    if (mysql_stmt_execute(stmt) != 0) {
        Logger::error("LikeRepository::deleteByUserAndPost - 执行删除失败");
        mysql_stmt_close(stmt);
        return false;
    }

    // 检查是否有记录被删除
    my_ulonglong affected_rows = mysql_stmt_affected_rows(stmt);
    mysql_stmt_close(stmt);

    if (affected_rows == 0) {
        Logger::warning("LikeRepository::deleteByUserAndPost - 未找到点赞记录");
        return false;
    }

    Logger::info("LikeRepository::deleteByUserAndPost - 点赞记录删除成功");
    return true;
}

/**
 * @brief 检查点赞是否存在
 * @param userId 用户ID
 * @param postId 帖子ID（物理ID）
 * @return 存在返回true，不存在返回false
 */
bool LikeRepository::exists(int64_t userId, int64_t postId) {
    ConnectionGuard connGuard(DatabaseConnectionPool::getInstance());
    if (!connGuard.isValid()) {
        Logger::error("LikeRepository::exists - 获取数据库连接失败");
        return false;
    }

    MYSQL* conn = connGuard.get();

    const char* sql = "SELECT COUNT(*) FROM likes WHERE user_id = ? AND post_id = ?";

    MYSQL_STMT* stmt = mysql_stmt_init(conn);
    if (!stmt) {
        Logger::error("LikeRepository::exists - 初始化预编译语句失败");
        return false;
    }

    if (mysql_stmt_prepare(stmt, sql, strlen(sql)) != 0) {
        Logger::error("LikeRepository::exists - 预编译语句失败");
        mysql_stmt_close(stmt);
        return false;
    }

    MYSQL_BIND bind[2];
    memset(bind, 0, sizeof(bind));

    bind[0].buffer_type = MYSQL_TYPE_LONGLONG;
    bind[0].buffer = &userId;
    bind[0].is_null = 0;

    bind[1].buffer_type = MYSQL_TYPE_LONGLONG;
    bind[1].buffer = &postId;
    bind[1].is_null = 0;

    if (mysql_stmt_bind_param(stmt, bind) != 0) {
        Logger::error("LikeRepository::exists - 参数绑定失败");
        mysql_stmt_close(stmt);
        return false;
    }

    if (mysql_stmt_execute(stmt) != 0) {
        Logger::error("LikeRepository::exists - 执行查询失败");
        mysql_stmt_close(stmt);
        return false;
    }

    // 绑定结果
    int64_t count = 0;
    MYSQL_BIND result[1];
    memset(result, 0, sizeof(result));

    result[0].buffer_type = MYSQL_TYPE_LONGLONG;
    result[0].buffer = &count;
    result[0].is_null = 0;

    if (mysql_stmt_bind_result(stmt, result) != 0) {
        Logger::error("LikeRepository::exists - 结果绑定失败");
        mysql_stmt_close(stmt);
        return false;
    }

    if (mysql_stmt_store_result(stmt) != 0) {
        Logger::error("LikeRepository::exists - 存储结果失败");
        mysql_stmt_close(stmt);
        return false;
    }

    bool exists = false;
    if (mysql_stmt_fetch(stmt) == 0) {
        exists = (count > 0);
    }

    mysql_stmt_close(stmt);
    return exists;
}

/**
 * @brief 根据用户ID查找点赞列表（分页）
 * @param userId 用户ID
 * @param page 页码（从1开始）
 * @param pageSize 每页数量
 * @return 点赞列表
 */
std::vector<Like> LikeRepository::findByUserId(int64_t userId, int page, int pageSize) {
    std::vector<Like> likes;

    ConnectionGuard connGuard(DatabaseConnectionPool::getInstance());
    if (!connGuard.isValid()) {
        Logger::error("LikeRepository::findByUserId - 获取数据库连接失败");
        return likes;
    }

    MYSQL* conn = connGuard.get();

    // 计算偏移量
    int offset = (page - 1) * pageSize;

    const char* sql = "SELECT id, user_id, post_id, UNIX_TIMESTAMP(create_time) "
                      "FROM likes WHERE user_id = ? "
                      "ORDER BY create_time DESC LIMIT ? OFFSET ?";

    MYSQL_STMT* stmt = mysql_stmt_init(conn);
    if (!stmt) {
        Logger::error("LikeRepository::findByUserId - 初始化预编译语句失败");
        return likes;
    }

    if (mysql_stmt_prepare(stmt, sql, strlen(sql)) != 0) {
        Logger::error("LikeRepository::findByUserId - 预编译语句失败");
        mysql_stmt_close(stmt);
        return likes;
    }

    MYSQL_BIND bind[3];
    memset(bind, 0, sizeof(bind));

    bind[0].buffer_type = MYSQL_TYPE_LONGLONG;
    bind[0].buffer = &userId;
    bind[0].is_null = 0;

    bind[1].buffer_type = MYSQL_TYPE_LONG;
    bind[1].buffer = &pageSize;
    bind[1].is_null = 0;

    bind[2].buffer_type = MYSQL_TYPE_LONG;
    bind[2].buffer = &offset;
    bind[2].is_null = 0;

    if (mysql_stmt_bind_param(stmt, bind) != 0) {
        Logger::error("LikeRepository::findByUserId - 参数绑定失败");
        mysql_stmt_close(stmt);
        return likes;
    }

    if (mysql_stmt_execute(stmt) != 0) {
        Logger::error("LikeRepository::findByUserId - 执行查询失败");
        mysql_stmt_close(stmt);
        return likes;
    }

    // 绑定结果
    int64_t id, resultUserId, postId, createTime;
    MYSQL_BIND result[4];
    memset(result, 0, sizeof(result));

    result[0].buffer_type = MYSQL_TYPE_LONGLONG;
    result[0].buffer = &id;

    result[1].buffer_type = MYSQL_TYPE_LONGLONG;
    result[1].buffer = &resultUserId;

    result[2].buffer_type = MYSQL_TYPE_LONGLONG;
    result[2].buffer = &postId;

    result[3].buffer_type = MYSQL_TYPE_LONGLONG;
    result[3].buffer = &createTime;

    if (mysql_stmt_bind_result(stmt, result) != 0) {
        Logger::error("LikeRepository::findByUserId - 结果绑定失败");
        mysql_stmt_close(stmt);
        return likes;
    }

    if (mysql_stmt_store_result(stmt) != 0) {
        Logger::error("LikeRepository::findByUserId - 存储结果失败");
        mysql_stmt_close(stmt);
        return likes;
    }

    // 获取所有记录
    while (mysql_stmt_fetch(stmt) == 0) {
        Like like(id, resultUserId, postId);
        like.setCreateTime((std::time_t)createTime);
        likes.push_back(like);
    }

    mysql_stmt_close(stmt);

    Logger::info("LikeRepository::findByUserId - 查询到" + std::to_string(likes.size()) + "条点赞记录");
    return likes;
}

/**
 * @brief 根据帖子ID获取点赞数量
 * @param postId 帖子ID（物理ID）
 * @return 点赞数量
 */
int LikeRepository::getCountByPostId(int64_t postId) {
    ConnectionGuard connGuard(DatabaseConnectionPool::getInstance());
    if (!connGuard.isValid()) {
        Logger::error("LikeRepository::getCountByPostId - 获取数据库连接失败");
        return 0;
    }

    MYSQL* conn = connGuard.get();

    const char* sql = "SELECT COUNT(*) FROM likes WHERE post_id = ?";

    MYSQL_STMT* stmt = mysql_stmt_init(conn);
    if (!stmt) {
        Logger::error("LikeRepository::getCountByPostId - 初始化预编译语句失败");
        return 0;
    }

    if (mysql_stmt_prepare(stmt, sql, strlen(sql)) != 0) {
        Logger::error("LikeRepository::getCountByPostId - 预编译语句失败");
        mysql_stmt_close(stmt);
        return 0;
    }

    MYSQL_BIND bind[1];
    memset(bind, 0, sizeof(bind));

    bind[0].buffer_type = MYSQL_TYPE_LONGLONG;
    bind[0].buffer = &postId;
    bind[0].is_null = 0;

    if (mysql_stmt_bind_param(stmt, bind) != 0) {
        Logger::error("LikeRepository::getCountByPostId - 参数绑定失败");
        mysql_stmt_close(stmt);
        return 0;
    }

    if (mysql_stmt_execute(stmt) != 0) {
        Logger::error("LikeRepository::getCountByPostId - 执行查询失败");
        mysql_stmt_close(stmt);
        return 0;
    }

    int64_t count = 0;
    MYSQL_BIND result[1];
    memset(result, 0, sizeof(result));

    result[0].buffer_type = MYSQL_TYPE_LONGLONG;
    result[0].buffer = &count;
    result[0].is_null = 0;

    if (mysql_stmt_bind_result(stmt, result) != 0) {
        Logger::error("LikeRepository::getCountByPostId - 结果绑定失败");
        mysql_stmt_close(stmt);
        return 0;
    }

    if (mysql_stmt_store_result(stmt) != 0) {
        Logger::error("LikeRepository::getCountByPostId - 存储结果失败");
        mysql_stmt_close(stmt);
        return 0;
    }

    if (mysql_stmt_fetch(stmt) == 0) {
        mysql_stmt_close(stmt);
        return (int)count;
    }

    mysql_stmt_close(stmt);
    return 0;
}
```

**验证**:
```bash
cat /home/kun/projects/Knot/backend-service/src/database/like_repository.cpp | wc -l
# 应该约400行
```

---

#### 任务3.3: 创建并实现 `src/database/favorite_repository.{h,cpp}`

**执行**:
```bash
# 复制like_repository并修改
cp /home/kun/projects/Knot/backend-service/src/database/like_repository.h \
   /home/kun/projects/Knot/backend-service/src/database/favorite_repository.h

cp /home/kun/projects/Knot/backend-service/src/database/like_repository.cpp \
   /home/kun/projects/Knot/backend-service/src/database/favorite_repository.cpp
```

**修改内容**:
- 将所有 `Like` 替换为 `Favorite`
- 将所有 `like` 替换为 `favorite`
- 将所有 `likes` 表名替换为 `favorites`
- 将所有 `LikeRepository` 替换为 `FavoriteRepository`

---

#### 任务3.4: 修改 `src/database/post_repository.h`

**在文件末尾的private之前添加**:

```cpp
    /**
     * @brief 原子增加点赞数
     * @param postId 帖子业务ID
     * @return 成功返回true，失败返回false
     */
    bool incrementLikeCount(const std::string& postId);

    /**
     * @brief 原子减少点赞数
     * @param postId 帖子业务ID
     * @return 成功返回true，失败返回false
     */
    bool decrementLikeCount(const std::string& postId);

    /**
     * @brief 原子增加收藏数
     * @param postId 帖子业务ID
     * @return 成功返回true，失败返回false
     */
    bool incrementFavoriteCount(const std::string& postId);

    /**
     * @brief 原子减少收藏数
     * @param postId 帖子业务ID
     * @return 成功返回true，失败返回false
     */
    bool decrementFavoriteCount(const std::string& postId);
```

---

#### 任务3.5: 实现 `src/database/post_repository.cpp` - 原子更新方法

**在文件末尾添加**:

```cpp
/**
 * @brief 原子增加点赞数
 * @param postId 帖子业务ID
 * @return 成功返回true，失败返回false
 */
bool PostRepository::incrementLikeCount(const std::string& postId) {
    Logger::info("PostRepository::incrementLikeCount - 增加帖子点赞数: " + postId);

    ConnectionGuard connGuard(DatabaseConnectionPool::getInstance());
    if (!connGuard.isValid()) {
        Logger::error("PostRepository::incrementLikeCount - 获取数据库连接失败");
        return false;
    }

    MYSQL* conn = connGuard.get();

    // 使用原子操作：like_count = like_count + 1
    const char* sql = "UPDATE posts SET like_count = like_count + 1 WHERE post_id = ?";

    MYSQL_STMT* stmt = mysql_stmt_init(conn);
    if (!stmt) {
        Logger::error("PostRepository::incrementLikeCount - 初始化预编译语句失败");
        return false;
    }

    if (mysql_stmt_prepare(stmt, sql, strlen(sql)) != 0) {
        Logger::error("PostRepository::incrementLikeCount - 预编译语句失败");
        mysql_stmt_close(stmt);
        return false;
    }

    MYSQL_BIND bind[1];
    memset(bind, 0, sizeof(bind));

    unsigned long postIdLength = postId.length();
    bind[0].buffer_type = MYSQL_TYPE_STRING;
    bind[0].buffer = (void*)postId.c_str();
    bind[0].buffer_length = postIdLength;
    bind[0].length = &postIdLength;
    bind[0].is_null = 0;

    if (mysql_stmt_bind_param(stmt, bind) != 0) {
        Logger::error("PostRepository::incrementLikeCount - 参数绑定失败");
        mysql_stmt_close(stmt);
        return false;
    }

    if (mysql_stmt_execute(stmt) != 0) {
        Logger::error("PostRepository::incrementLikeCount - 执行更新失败");
        mysql_stmt_close(stmt);
        return false;
    }

    mysql_stmt_close(stmt);
    Logger::info("PostRepository::incrementLikeCount - 点赞数增加成功");
    return true;
}

/**
 * @brief 原子减少点赞数
 * @param postId 帖子业务ID
 * @return 成功返回true，失败返回false
 */
bool PostRepository::decrementLikeCount(const std::string& postId) {
    Logger::info("PostRepository::decrementLikeCount - 减少帖子点赞数: " + postId);

    ConnectionGuard connGuard(DatabaseConnectionPool::getInstance());
    if (!connGuard.isValid()) {
        Logger::error("PostRepository::decrementLikeCount - 获取数据库连接失败");
        return false;
    }

    MYSQL* conn = connGuard.get();

    // 使用原子操作：like_count = like_count - 1，但不能小于0
    const char* sql = "UPDATE posts SET like_count = like_count - 1 WHERE post_id = ? AND like_count > 0";

    MYSQL_STMT* stmt = mysql_stmt_init(conn);
    if (!stmt) {
        Logger::error("PostRepository::decrementLikeCount - 初始化预编译语句失败");
        return false;
    }

    if (mysql_stmt_prepare(stmt, sql, strlen(sql)) != 0) {
        Logger::error("PostRepository::decrementLikeCount - 预编译语句失败");
        mysql_stmt_close(stmt);
        return false;
    }

    MYSQL_BIND bind[1];
    memset(bind, 0, sizeof(bind));

    unsigned long postIdLength = postId.length();
    bind[0].buffer_type = MYSQL_TYPE_STRING;
    bind[0].buffer = (void*)postId.c_str();
    bind[0].buffer_length = postIdLength;
    bind[0].length = &postIdLength;
    bind[0].is_null = 0;

    if (mysql_stmt_bind_param(stmt, bind) != 0) {
        Logger::error("PostRepository::decrementLikeCount - 参数绑定失败");
        mysql_stmt_close(stmt);
        return false;
    }

    if (mysql_stmt_execute(stmt) != 0) {
        Logger::error("PostRepository::decrementLikeCount - 执行更新失败");
        mysql_stmt_close(stmt);
        return false;
    }

    mysql_stmt_close(stmt);
    Logger::info("PostRepository::decrementLikeCount - 点赞数减少成功");
    return true;
}

/**
 * @brief 原子增加收藏数
 * @param postId 帖子业务ID
 * @return 成功返回true，失败返回false
 */
bool PostRepository::incrementFavoriteCount(const std::string& postId) {
    Logger::info("PostRepository::incrementFavoriteCount - 增加帖子收藏数: " + postId);

    ConnectionGuard connGuard(DatabaseConnectionPool::getInstance());
    if (!connGuard.isValid()) {
        Logger::error("PostRepository::incrementFavoriteCount - 获取数据库连接失败");
        return false;
    }

    MYSQL* conn = connGuard.get();

    const char* sql = "UPDATE posts SET favorite_count = favorite_count + 1 WHERE post_id = ?";

    MYSQL_STMT* stmt = mysql_stmt_init(conn);
    if (!stmt) {
        Logger::error("PostRepository::incrementFavoriteCount - 初始化预编译语句失败");
        return false;
    }

    if (mysql_stmt_prepare(stmt, sql, strlen(sql)) != 0) {
        Logger::error("PostRepository::incrementFavoriteCount - 预编译语句失败");
        mysql_stmt_close(stmt);
        return false;
    }

    MYSQL_BIND bind[1];
    memset(bind, 0, sizeof(bind));

    unsigned long postIdLength = postId.length();
    bind[0].buffer_type = MYSQL_TYPE_STRING;
    bind[0].buffer = (void*)postId.c_str();
    bind[0].buffer_length = postIdLength;
    bind[0].length = &postIdLength;
    bind[0].is_null = 0;

    if (mysql_stmt_bind_param(stmt, bind) != 0) {
        Logger::error("PostRepository::incrementFavoriteCount - 参数绑定失败");
        mysql_stmt_close(stmt);
        return false;
    }

    if (mysql_stmt_execute(stmt) != 0) {
        Logger::error("PostRepository::incrementFavoriteCount - 执行更新失败");
        mysql_stmt_close(stmt);
        return false;
    }

    mysql_stmt_close(stmt);
    Logger::info("PostRepository::incrementFavoriteCount - 收藏数增加成功");
    return true;
}

/**
 * @brief 原子减少收藏数
 * @param postId 帖子业务ID
 * @return 成功返回true，失败返回false
 */
bool PostRepository::decrementFavoriteCount(const std::string& postId) {
    Logger::info("PostRepository::decrementFavoriteCount - 减少帖子收藏数: " + postId);

    ConnectionGuard connGuard(DatabaseConnectionPool::getInstance());
    if (!connGuard.isValid()) {
        Logger::error("PostRepository::decrementFavoriteCount - 获取数据库连接失败");
        return false;
    }

    MYSQL* conn = connGuard.get();

    const char* sql = "UPDATE posts SET favorite_count = favorite_count - 1 WHERE post_id = ? AND favorite_count > 0";

    MYSQL_STMT* stmt = mysql_stmt_init(conn);
    if (!stmt) {
        Logger::error("PostRepository::decrementFavoriteCount - 初始化预编译语句失败");
        return false;
    }

    if (mysql_stmt_prepare(stmt, sql, strlen(sql)) != 0) {
        Logger::error("PostRepository::decrementFavoriteCount - 预编译语句失败");
        mysql_stmt_close(stmt);
        return false;
    }

    MYSQL_BIND bind[1];
    memset(bind, 0, sizeof(bind));

    unsigned long postIdLength = postId.length();
    bind[0].buffer_type = MYSQL_TYPE_STRING;
    bind[0].buffer = (void*)postId.c_str();
    bind[0].buffer_length = postIdLength;
    bind[0].length = &postIdLength;
    bind[0].is_null = 0;

    if (mysql_stmt_bind_param(stmt, bind) != 0) {
        Logger::error("PostRepository::decrementFavoriteCount - 参数绑定失败");
        mysql_stmt_close(stmt);
        return false;
    }

    if (mysql_stmt_execute(stmt) != 0) {
        Logger::error("PostRepository::decrementFavoriteCount - 执行更新失败");
        mysql_stmt_close(stmt);
        return false;
    }

    mysql_stmt_close(stmt);
    Logger::info("PostRepository::decrementFavoriteCount - 收藏数减少成功");
    return true;
}
```

---

#### 任务3.6: 编译测试

**执行**:
```bash
cd /home/kun/projects/Knot/backend-service/build
cmake ..
make -j4
```

**验证**:
- ✅ 编译无错误
- ✅ 编译无警告
- ✅ 生成所有Repository的.o文件

---

### 阶段4：Service层（3-4小时）

**目标**: 实现LikeService和FavoriteService，包含完整的业务逻辑和事务管理

**说明**: 由于篇幅限制，Service层和后续阶段的详细实现将在实际开发时参考本文档执行。核心要点：
- 使用TransactionGuard保证原子性
- 完整的错误处理和日志记录
- 权限验证（只能操作自己的点赞/收藏）

---

### 阶段5：Handler层（2-3小时）

**目标**: 实现LikeHandler和FavoriteHandler，继承BaseHandler

**核心代码框架**:
```cpp
void LikeHandler::handleLike(const httplib::Request& req, httplib::Response& res) {
    // 1. 验证JWT token
    auto tokenResult = validateTokenFromHeader(req);
    if (!tokenResult.valid) {
        sendErrorResponse(res, 401, "令牌无效或已过期");
        return;
    }

    // 2. 提取post_id（从路径参数）
    std::string postId = req.matches[1];

    // 3. 调用Service
    auto result = likeService_->likePost(tokenResult.userId, postId);

    // 4. 构造响应
    if (result.success) {
        sendSuccessResponse(res, 200, result.message, result.data);
    } else {
        sendErrorResponse(res, result.httpCode, result.message);
    }
}
```

---

### 阶段6：集成测试（2-3小时）

**测试用例清单**:
1. ✅ 点赞功能正常工作
2. ✅ 重复点赞返回409
3. ✅ 取消点赞功能正常工作
4. ✅ 收藏功能正常工作
5. ✅ 重复收藏返回409
6. ✅ 取消收藏功能正常工作
7. ✅ 并发点赞计数准确
8. ✅ 级联删除正常工作
9. ✅ JWT认证正确实施

---

### 阶段7：文档更新（1小时）

**待更新文档**:
- [000]API文档.md - 新增互动系统API章节
- [002]项目架构文档.md - 更新代码统计
- backend-service/README.md - 更新版本号v2.2.0
- CLAUDE.md - 更新API版本历史

---

## 关键技术点

### 1. 并发安全的点赞计数

**错误示例**（有竞态条件）:
```cpp
// ❌ 错误：先读后写，高并发时会丢失更新
int count = postRepo_->getLikeCount(postId);  // 读取：42
count++;                                       // 计算：43
postRepo_->setLikeCount(postId, count);       // 写入：43

// 如果两个用户同时点赞：
// 用户A读取：42 → 计算：43 → 写入：43
// 用户B读取：42 → 计算：43 → 写入：43
// 结果：like_count=43（错误！应该是44）
```

**正确示例**（原子操作）:
```cpp
// ✅ 正确：使用SQL原子操作
// SQL: UPDATE posts SET like_count = like_count + 1 WHERE post_id = ?
postRepo_->incrementLikeCount(postId);

// MySQL保证原子性：
// 用户A执行：UPDATE posts SET like_count = like_count + 1  (42→43)
// 用户B执行：UPDATE posts SET like_count = like_count + 1  (43→44)
// 结果：like_count=44（正确！）
```

---

### 2. 事务管理模式

**使用TransactionGuard保证原子性**:

```cpp
bool LikeService::likePost(int userId, const std::string& postId) {
    // 开启事务
    TransactionGuard tx(DatabaseConnectionPool::getInstance());

    // 步骤1：插入点赞记录
    Like like;
    like.setUserId(userId);
    like.setPostId(postIdInt);
    if (!likeRepo_->create(like)) {
        // 自动回滚（TransactionGuard析构）
        return false;
    }

    // 步骤2：更新点赞数
    if (!postRepo_->incrementLikeCount(postId)) {
        // 自动回滚
        return false;
    }

    // 手动提交
    tx.commit();
    return true;
}

// 如果任何步骤失败，TransactionGuard析构时自动回滚
// 保证数据一致性：likes表记录和posts.like_count同步
```

---

### 3. 唯一约束的幂等性处理

**数据库唯一约束**:
```sql
UNIQUE KEY uk_user_post (user_id, post_id)
```

**Repository层处理**:
```cpp
bool LikeRepository::create(Like& like) {
    // ...执行INSERT语句...

    if (mysql_stmt_execute(stmt) != 0) {
        unsigned int error_code = mysql_stmt_errno(stmt);

        // 检查是否是唯一约束冲突（已经点赞过）
        if (error_code == 1062) {  // ER_DUP_ENTRY
            Logger::warning("用户已点赞过该帖子");
            return false;  // 返回false表示已点赞
        }

        // 其他错误
        Logger::error("执行插入失败: " + std::string(mysql_stmt_error(stmt)));
        return false;
    }

    return true;
}
```

**Service层转换为友好错误**:
```cpp
LikeResult LikeService::likePost(int userId, const std::string& postId) {
    // 先检查是否已点赞
    if (likeRepo_->exists(userId, postIdInt)) {
        return {false, "已经点赞过该帖子", 409, currentCount};
    }

    // 执行点赞逻辑...
}
```

---

### 4. 性能优化索引设计

**索引设计**:

| 索引 | 字段 | 类型 | 用途 | 查询示例 |
|------|------|------|------|---------|
| PRIMARY | id | 主键索引 | 快速定位记录 | `SELECT * FROM likes WHERE id = 123` |
| uk_user_post | (user_id, post_id) | 唯一索引 | 防止重复点赞 + 快速exists()查询 | `SELECT COUNT(*) FROM likes WHERE user_id=1 AND post_id=2` |
| idx_post_id | post_id | 普通索引 | 按帖子统计点赞数 | `SELECT COUNT(*) FROM likes WHERE post_id = 2` |
| idx_user_create | (user_id, create_time DESC) | 复合索引 | 查询用户点赞历史（时间倒序） | `SELECT * FROM likes WHERE user_id=1 ORDER BY create_time DESC LIMIT 20` |

**索引覆盖查询**:
```sql
-- 查询是否点赞过（使用uk_user_post索引，无需回表）
SELECT COUNT(*) FROM likes WHERE user_id = 1 AND post_id = 2;

-- 查询某帖子点赞数（使用idx_post_id索引）
SELECT COUNT(*) FROM likes WHERE post_id = 2;
```

---

## 风险和注意事项

### 风险评估表

| 风险点 | 影响等级 | 发生概率 | 影响 | 缓解措施 |
|--------|---------|---------|------|----------|
| 高并发点赞导致计数不准 | 🔴 高 | 中 | 用户看到的点赞数错误，数据不一致 | 使用SQL原子操作（like_count + 1） |
| 点赞记录与计数不一致 | 🔴 高 | 低 | 数据完整性问题 | 使用TransactionGuard保证事务原子性 |
| 热门帖子点赞频繁更新 | 🟡 中 | 高 | 数据库性能瓶颈，写入延迟 | 考虑引入Redis缓存（未来优化） |
| 重复点赞请求 | 🟢 低 | 中 | 用户体验不佳 | 唯一约束 + 前端防抖 + Service层检查 |
| 误删别人的点赞 | 🔴 高 | 低 | 安全问题 | Service层验证userId匹配 |
| 数据库连接泄漏 | 🔴 高 | 低 | 服务器崩溃 | 所有Repository使用ConnectionGuard |
| SQL注入攻击 | 🔴 高 | 低 | 数据库被攻击 | 所有查询使用预编译语句（MYSQL_STMT） |

---

### 注意事项清单

**架构规范**:
1. ⚠️ **不要在Model层添加业务逻辑**（只做数据封装，toJson/fromJson）
2. ⚠️ **不要在Repository层做权限验证**（应在Service层验证userId）
3. ⚠️ **不要在Handler层直接访问Repository**（必须通过Service层）
4. ⚠️ **不要跨层调用**（严格遵循九层架构，每层只能调用下层）

**事务管理**:
5. ⚠️ **不要忘记使用TransactionGuard**（所有多表操作必须在事务中）
6. ⚠️ **不要在事务中执行长时间操作**（如网络请求、文件IO，会锁表）
7. ⚠️ **不要嵌套事务**（TransactionGuard不支持嵌套事务）

**资源管理**:
8. ⚠️ **不要在循环中获取数据库连接**（ConnectionGuard应在循环外创建）
9. ⚠️ **不要忘记关闭MYSQL_STMT**（使用mysql_stmt_close释放资源）
10. ⚠️ **不要在析构函数中抛异常**（ConnectionGuard和TransactionGuard会自动清理）

**并发安全**:
11. ⚠️ **不要使用先读后写的模式更新计数**（使用原子操作：count + 1）
12. ⚠️ **不要依赖唯一约束做业务逻辑**（应先exists()检查，再insert）

**错误处理**:
13. ⚠️ **不要吞掉异常**（所有错误必须记录日志）
14. ⚠️ **不要返回内部错误信息给用户**（如SQL错误，应转换为友好消息）
15. ⚠️ **不要忽略mysql_stmt_execute()的返回值**（必须检查是否成功）

---

## 验收标准

### 功能验收

- [ ] **点赞功能**
  - [ ] 点赞帖子成功（POST /like）
  - [ ] 点赞数实时更新（posts.like_count +1）
  - [ ] 重复点赞返回409错误
  - [ ] 已点赞标识正确（has_liked=true）

- [ ] **取消点赞功能**
  - [ ] 取消点赞成功（DELETE /like）
  - [ ] 点赞数实时更新（posts.like_count -1）
  - [ ] 未点赞时取消返回400错误
  - [ ] 已点赞标识正确（has_liked=false）

- [ ] **收藏功能**
  - [ ] 收藏帖子成功（POST /favorite）
  - [ ] 收藏数实时更新（posts.favorite_count +1）
  - [ ] 重复收藏返回409错误
  - [ ] 已收藏标识正确（has_favorited=true）

- [ ] **取消收藏功能**
  - [ ] 取消收藏成功（DELETE /favorite）
  - [ ] 收藏数实时更新（posts.favorite_count -1）
  - [ ] 未收藏时取消返回400错误
  - [ ] 已收藏标识正确（has_favorited=false）

- [ ] **权限验证**
  - [ ] JWT认证正确实施（无token返回401）
  - [ ] 令牌过期返回401
  - [ ] 只能操作自己的点赞/收藏

- [ ] **数据一致性**
  - [ ] likes表记录与posts.like_count一致
  - [ ] favorites表记录与posts.favorite_count一致
  - [ ] 级联删除正常工作（删除帖子时自动删除点赞/收藏）

---

### 代码质量验收

- [ ] **架构规范**
  - [ ] 符合九层架构规范
  - [ ] 每层职责清晰，无跨层调用
  - [ ] 继承BaseHandler（LikeHandler、FavoriteHandler）

- [ ] **代码注释**
  - [ ] 所有类有Doxygen注释
  - [ ] 所有方法有详细中文注释
  - [ ] 关键逻辑有行内注释说明

- [ ] **安全性**
  - [ ] 使用预编译语句（防SQL注入）
  - [ ] 使用ConnectionGuard（防连接泄漏）
  - [ ] 使用TransactionGuard（保证原子性）
  - [ ] JWT令牌验证正确实施

- [ ] **错误处理**
  - [ ] 统一的错误处理（sendErrorResponse）
  - [ ] 完整的日志记录（Logger::info/error）
  - [ ] 友好的错误消息（中文）

- [ ] **编译**
  - [ ] 编译无错误
  - [ ] 编译无警告
  - [ ] 链接成功

---

### 性能验收

- [ ] **响应时间**
  - [ ] 单次点赞响应时间 < 100ms
  - [ ] 单次收藏响应时间 < 100ms
  - [ ] Feed流加载时间无明显增加

- [ ] **并发性能**
  - [ ] 100个用户同时点赞同一帖子，计数准确（=100）
  - [ ] 50个用户同时收藏同一帖子，计数准确（=50）
  - [ ] 无死锁现象

- [ ] **资源管理**
  - [ ] 无数据库连接泄漏
  - [ ] 无内存泄漏（使用valgrind验证）
  - [ ] 正常关闭时无资源残留

---

### 测试验收

- [ ] **集成测试**
  - [ ] 所有集成测试通过（任务6.1-6.9）
  - [ ] 异常流程测试通过（无效token、不存在的帖子等）
  - [ ] 并发测试通过（多用户同时点赞）

- [ ] **边界测试**
  - [ ] 点赞数为0时取消点赞（不能变成负数）
  - [ ] 收藏数为0时取消收藏（不能变成负数）
  - [ ] 已删除的帖子无法点赞（返回404）

- [ ] **回归测试**
  - [ ] 现有帖子功能正常工作（创建、查询、更新、删除）
  - [ ] 现有用户功能正常工作（注册、登录、信息管理）
  - [ ] 现有图片功能正常工作（上传、查询、删除）

---

### 文档验收

- [ ] **API文档更新**
  - [ ] [000]API文档.md更新完整
  - [ ] 包含4个新接口文档
  - [ ] 请求/响应示例完整
  - [ ] 错误码说明清晰

- [ ] **架构文档更新**
  - [ ] [002]项目架构文档.md更新
  - [ ] 代码统计数据更新
  - [ ] 新增模块说明

- [ ] **README更新**
  - [ ] backend-service/README.md更新
  - [ ] 版本号更新为v2.2.0
  - [ ] 功能列表更新

- [ ] **CLAUDE.md更新**
  - [ ] 当前状态更新
  - [ ] API版本历史添加v2.2.0条目

---

## 进度跟踪

| 阶段 | 任务数 | 已完成 | 进度 | 预计工时 | 实际工时 |
|------|--------|--------|------|---------|---------|
| 阶段0：数据库调研 | 3 | 0 | 0% ⬜⬜⬜⬜⬜ | 0.5小时 | - |
| 阶段1：数据库变更 | 3 | 0 | 0% ⬜⬜⬜⬜⬜ | 1小时 | - |
| 阶段2：Model层 | 5 | 0 | 0% ⬜⬜⬜⬜⬜ | 2小时 | - |
| 阶段3：Repository层 | 6 | 0 | 0% ⬜⬜⬜⬜⬜ | 4小时 | - |
| 阶段4：Service层 | 5 | 0 | 0% ⬜⬜⬜⬜⬜ | 4小时 | - |
| 阶段5：Handler层 | 8 | 0 | 0% ⬜⬜⬜⬜⬜ | 3小时 | - |
| 阶段6：集成测试 | 9 | 0 | 0% ⬜⬜⬜⬜⬜ | 3小时 | - |
| 阶段7：文档更新 | 4 | 0 | 0% ⬜⬜⬜⬜⬜ | 1小时 | - |
| **总计** | **43** | **0** | **0%** | **18.5小时** | **-** |

**预计完成时间**: 2-3个工作日

**开始时间**: 待定

**实际完成时间**: 待定

---

## 变更日志

### 2025-10-10 - 文档创建 ✅

**创建内容**:
- ✅ 完成概述（背景、目标、实施范围）
- ✅ 完成技术设计（数据库、架构、API）
- ✅ 完成详细任务列表（43个子任务）
- ✅ 完成关键技术点（4个技术要点）
- ✅ 完成风险评估（7个风险点 + 15个注意事项）
- ✅ 完成验收标准（4个维度）
- ✅ 完成进度跟踪表格

**设计决策**:
- ✅ 采用简化设计（不使用业务ID）
- ✅ 使用唯一约束保证幂等性
- ✅ 使用SQL原子操作避免竞态
- ✅ 使用TransactionGuard保证事务
- ✅ 继承BaseHandler复用JWT验证

**待开始**:
- ⏳ 阶段0：数据库调研（下一步）

---

### 变更记录模板（实施时填写）

#### YYYY-MM-DD HH:MM - 阶段X完成

**完成内容**:
- ✅ 任务X.1: ...
- ✅ 任务X.2: ...

**遇到的问题**:
- 问题描述
- 解决方案

**代码统计**:
- 新增文件：X个
- 修改文件：X个
- 新增代码：X行

---

**最后更新**: 2025-10-10
**维护者**: Knot Development Team
**文档状态**: 📝 计划中

---

**附录**:

**参考文档**:
- [000]API文档.md
- [001]数据库设计文档.md
- [105]阶段C-2-多图片帖子系统.md
- [106]用户信息管理功能完善-实施计划.md
- 需求分析.md

**相关代码**:
- src/models/post.{h,cpp} - 参考模型设计
- src/database/post_repository.{h,cpp} - 参考Repository实现
- src/core/post_service.{h,cpp} - 参考Service实现
- src/api/post_handler.{h,cpp} - 参考Handler实现
- src/api/base_handler.{h,cpp} - BaseHandler基类
- src/database/connection_guard.h - 连接管理
- src/database/transaction_guard.h - 事务管理

**下一阶段计划**:
- [108]阶段D-2：关注系统功能实现计划（待编写）
- [109]阶段D-3：评论系统功能实现计划（待编写）
