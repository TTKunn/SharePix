# 创建帖子请求流程文档

## 一、概述

创建帖子功能使用 `multipart/form-data` 格式上传数据，支持多图片上传和文本字段传输。

**请求方式：** POST  
**请求URL：** `http://10.34.31.81:9001/api/v1/posts`  
**Content-Type：** `multipart/form-data`

---

## 二、数据流转流程

### 2.1 流程图

```
用户输入表单数据
    ↓
CreatePostViewModel.submitPost()
    ↓
读取图片文件为 ArrayBuffer[]
    ↓
构建 CreatePostParams 对象
    ↓
PostApi.submitImage(params)
    ↓
HttpRequest.post()
    ↓
检测到 CreatePostParams 类型
    ↓
buildMultipartFormData() 构建 multipart 数据
    ↓
发起 HTTP 请求
    ↓
返回响应结果
```

### 2.2 详细步骤

1. **用户界面层**：收集表单数据（标题、描述、图片、标签）
2. **ViewModel层**：验证数据、读取图片文件为 ArrayBuffer
3. **API层**：调用 `submitImage` 方法
4. **HttpRequest层**：
   - 检测请求参数类型
   - 将 CreatePostParams 转换为 `http.MultiFormData[]`
   - 设置 `multipart/form-data` 请求头
   - 发起请求

---

## 三、参数类型定义

### 3.1 CreatePostParams（请求参数）

```typescript
export interface CreatePostParams {
  title: string;              // 必填：帖子标题
  description?: string;        // 可选：帖子描述
  imageFiles: ArrayBuffer[];   // 必填：图片文件数组（ArrayBuffer格式）
  tags?: string[];             // 可选：标签数组
}
```

**字段说明：**

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| `title` | `string` | ✅ | 帖子标题 |
| `description` | `string` | ❌ | 帖子描述 |
| `imageFiles` | `ArrayBuffer[]` | ✅ | 图片文件数组，至少包含一张图片 |
| `tags` | `string[]` | ❌ | 标签数组 |

### 3.2 SubmitImageResponse（响应数据）

```typescript
export interface SubmitImageResponse {
  success: boolean;
  message: string;
  data: SubmitImageData;
  timestamp: number;
}

export interface SubmitImageData {
  post: PostEntity;
}

export interface PostEntity {
  id: number;
  post_id: string;
  user_id: number;
  title: string;
  description: string | null;
  image_count: number;
  like_count: number;
  favorite_count: number;
  view_count: number;
  share_count: number;
  comment_count: number;
  status: "APPROVED" | "PENDING" | "REJECTED";
  create_time: string;
  update_time: string;
  images: ImageEntity[];
  tags: string[];
}
```

---

## 四、核心代码实现

### 4.1 ViewModel层：提交帖子

**文件：** `entry/src/main/ets/viewmodels/CreatePostViewModel.ets`

```typescript
async submitPost(): Promise<void> {
  if (!this.validate() || this.isSubmitting) return;

  this.isSubmitting = true;
  const imageFiles: ArrayBuffer[] = [];

  for (let i = 0; i < this.selectedImages.length; i++) {
    const imageUri = this.selectedImages[i];
    const file = fileIo.openSync(imageUri, fileIo.OpenMode.READ_ONLY);
    const stat: fileIo.Stat = fileIo.statSync(file.fd);
    const buffer = new ArrayBuffer(stat.size);
    fileIo.readSync(file.fd, buffer);
    fileIo.closeSync(file);
    imageFiles.push(buffer);
  }

  const params: CreatePostParams = {
    title: this.title,
    description: this.description || undefined,
    imageFiles: imageFiles,
    tags: this.tags.length > 0 ? this.tags : undefined
  };

  const response = await submitImage(params);

  if (response.success && response.data) {
    this.showSuccess('发布成功');
    router.back();
  } else {
    this.showError(response.message || '发布失败');
  }

  this.isSubmitting = false;
}
```

**关键点：**
- 使用 `fileIo` 同步读取图片文件为 ArrayBuffer
- 构建符合 `CreatePostParams` 类型的参数对象

---

### 4.2 API层：调用接口

**文件：** `entry/src/main/ets/services/api/PostApi.ets`

```typescript
export const submitImage = async (
  param: CreatePostParams
): Promise<ApiResponse<SubmitImageResponse>> => {
  return httpRequest.post<SubmitImageResponse, CreatePostParams>(
    'http://10.34.31.81:9001/api/v1/posts',
    param
  )
}
```

---

### 4.3 HttpRequest层：构建 multipart/form-data

**文件：** `entry/src/main/ets/services/api/HttpRequest.ets`

#### 4.3.1 检测请求类型

```typescript
private checkIsCreatePostParams(data: RequestData | undefined): boolean {
  if (!data || typeof data !== 'object') {
    return false;
  }
  const obj = data as CreatePostParams;
  return typeof obj.title === 'string' && Array.isArray(obj.imageFiles);
}
```

#### 4.3.2 构建 MultiFormData

```typescript
private buildMultipartFormData(data: CreatePostParams): http.MultiFormData[] {
  const formData: http.MultiFormData[] = [];

  if (data.title) {
    formData.push({
      name: 'title',
      contentType: 'text/plain',
      data: new util.TextEncoder().encode(data.title).buffer
    });
  }

  if (data.description) {
    formData.push({
      name: 'description',
      contentType: 'text/plain',
      data: new util.TextEncoder().encode(data.description).buffer
    });
  }

  if (data.tags && data.tags.length > 0) {
    formData.push({
      name: 'tags',
      contentType: 'text/plain',
      data: new util.TextEncoder().encode(JSON.stringify(data.tags)).buffer
    });
  }

  if (data.imageFiles && data.imageFiles.length > 0) {
    data.imageFiles.forEach((buffer: ArrayBuffer, index: number) => {
      const fileName = `image_${index}.jpg`;
      formData.push({
        name: 'imageFiles',
        contentType: 'image/jpeg',
        remoteFileName: fileName,
        data: buffer
      });
    });
  }

  return formData;
}
```

**关键点：**
- 文本字段使用 `util.TextEncoder().encode().buffer` 转换为 ArrayBuffer
- tags 字段使用 `JSON.stringify()` 转换为字符串后再编码
- 图片字段直接使用 ArrayBuffer，设置 `remoteFileName`
- 所有图片使用相同的 `name: 'imageFiles'`，后端接收为数组

#### 4.3.3 发起请求

```typescript
if (isCreatePost) {
  const postData = data as CreatePostParams;
  const multipartData = this.buildMultipartFormData(postData);
  const headers: Record<string, string> = {
    'Content-Type': 'multipart/form-data',
    'Accept': 'application/json'
  };
  if (this.authToken) {
    headers['Authorization'] = `Bearer ${this.authToken}`;
  }
  
  options = {
    method,
    header: headers,
    readTimeout: ApiConstants.TIMEOUT,
    connectTimeout: ApiConstants.TIMEOUT,
    multiFormDataList: multipartData,
  };
}

const response = await this.httpRequest.request(fullUrl, options);
```

---

## 五、MultiFormData 字段结构

### 5.1 文本字段

```typescript
{
  name: string;           // 字段名
  contentType: string;    // 'text/plain'
  data: ArrayBuffer;      // 文本内容转换后的 ArrayBuffer
}
```

### 5.2 文件字段

```typescript
{
  name: string;           // 字段名（多个文件使用相同name）
  contentType: string;    // 'image/jpeg'
  remoteFileName: string; // 文件名
  data: ArrayBuffer;      // 文件内容的 ArrayBuffer
}
```

---

## 六、关键技术点

### 6.1 文本字段编码

HarmonyOS 的 `http.MultiFormData` 要求所有字段的 `data` 属性都必须是 `ArrayBuffer` 类型。

**错误示例：**
```typescript
data: data.title  // ❌ 直接传 string 不符合接口要求
```

**正确做法：**
```typescript
import util from '@ohos.util';

data: new util.TextEncoder().encode(data.title).buffer  // ✅ 转换为 ArrayBuffer
```

### 6.2 请求头设置

必须显式设置 `Content-Type: multipart/form-data`：

```typescript
const headers: Record<string, string> = {
  'Content-Type': 'multipart/form-data',
  'Accept': 'application/json'
};
```

### 6.3 图片文件读取

使用 `@kit.CoreFileKit` 的 `fileIo` 模块：

```typescript
import { fileIo } from '@kit.CoreFileKit';

const file = fileIo.openSync(imageUri, fileIo.OpenMode.READ_ONLY);
const stat: fileIo.Stat = fileIo.statSync(file.fd);
const buffer = new ArrayBuffer(stat.size);
fileIo.readSync(file.fd, buffer);
fileIo.closeSync(file);
```

---

## 七、请求示例

### 7.1 完整的 multipart/form-data 结构

```
POST http://10.34.31.81:9001/api/v1/posts
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary
Authorization: Bearer eyJhbGciOiJIUzI1NiJ9...

------WebKitFormBoundary
Content-Disposition: form-data; name="title"
Content-Type: text/plain

我的帖子标题
------WebKitFormBoundary
Content-Disposition: form-data; name="description"
Content-Type: text/plain

这是帖子描述
------WebKitFormBoundary
Content-Disposition: form-data; name="tags"
Content-Type: text/plain

["风景","旅行"]
------WebKitFormBoundary
Content-Disposition: form-data; name="imageFiles"; filename="image_0.jpg"
Content-Type: image/jpeg

[binary data]
------WebKitFormBoundary
Content-Disposition: form-data; name="imageFiles"; filename="image_1.jpg"
Content-Type: image/jpeg

[binary data]
------WebKitFormBoundary--
```

---

## 八、常见问题

### Q1: 后端接收不到 title 参数？

**原因：** 文本字段的 `data` 直接传了 string，而不是 ArrayBuffer。

**解决：** 使用 `util.TextEncoder().encode().buffer` 转换。

### Q2: 请求发送的是 JSON 格式？

**原因：** 请求头未设置 `Content-Type: multipart/form-data`。

**解决：** 显式设置请求头。

### Q3: 图片上传失败？

**原因：** 
- 图片 ArrayBuffer 读取不完整
- 文件路径错误
- contentType 设置错误

**解决：** 
- 确保使用 `fileIo.statSync()` 获取正确文件大小
- 检查图片 URI 路径
- 根据实际图片格式设置 contentType

---

## 九、依赖模块

```typescript
import http from '@ohos.net.http';        // HTTP 请求
import util from '@ohos.util';            // TextEncoder
import { fileIo } from '@kit.CoreFileKit'; // 文件读取
import { router } from '@kit.ArkUI';       // 页面路由
import promptAction from '@ohos.promptAction'; // Toast 提示
```

---

## 十、总结

创建帖子请求的核心要点：

1. **参数类型识别**：通过 `checkIsCreatePostParams` 判断是否为创建帖子请求
2. **文本字段编码**：使用 `util.TextEncoder` 将字符串转换为 ArrayBuffer
3. **请求头设置**：必须设置 `Content-Type: multipart/form-data`
4. **MultiFormData 构建**：统一使用 ArrayBuffer 作为 data 类型
5. **文件读取**：使用 `fileIo` 同步读取图片为 ArrayBuffer
6. **数组字段处理**：多个文件使用相同的 name，后端自动解析为数组

