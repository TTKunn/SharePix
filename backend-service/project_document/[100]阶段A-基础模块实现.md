# [007] 阶段A - 基础模块代码实现详解

**创建时间**: 2025-10-01
**文档类型**: 技术详解
**目标读者**: 开发人员
**覆盖范围**: 阶段A（项目骨架）的所有基础模块

---

## 📋 文档说明

本文档详细讲解**阶段A（项目骨架搭建）**中实现的所有基础模块代码。

**已实现模块**:
- ✅ 配置管理 (ConfigManager)
- ✅ 日志系统 (Logger)
- ✅ 用户模型 (User)
- ✅ 数据库连接池 (DatabaseConnectionPool)
- ✅ HTTP 服务器 (HttpServer)
- ✅ 主程序 (main.cpp)

**后续阶段**:
- 🔜 阶段B: 认证核心模块（password_hasher, jwt_manager, auth_service, user_repository）
- 🔜 阶段C: API 接口模块（auth_handler, json_response, validator）

---

## 📚 目录

1. [配置管理模块 (ConfigManager)](#1-配置管理模块)
2. [日志系统模块 (Logger)](#2-日志系统模块)
3. [用户模型 (User)](#3-用户模型)
4. [数据库连接池 (DatabaseConnectionPool)](#4-数据库连接池)
5. [HTTP 服务器 (HttpServer)](#5-http-服务器)
6. [主程序 (main.cpp)](#6-主程序)
7. [项目架构总结](#项目架构总结)

---

## 1. 配置管理模块

### 📁 文件位置
- `src/utils/config_manager.h` - 头文件
- `src/utils/config_manager.cpp` - 实现文件

### 🎯 作用
负责从 `config/config.json` 加载和管理应用程序的所有配置信息。

### 🔑 核心设计

#### 1.1 单例模式 (Meyer's Singleton)
```cpp
static ConfigManager& getInstance() {
    static ConfigManager instance;  // C++11 保证线程安全
    return instance;
}
```

**为什么使用单例？**
- 全局唯一的配置管理器
- 避免重复加载配置文件
- 线程安全（C++11 标准保证）

#### 1.2 配置加载流程
```cpp
bool loadConfig(const std::string& configPath) {
    // 1. 打开配置文件
    std::ifstream configFile(configPath);
    
    // 2. 使用 JsonCpp 解析
    Json::CharReaderBuilder builder;
    Json::parseFromStream(builder, configFile, &config_, &errs);
    
    // 3. 保存配置路径
    configPath_ = configPath;
}
```

#### 1.3 点分路径访问
```cpp
// 支持嵌套访问：config.get<int>("database.port")
const Json::Value* findValue(const std::string& keyPath) {
    // 1. 按 '.' 分割路径
    std::vector<std::string> keys;
    std::stringstream ss(keyPath);
    std::string key;
    while (std::getline(ss, key, '.')) {
        keys.push_back(key);
    }
    
    // 2. 逐层导航 JSON 树
    const Json::Value* current = &config_;
    for (const auto& k : keys) {
        if (!current->isObject() || !current->isMember(k)) {
            return nullptr;  // 路径不存在
        }
        current = &(*current)[k];
    }
    
    return current;
}
```

#### 1.4 模板方法 + 特化
```cpp
// 模板声明
template<typename T>
T get(const std::string& keyPath, const T& defaultValue = T{}) const;

// 特化实现（支持 string, int, bool, double）
template<>
std::string ConfigManager::get<std::string>(
    const std::string& keyPath, 
    const std::string& defaultValue) const {
    const Json::Value* value = findValue(keyPath);
    if (value && value->isString()) {
        return value->asString();
    }
    return defaultValue;  // 找不到或类型不匹配返回默认值
}
```

### 💡 使用示例
```cpp
auto& config = ConfigManager::getInstance();
config.loadConfig("config/config.json");

// 获取配置
std::string host = config.get<std::string>("database.host", "localhost");
int port = config.get<int>("database.port", 3306);
bool enableCors = config.get<bool>("api.enable_cors", true);

// 检查配置是否存在
if (config.has("jwt.secret")) {
    // ...
}
```

### ⚠️ 注意事项
- 配置文件必须是有效的 JSON 格式
- 类型不匹配时返回默认值
- 线程安全（const 方法）

---

## 2. 日志系统模块

### 📁 文件位置
- `src/utils/logger.h` - 头文件
- `src/utils/logger.cpp` - 实现文件

### 🎯 作用
封装 spdlog 库，提供统一的日志接口，支持文件和控制台双输出。

### 🔑 核心设计

#### 2.1 日志级别
```cpp
enum class LogLevel {
    DEBUG = 0,    // 调试信息
    INFO = 1,     // 一般信息
    WARNING = 2,  // 警告
    ERROR = 3,    // 错误
    FATAL = 4     // 致命错误
};
```

#### 2.2 初始化流程
```cpp
bool Logger::initialize(const std::string& logFile, 
                       LogLevel level,
                       bool consoleOutput) {
    std::lock_guard<std::mutex> lock(logMutex_);  // 线程安全
    
    std::vector<spdlog::sink_ptr> sinks;
    
    // 1. 控制台输出 (带颜色)
    if (consoleOutput) {
        auto console_sink = std::make_shared<spdlog::sinks::stdout_color_sink_mt>();
        sinks.push_back(console_sink);
    }
    
    // 2. 文件输出 (轮转)
    if (!logFile.empty()) {
        // 自动创建日志目录
        createLogDirectory(logFile);
        
        // 10MB 文件大小，保留 5 个文件
        auto file_sink = std::make_shared<spdlog::sinks::rotating_file_sink_mt>(
            logFile, 1024 * 1024 * 10, 5);
        sinks.push_back(file_sink);
    }
    
    // 3. 创建 logger
    auto logger = std::make_shared<spdlog::logger>("shared_parking", 
                                                   sinks.begin(), 
                                                   sinks.end());
    
    // 4. 设置日志格式
    logger->set_pattern("[%Y-%m-%d %H:%M:%S.%e] [%^%l%$] [thread %t] %v");
    //                   时间戳              级别    线程ID   消息
    
    // 5. 注册为默认 logger
    spdlog::set_default_logger(logger);
}
```

#### 2.3 自动创建日志目录
```cpp
// 如果日志目录不存在，自动创建
if (!logFile.empty()) {
    char* logFilePathCopy = strdup(logFileCopy.c_str());
    char* logDir = dirname(logFilePathCopy);  // 获取目录路径
    
    struct stat st;
    if (stat(logDir, &st) != 0) {
        // 目录不存在，递归创建
        std::string mkdirCmd = "mkdir -p " + std::string(logDir);
        system(mkdirCmd.c_str());
    }
    free(logFilePathCopy);
}
```

#### 2.4 日志输出方法
```cpp
// 静态方法，全局可用
void Logger::info(const std::string& message) {
    if (currentLevel_ <= LogLevel::INFO) {
        spdlog::info(message);
    }
}

void Logger::error(const std::string& message) {
    if (currentLevel_ <= LogLevel::ERROR) {
        spdlog::error(message);
    }
}
```

### 💡 使用示例
```cpp
// 初始化
Logger::initialize("logs/app.log", LogLevel::INFO, true);

// 使用
Logger::info("Server started successfully");
Logger::warning("Connection pool size is low");
Logger::error("Failed to connect to database: " + errorMsg);
Logger::debug("User data: " + userData);  // 只在 DEBUG 级别输出
```

### 📊 日志格式示例
```
[2025-10-01 15:30:59.122] [info] [thread 113673] Configuration loaded successfully
[2025-10-01 15:30:59.155] [error] [thread 113673] Failed to connect to database
```

### ⚠️ 注意事项
- 线程安全（使用 mutex 保护）
- 日志轮转自动管理（10MB 一个文件）
- ERROR 级别自动刷新到磁盘

---

## 3. 用户模型

### 📁 文件位置
- `src/models/user.h` - 头文件
- `src/models/user.cpp` - 实现文件

### 🎯 作用
表示系统中的用户实体，提供 JSON 序列化/反序列化和验证功能。

### 🔑 核心设计

#### 3.1 用户状态枚举
```cpp
enum class UserStatus {
    ACTIVE,      // 活跃用户
    INACTIVE,    // 未激活
    SUSPENDED    // 已暂停
};
```

#### 3.2 用户属性
```cpp
class User {
private:
    int id_;                    // 用户ID
    std::string username_;      // 用户名
    std::string email_;         // 邮箱
    std::string passwordHash_;  // 密码哈希
    std::string salt_;          // 盐值
    UserStatus status_;         // 状态
    std::time_t createdAt_;     // 创建时间
    std::time_t updatedAt_;     // 更新时间
    std::time_t lastLoginAt_;   // 最后登录时间
};
```

#### 3.3 JSON 序列化
```cpp
Json::Value User::toJson(bool includeSecrets) const {
    Json::Value json;
    
    // 基本信息
    json["id"] = id_;
    json["username"] = username_;
    json["email"] = email_;
    
    // 状态转换
    switch (status_) {
        case UserStatus::ACTIVE:
            json["status"] = "active";
            break;
        case UserStatus::INACTIVE:
            json["status"] = "inactive";
            break;
        case UserStatus::SUSPENDED:
            json["status"] = "suspended";
            break;
    }
    
    // 时间戳
    json["created_at"] = static_cast<Json::Int64>(createdAt_);
    json["updated_at"] = static_cast<Json::Int64>(updatedAt_);
    
    // 可选：最后登录时间
    if (lastLoginAt_ > 0) {
        json["last_login_at"] = static_cast<Json::Int64>(lastLoginAt_);
    } else {
        json["last_login_at"] = Json::Value::null;
    }
    
    // 敏感信息（仅内部使用）
    if (includeSecrets) {
        json["password_hash"] = passwordHash_;
        json["salt"] = salt_;
    }
    
    return json;
}
```

#### 3.4 JSON 反序列化
```cpp
User User::fromJson(const Json::Value& j) {
    User user;
    
    // 安全地提取每个字段
    if (j.isMember("id") && j["id"].isInt()) {
        user.id_ = j["id"].asInt();
    }
    
    if (j.isMember("username") && j["username"].isString()) {
        user.username_ = j["username"].asString();
    }
    
    // 状态转换
    if (j.isMember("status") && j["status"].isString()) {
        std::string status = j["status"].asString();
        if (status == "active") {
            user.status_ = UserStatus::ACTIVE;
        } else if (status == "inactive") {
            user.status_ = UserStatus::INACTIVE;
        } else if (status == "suspended") {
            user.status_ = UserStatus::SUSPENDED;
        }
    }
    
    return user;
}
```

#### 3.5 数据验证
```cpp
std::string User::validate() const {
    // 用户名验证
    if (username_.empty()) {
        return "Username cannot be empty";
    }
    
    if (username_.length() < 3 || username_.length() > 50) {
        return "Username must be 3-50 characters";
    }
    
    // 只允许字母、数字、下划线
    std::regex usernameRegex("^[a-zA-Z0-9_]+$");
    if (!std::regex_match(username_, usernameRegex)) {
        return "Username can only contain letters, numbers, and underscores";
    }
    
    // 邮箱验证
    if (email_.empty()) {
        return "Email cannot be empty";
    }
    
    std::regex emailRegex(R"(^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$)");
    if (!std::regex_match(email_, emailRegex)) {
        return "Invalid email format";
    }
    
    if (email_.length() > 100) {
        return "Email cannot exceed 100 characters";
    }
    
    return "";  // 验证通过
}
```

### 💡 使用示例
```cpp
// 创建用户
User user(1, "john_doe", "john@example.com");
user.setPasswordHash("hashed_password");
user.setSalt("random_salt");

// 验证
std::string error = user.validate();
if (!error.empty()) {
    Logger::error("Validation failed: " + error);
}

// 转换为 JSON（不包含敏感信息）
Json::Value json = user.toJson(false);

// 从 JSON 创建用户
User newUser = User::fromJson(json);
```

---


# [007-2] 代码实现详细讲解 - 数据库和HTTP服务器

**创建时间**: 2025-10-01  
**文档类型**: 技术详解（续）  
**前置文档**: [007]代码实现详细讲解.md

---

## 4. 数据库连接池

### 📁 文件位置
- `src/database/connection_pool.h` - 头文件
- `src/database/connection_pool.cpp` - 实现文件

### 🎯 作用
管理 MySQL 数据库连接，提供连接池功能，避免频繁创建/销毁连接。

### 🔑 核心设计

#### 4.1 RAII 连接封装
```cpp
class MySQLConnection {
public:
    explicit MySQLConnection(MYSQL* conn) : connection_(conn) {}
    
    ~MySQLConnection() {
        if (connection_) {
            mysql_close(connection_);  // 自动关闭连接
            connection_ = nullptr;
        }
    }
    
    MYSQL* get() const { return connection_; }
    
    bool isValid() const {
        return connection_ && mysql_ping(connection_) == 0;
    }
    
private:
    MYSQL* connection_;
};
```

**RAII 优势**:
- ✅ 自动资源管理，防止内存泄漏
- ✅ 异常安全
- ✅ 无需手动调用 `mysql_close()`

#### 4.2 连接池架构
```cpp
class DatabaseConnectionPool {
private:
    std::queue<std::unique_ptr<MySQLConnection>> connections_;  // 连接队列
    mutable std::mutex poolMutex_;                              // 互斥锁
    std::condition_variable poolCondition_;                     // 条件变量
    
    std::string host_;
    int port_;
    std::string database_;
    std::string username_;
    std::string password_;
    int poolSize_;          // 连接池大小
    bool initialized_;
};
```

**设计要点**:
- `std::queue`: 先进先出，公平分配连接
- `std::mutex`: 保护共享资源
- `std::condition_variable`: 实现等待/通知机制
- `std::unique_ptr`: 确保连接的唯一所有权

#### 4.3 初始化流程
```cpp
bool DatabaseConnectionPool::initialize() {
    std::lock_guard<std::mutex> lock(poolMutex_);
    
    // 1. 初始化 MySQL 库
    mysql_library_init(0, nullptr, nullptr);
    
    // 2. 从配置加载参数
    auto& config = ConfigManager::getInstance();
    host_ = config.get<std::string>("database.host", "localhost");
    port_ = config.get<int>("database.port", 3306);
    database_ = config.get<std::string>("database.database", "");
    username_ = config.get<std::string>("database.username", "");
    password_ = config.get<std::string>("database.password", "");
    poolSize_ = config.get<int>("database.pool_size", 10);
    
    Logger::info("Initializing database connection pool...");
    Logger::info("Host: " + host_ + ":" + std::to_string(port_));
    Logger::info("Database: " + database_);
    Logger::info("Pool size: " + std::to_string(poolSize_));
    
    // 3. 测试连接
    if (!testConnection()) {
        Logger::error("Failed to connect to database");
        return false;
    }
    
    // 4. 创建连接池
    for (int i = 0; i < poolSize_; ++i) {
        auto conn = createConnection();
        if (conn) {
            connections_.push(std::move(conn));
        } else {
            Logger::error("Failed to create connection " + std::to_string(i + 1));
            return false;
        }
    }
    
    initialized_ = true;
    Logger::info("Database connection pool initialized successfully");
    
    return true;
}
```

#### 4.4 创建连接
```cpp
std::unique_ptr<MySQLConnection> DatabaseConnectionPool::createConnection() {
    MYSQL* mysql = mysql_init(nullptr);
    if (!mysql) {
        Logger::error("Failed to initialize MySQL connection");
        return nullptr;
    }
    
    // 设置连接选项
    unsigned int timeout = connectionTimeout_;
    mysql_options(mysql, MYSQL_OPT_CONNECT_TIMEOUT, &timeout);
    mysql_options(mysql, MYSQL_OPT_READ_TIMEOUT, &timeout);
    mysql_options(mysql, MYSQL_OPT_WRITE_TIMEOUT, &timeout);
    
    // 自动重连（MySQL 8.0 已弃用）
    my_bool reconnect = 1;
    mysql_options(mysql, MYSQL_OPT_RECONNECT, &reconnect);
    
    // 设置字符集
    mysql_options(mysql, MYSQL_SET_CHARSET_NAME, "utf8mb4");
    
    // 连接数据库
    if (!mysql_real_connect(mysql, 
                           host_.c_str(), 
                           username_.c_str(), 
                           password_.c_str(), 
                           database_.c_str(), 
                           port_, 
                           nullptr,  // unix_socket
                           0)) {     // client_flag
        Logger::error("MySQL connection failed: " + std::string(mysql_error(mysql)));
        mysql_close(mysql);
        return nullptr;
    }
    
    return std::make_unique<MySQLConnection>(mysql);
}
```

#### 4.5 获取连接（线程安全）
```cpp
std::unique_ptr<MySQLConnection> DatabaseConnectionPool::getConnection() {
    std::unique_lock<std::mutex> lock(poolMutex_);
    
    // 等待直到有可用连接
    poolCondition_.wait(lock, [this] { 
        return !connections_.empty(); 
    });
    
    // 从队列取出连接
    auto conn = std::move(connections_.front());
    connections_.pop();
    
    // 检查连接是否有效
    if (!conn->isValid()) {
        Logger::warning("Connection is invalid, creating new one");
        lock.unlock();  // 释放锁，避免死锁
        conn = createConnection();
    }
    
    return conn;
}
```

**线程安全分析**:
1. `unique_lock`: 可以手动解锁，比 `lock_guard` 更灵活
2. `condition_variable::wait()`: 原子地释放锁并等待
3. 等待条件: `!connections_.empty()` - 有可用连接

#### 4.6 归还连接
```cpp
void DatabaseConnectionPool::returnConnection(std::unique_ptr<MySQLConnection> conn) {
    if (!conn) {
        return;
    }
    
    std::lock_guard<std::mutex> lock(poolMutex_);
    
    // 检查连接是否有效
    if (conn->isValid()) {
        connections_.push(std::move(conn));
    } else {
        // 无效连接，创建新的
        Logger::warning("Returned connection is invalid, creating new one");
        auto newConn = createConnection();
        if (newConn) {
            connections_.push(std::move(newConn));
        }
    }
    
    // 通知等待的线程
    poolCondition_.notify_one();
}
```

#### 4.7 执行查询
```cpp
// MySQLConnection 类的方法
bool MySQLConnection::execute(const std::string& query) {
    if (!connection_) {
        return false;
    }
    
    int result = mysql_real_query(connection_, query.c_str(), query.length());
    if (result != 0) {
        Logger::error("MySQL query failed: " + std::string(mysql_error(connection_)));
        return false;
    }
    
    return true;
}

MYSQL_RES* MySQLConnection::executeQuery(const std::string& query) {
    if (!execute(query)) {
        return nullptr;
    }
    
    MYSQL_RES* result = mysql_store_result(connection_);
    if (!result && mysql_field_count(connection_) > 0) {
        Logger::error("MySQL store result failed: " + std::string(mysql_error(connection_)));
        return nullptr;
    }
    
    return result;
}
```

#### 4.8 统计信息
```cpp
Json::Value DatabaseConnectionPool::getStats() const {
    std::lock_guard<std::mutex> lock(poolMutex_);
    
    Json::Value stats;
    stats["pool_size"] = poolSize_;
    stats["available_connections"] = static_cast<int>(connections_.size());
    stats["active_connections"] = poolSize_ - static_cast<int>(connections_.size());
    stats["initialized"] = initialized_;
    
    return stats;
}
```

### 💡 使用示例
```cpp
// 初始化连接池
auto& pool = DatabaseConnectionPool::getInstance();
if (!pool.initialize()) {
    Logger::error("Failed to initialize connection pool");
    return 1;
}

// 获取连接
auto conn = pool.getConnection();
if (conn && conn->isValid()) {
    // 执行查询
    MYSQL_RES* result = conn->executeQuery("SELECT * FROM users WHERE id = 1");
    if (result) {
        // 处理结果
        MYSQL_ROW row;
        while ((row = mysql_fetch_row(result))) {
            std::cout << "Username: " << row[1] << std::endl;
        }
        mysql_free_result(result);
    }
    
    // 归还连接
    pool.returnConnection(std::move(conn));
}

// 查看统计
Json::Value stats = pool.getStats();
std::cout << "Available: " << stats["available_connections"].asInt() << std::endl;
std::cout << "Active: " << stats["active_connections"].asInt() << std::endl;
```

### 🔒 线程安全机制

| 机制 | 作用 | 使用场景 |
|------|------|----------|
| `std::mutex` | 保护共享资源 | 访问连接队列时 |
| `std::condition_variable` | 等待/通知 | 连接池为空时等待 |
| `std::unique_ptr` | 唯一所有权 | 确保连接不被复制 |
| `std::lock_guard` | 自动加锁/解锁 | 简单的临界区 |
| `std::unique_lock` | 手动控制锁 | 需要提前解锁的场景 |

### ⚠️ 注意事项
- 连接池大小建议: CPU 核心数 × 2-4
- `MYSQL_OPT_RECONNECT` 在 MySQL 8.0 已弃用
- 使用 `mysql_ping()` 检查连接有效性
- 归还连接时会自动检查并重建无效连接

---

## 5. HTTP 服务器

### 📁 文件位置
- `src/server/http_server.h` - 头文件
- `src/server/http_server.cpp` - 实现文件

### 🎯 作用
基于 cpp-httplib 实现 HTTP 服务器，提供 RESTful API 接口。

### 🔑 核心设计

#### 5.1 服务器架构
```cpp
class HttpServer {
private:
    std::unique_ptr<httplib::Server> server_;  // HTTP 服务器实例
    std::string host_;                         // 监听地址
    int port_;                                 // 监听端口
    bool running_;                             // 运行状态
};
```

#### 5.2 初始化流程
```cpp
bool HttpServer::initialize() {
    try {
        // 1. 加载配置
        auto& config = ConfigManager::getInstance();
        host_ = config.get<std::string>("server.host", "0.0.0.0");
        port_ = config.get<int>("server.port", 8080);
        
        Logger::info("Initializing HTTP server on " + host_ + ":" + std::to_string(port_));
        
        // 2. 设置中间件
        setupMiddleware();
        
        // 3. 设置 CORS
        setupCORS();
        
        // 4. 设置路由
        setupRoutes();
        
        // 5. 设置错误处理
        setupErrorHandlers();
        
        Logger::info("HTTP server initialized successfully");
        return true;
        
    } catch (const std::exception& e) {
        Logger::error("Failed to initialize HTTP server: " + std::string(e.what()));
        return false;
    }
}
```

#### 5.3 中间件：请求日志
```cpp
void HttpServer::setupMiddleware() {
    // 前置路由处理器（请求日志）
    server_->set_pre_routing_handler([](const httplib::Request& req, 
                                        httplib::Response& res) {
        Logger::info("Request: " + req.method + " " + req.path);
        return httplib::Server::HandlerResponse::Unhandled;
    });
}
```

**工作原理**:
- 在路由匹配前执行
- 记录所有请求
- 返回 `Unhandled` 继续处理

#### 5.4 CORS 支持
```cpp
void HttpServer::setupCORS() {
    // 后置路由处理器（CORS 头）
    server_->set_post_routing_handler([](const httplib::Request& req, 
                                         httplib::Response& res) {
        res.set_header("Access-Control-Allow-Origin", "*");
        res.set_header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
        res.set_header("Access-Control-Allow-Headers", "Content-Type, Authorization");
    });
}
```

**CORS 头说明**:
- `Access-Control-Allow-Origin`: 允许的来源（`*` = 所有）
- `Access-Control-Allow-Methods`: 允许的 HTTP 方法
- `Access-Control-Allow-Headers`: 允许的请求头

⚠️ **生产环境建议**: 将 `*` 改为具体的域名列表

#### 5.5 路由设置
```cpp
void HttpServer::setupRoutes() {
    // 健康检查
    server_->Get("/health", [this](const httplib::Request& req, 
                                   httplib::Response& res) {
        handleHealthCheck(req, res);
    });
    
    // 指标查询
    server_->Get("/metrics", [this](const httplib::Request& req, 
                                    httplib::Response& res) {
        handleMetrics(req, res);
    });
    
    // API 版本
    server_->Get("/api/v1/version", [](const httplib::Request& req, 
                                       httplib::Response& res) {
        Json::Value response;
        response["version"] = "1.0.0";
        response["service"] = "Shared Parking Authentication Service";
        response["timestamp"] = static_cast<Json::Int64>(std::time(nullptr));
        
        Json::StreamWriterBuilder writer;
        std::string jsonStr = Json::writeString(writer, response);
        
        res.set_content(jsonStr, "application/json");
        res.status = 200;
    });
}
```

**Lambda 表达式说明**:
- `[this]`: 捕获 `this` 指针，可以调用成员方法
- `[]`: 不捕获任何变量
- `const httplib::Request& req`: 请求对象
- `httplib::Response& res`: 响应对象

#### 5.6 健康检查端点
```cpp
void HttpServer::handleHealthCheck(const httplib::Request& req, 
                                   httplib::Response& res) {
    Json::Value response;
    response["status"] = "healthy";
    response["service"] = "Shared Parking Authentication Service";
    response["timestamp"] = static_cast<Json::Int64>(std::time(nullptr));
    
    // 检查数据库连接
    auto& dbPool = DatabaseConnectionPool::getInstance();
    auto conn = dbPool.getConnection();
    
    if (conn && conn->isValid()) {
        response["database"] = "connected";
        dbPool.returnConnection(std::move(conn));
    } else {
        response["database"] = "disconnected";
        response["status"] = "unhealthy";
    }
    
    Json::StreamWriterBuilder writer;
    std::string jsonStr = Json::writeString(writer, response);
    
    res.set_content(jsonStr, "application/json");
    res.status = (response["status"].asString() == "healthy") ? 200 : 503;
}
```

**响应示例**:
```json
{
  "status": "healthy",
  "service": "Shared Parking Authentication Service",
  "database": "connected",
  "timestamp": 1759303899
}
```

#### 5.7 指标端点
```cpp
void HttpServer::handleMetrics(const httplib::Request& req, 
                               httplib::Response& res) {
    Json::Value response;
    
    // 服务器指标
    Json::Value serverMetrics;
    serverMetrics["running"] = running_;
    serverMetrics["host"] = host_;
    serverMetrics["port"] = port_;
    response["server"] = serverMetrics;
    
    // 数据库指标
    auto& dbPool = DatabaseConnectionPool::getInstance();
    response["database"] = dbPool.getStats();
    
    // 时间戳
    response["timestamp"] = static_cast<Json::Int64>(std::time(nullptr));
    
    Json::StreamWriterBuilder writer;
    std::string jsonStr = Json::writeString(writer, response);
    
    res.set_content(jsonStr, "application/json");
    res.status = 200;
}
```

**响应示例**:
```json
{
  "server": {
    "running": true,
    "host": "0.0.0.0",
    "port": 8080
  },
  "database": {
    "pool_size": 10,
    "available_connections": 10,
    "active_connections": 0,
    "initialized": true
  },
  "timestamp": 1759303910
}
```

#### 5.8 错误处理
```cpp
void HttpServer::setupErrorHandlers() {
    // 404 Not Found
    server_->set_error_handler([](const httplib::Request& req, 
                                  httplib::Response& res) {
        Json::Value error;
        error["success"] = false;
        error["error"] = "Not Found";
        error["message"] = "The requested endpoint does not exist";
        error["path"] = req.path;
        error["timestamp"] = static_cast<Json::Int64>(std::time(nullptr));
        
        Json::StreamWriterBuilder writer;
        std::string jsonStr = Json::writeString(writer, error);
        
        res.set_content(jsonStr, "application/json");
    });
    
    // 异常处理
    server_->set_exception_handler([](const httplib::Request& req, 
                                      httplib::Response& res, 
                                      std::exception_ptr ep) {
        try {
            std::rethrow_exception(ep);
        } catch (const std::exception& e) {
            Logger::error("Exception in request handler: " + std::string(e.what()));
            
            Json::Value error;
            error["success"] = false;
            error["error"] = "Internal Server Error";
            error["message"] = "An unexpected error occurred";
            error["timestamp"] = static_cast<Json::Int64>(std::time(nullptr));
            
            Json::StreamWriterBuilder writer;
            std::string jsonStr = Json::writeString(writer, error);
            
            res.set_content(jsonStr, "application/json");
            res.status = 500;
        }
    });
}
```

### 📡 API 端点总结

| 端点 | 方法 | 描述 | 状态码 |
|------|------|------|--------|
| `/health` | GET | 健康检查 | 200/503 |
| `/metrics` | GET | 服务器指标 | 200 |
| `/api/v1/version` | GET | API 版本 | 200 |
| 其他 | ANY | 404 错误 | 404 |

### 💡 使用示例
```bash
# 健康检查
curl http://localhost:8080/health

# 查看指标
curl http://localhost:8080/metrics

# API 版本
curl http://localhost:8080/api/v1/version

# 404 测试
curl http://localhost:8080/nonexistent
```

### ⚠️ 注意事项
- `server->listen()` 是**阻塞调用**，会阻塞当前线程
- CORS 设置允许所有来源（生产环境需限制）
- 所有错误响应都是统一的 JSON 格式
- 异常会被捕获并返回 500 错误

---

## 📚 总结

本文档详细讲解了：
1. **数据库连接池**: RAII、线程安全、连接管理
2. **HTTP 服务器**: 路由、中间件、CORS、错误处理

**下一步**: 查看 [007-3]代码实现详细讲解-主程序.md 了解主程序的实现。

# [007-3] 代码实现详细讲解 - 主程序和总结

**创建时间**: 2025-10-01  
**文档类型**: 技术详解（完结篇）  
**前置文档**: [007]代码实现详细讲解.md, [007-2]代码实现详细讲解-数据库和HTTP服务器.md

---

## 6. 主程序 (main.cpp)

### 📁 文件位置
- `src/main.cpp` - 主程序入口

### 🎯 作用
应用程序的入口点，负责初始化所有模块并启动服务器。

### 🔑 核心设计

#### 6.1 程序启动流程
```
1. 打印 Banner
2. 设置信号处理器
3. 加载配置文件
4. 初始化日志系统
5. 初始化数据库连接池
6. 创建 HTTP 服务器
7. 启动服务器（阻塞）
```

#### 6.2 Banner 显示
```cpp
void printBanner() {
    std::cout << R"(
    ____  __                      __   ____             __   _            
   / ___\/ /_  ____ _________  ___/ /  / __ \____ ______/ /__(_)___  ____ _
   \__ \/ __ \/ __ `/ ___/ _ \/ __  /  / /_/ / __ `/ ___/ //_/ / __ \/ __ `/
  ___/ / / / / /_/ / /  /  __/ /_/ /  / ____/ /_/ / /  / ,< / / / / / /_/ / 
 /____/_/ /_/\__,_/_/   \___/\__,_/  /_/    \__,_/_/  /_/|_/_/_/ /_/\__, /  
                                                                   /____/   
 Authentication Service v1.0.0
 )" << std::endl;
}
```

**作用**: 美化启动界面，显示应用名称和版本

#### 6.3 信号处理器
```cpp
// 全局服务器实例（用于信号处理）
std::unique_ptr<HttpServer> g_server;

void signalHandler(int signal) {
    Logger::info("Received signal " + std::to_string(signal) + 
                 ", shutting down gracefully...");
    
    if (g_server) {
        g_server->stop();
    }
    
    Logger::info("Server stopped successfully");
    exit(0);
}

void setupSignalHandlers() {
    signal(SIGINT, signalHandler);   // Ctrl+C
    signal(SIGTERM, signalHandler);  // kill 命令
    signal(SIGQUIT, signalHandler);  // Ctrl+\
}
```

**优雅关闭流程**:
1. 接收信号（SIGINT, SIGTERM, SIGQUIT）
2. 记录日志
3. 停止 HTTP 服务器
4. 退出程序

#### 6.4 配置加载
```cpp
// 默认配置文件路径
std::string configPath = "config/config.json";

// 支持命令行参数指定配置文件
if (argc > 1) {
    configPath = argv[1];
}

std::cout << "Loading configuration from: " << configPath << std::endl;

if (!ConfigManager::getInstance().loadConfig(configPath)) {
    std::cerr << "Failed to load configuration file: " << configPath << std::endl;
    return 1;
}
```

**使用方式**:
```bash
# 使用默认配置
./shared_parking_auth

# 指定配置文件
./shared_parking_auth /path/to/custom/config.json
```

#### 6.5 日志系统初始化
```cpp
// 从配置读取日志参数
auto& config = ConfigManager::getInstance();
std::string logFile = config.get<std::string>("logging.file", "logs/app.log");
std::string logLevelStr = config.get<std::string>("logging.level", "info");
bool consoleOutput = config.get<bool>("logging.console_output", true);

// 转换日志级别字符串为枚举
LogLevel logLevel = LogLevel::INFO;
if (logLevelStr == "debug") logLevel = LogLevel::DEBUG;
else if (logLevelStr == "info") logLevel = LogLevel::INFO;
else if (logLevelStr == "warning") logLevel = LogLevel::WARNING;
else if (logLevelStr == "error") logLevel = LogLevel::ERROR;
else if (logLevelStr == "fatal") logLevel = LogLevel::FATAL;

// 初始化 Logger
if (!Logger::initialize(logFile, logLevel, consoleOutput)) {
    std::cerr << "Failed to initialize logger" << std::endl;
    return 1;
}

Logger::info("Configuration loaded successfully");
Logger::info("Initializing authentication service...");
```

**配置示例**:
```json
{
  "logging": {
    "level": "info",
    "file": "logs/auth-service.log",
    "console_output": true
  }
}
```

#### 6.6 数据库连接池初始化
```cpp
Logger::info("Initializing database connection pool...");

auto& dbPool = DatabaseConnectionPool::getInstance();
if (!dbPool.initialize()) {
    Logger::error("Failed to initialize database connection pool");
    return 1;
}

Logger::info("Database connection pool initialized successfully");
```

**初始化内容**:
- 加载数据库配置
- 测试数据库连接
- 创建连接池（默认 10 个连接）

#### 6.7 HTTP 服务器创建和启动
```cpp
Logger::info("Creating HTTP server...");
g_server = std::make_unique<HttpServer>();

// 初始化服务器
if (!g_server->initialize()) {
    Logger::error("Failed to initialize HTTP server");
    return 1;
}

Logger::info("HTTP server initialized successfully");

// 启动服务器（阻塞调用）
Logger::info("Starting HTTP server...");
if (!g_server->start()) {
    Logger::error("Failed to start HTTP server");
    return 1;
}

Logger::info("Authentication service started successfully");
Logger::info("Server is running and ready to accept connections");
```

**注意**: `g_server->start()` 是阻塞调用，会一直运行直到服务器停止

#### 6.8 异常处理
```cpp
int main(int argc, char* argv[]) {
    try {
        // ... 所有初始化代码 ...
        
    } catch (const std::exception& e) {
        Logger::error("Fatal error: " + std::string(e.what()));
        return 1;
    } catch (...) {
        Logger::error("Unknown fatal error occurred");
        return 1;
    }
    
    return 0;
}
```

**异常处理策略**:
- 捕获所有 `std::exception`
- 捕获未知异常 (`...`)
- 记录错误日志
- 返回非零退出码

### 📊 完整启动流程图

```
┌─────────────────────────────────────────┐
│         打印 Banner                      │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│      设置信号处理器                      │
│   (SIGINT, SIGTERM, SIGQUIT)            │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│      加载配置文件                        │
│   (config/config.json)                  │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│      初始化日志系统                      │
│   (Logger::initialize)                  │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│    初始化数据库连接池                    │
│   (DatabaseConnectionPool::initialize)  │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│      创建 HTTP 服务器                    │
│   (HttpServer::initialize)              │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│      启动 HTTP 服务器                    │
│   (HttpServer::start) - 阻塞            │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│      服务器运行中...                     │
│   等待请求或信号                         │
└─────────────────────────────────────────┘
```

### 💡 使用示例

#### 启动服务器
```bash
cd /home/kun/projects/shared-parking
./build/shared_parking_auth
```

#### 使用自定义配置
```bash
./build/shared_parking_auth /path/to/config.json
```

#### 优雅停止
```bash
# 方法1: Ctrl+C
^C

# 方法2: 发送 SIGTERM
kill <pid>

# 方法3: 发送 SIGQUIT
kill -QUIT <pid>
```

### 📝 启动日志示例
```
    ____  __                      __   ____             __   _            
   / ___\/ /_  ____ _________  ___/ /  / __ \____ ______/ /__(_)___  ____ _
   \__ \/ __ \/ __ `/ ___/ _ \/ __  /  / /_/ / __ `/ ___/ //_/ / __ \/ __ `/
  ___/ / / / / /_/ / /  /  __/ /_/ /  / ____/ /_/ / /  / ,< / / / / / /_/ / 
 /____/_/ /_/\__,_/_/   \___/\__,_/  /_/    \__,_/_/  /_/|_/_/_/ /_/\__, /  
                                                                   /____/   
 Authentication Service v1.0.0
 
Loading configuration from: config/config.json
[2025-10-01 15:30:59.122] [info] [thread 113673] Configuration loaded successfully
[2025-10-01 15:30:59.123] [info] [thread 113673] Initializing authentication service...
[2025-10-01 15:30:59.123] [info] [thread 113673] Initializing database connection pool...
[2025-10-01 15:30:59.126] [info] [thread 113673] Host: localhost:3306
[2025-10-01 15:30:59.126] [info] [thread 113673] Database: shared_parking
[2025-10-01 15:30:59.126] [info] [thread 113673] Pool size: 10
[2025-10-01 15:30:59.155] [info] [thread 113673] Database connection pool initialized successfully
[2025-10-01 15:30:59.155] [info] [thread 113673] Creating HTTP server...
[2025-10-01 15:30:59.155] [info] [thread 113673] Initializing HTTP server on 0.0.0.0:8080
[2025-10-01 15:30:59.155] [info] [thread 113673] HTTP server initialized successfully
[2025-10-01 15:30:59.155] [info] [thread 113673] Starting HTTP server...
```

### ⚠️ 注意事项
- 配置文件必须存在且格式正确
- 数据库必须可访问
- 端口 8080 必须未被占用
- 日志目录会自动创建

---

## 📚 项目架构总结

### 🏗️ 模块依赖关系

```
┌─────────────────────────────────────────────────────────┐
│                      main.cpp                           │
│                   (程序入口)                             │
└───────┬─────────────────────────────────────────────────┘
        │
        ├──────────────────────────────────────────────────┐
        │                                                  │
        ▼                                                  ▼
┌───────────────────┐                          ┌──────────────────┐
│  ConfigManager    │                          │   HttpServer     │
│  (配置管理)       │                          │  (HTTP服务器)    │
└───────┬───────────┘                          └────────┬─────────┘
        │                                               │
        │                                               │
        ▼                                               ▼
┌───────────────────┐                          ┌──────────────────┐
│     Logger        │◄─────────────────────────│ ConnectionPool   │
│   (日志系统)      │                          │  (数据库连接池)  │
└───────────────────┘                          └────────┬─────────┘
                                                        │
                                                        ▼
                                               ┌──────────────────┐
                                               │      User        │
                                               │   (用户模型)     │
                                               └──────────────────┘
```

### 🎯 设计模式应用

| 模式 | 应用位置 | 作用 |
|------|----------|------|
| **单例模式** | ConfigManager, Logger, DatabaseConnectionPool | 全局唯一实例 |
| **RAII** | MySQLConnection | 自动资源管理 |
| **工厂模式** | DatabaseConnectionPool::createConnection() | 创建连接对象 |
| **模板方法** | ConfigManager::get<T>() | 类型安全的配置访问 |
| **观察者模式** | 信号处理器 | 响应系统信号 |

### 🔒 线程安全保证

| 模块 | 线程安全机制 | 说明 |
|------|--------------|------|
| ConfigManager | Meyer's Singleton + const 方法 | C++11 保证单例线程安全 |
| Logger | std::mutex | 保护日志输出 |
| DatabaseConnectionPool | std::mutex + std::condition_variable | 保护连接队列 |
| HttpServer | cpp-httplib 内部处理 | 多线程请求处理 |

### 📊 性能优化

1. **连接池**: 避免频繁创建/销毁数据库连接
2. **日志轮转**: 防止日志文件过大
3. **RAII**: 自动资源管理，减少内存泄漏
4. **unique_ptr**: 零开销的智能指针

### 🛡️ 错误处理策略

1. **配置加载失败**: 程序退出，返回错误码 1
2. **日志初始化失败**: 程序退出，返回错误码 1
3. **数据库连接失败**: 程序退出，返回错误码 1
4. **HTTP 服务器启动失败**: 程序退出，返回错误码 1
5. **运行时异常**: 捕获并记录日志，优雅关闭

### 📈 可扩展性

#### 当前架构支持的扩展：
- ✅ 添加新的 API 端点（在 HttpServer::setupRoutes()）
- ✅ 添加新的配置项（在 config.json）
- ✅ 添加新的数据模型（参考 User 类）
- ✅ 添加新的中间件（在 HttpServer::setupMiddleware()）

#### 下一阶段将添加：
- 🔜 认证服务 (AuthService)
- 🔜 JWT 管理 (JWTManager)
- 🔜 密码哈希 (PasswordHasher)
- 🔜 用户仓储 (UserRepository)

---

## 🎓 学习要点总结

### 1. C++17 特性应用
- `std::unique_ptr`: 智能指针
- `enum class`: 强类型枚举
- `std::string_view`: 字符串视图（JsonCpp 1.9.7）
- Lambda 表达式: HTTP 路由处理
- RAII: 资源管理

### 2. 第三方库使用
- **JsonCpp**: JSON 解析和生成
- **spdlog**: 高性能日志库
- **cpp-httplib**: HTTP 服务器
- **MySQL C API**: 数据库访问

### 3. 并发编程
- `std::mutex`: 互斥锁
- `std::condition_variable`: 条件变量
- `std::lock_guard`: 自动锁管理
- `std::unique_lock`: 灵活锁管理

### 4. 软件工程实践
- 模块化设计
- 单一职责原则
- 依赖注入
- 配置外部化
- 日志记录
- 错误处理

---

## 📖 阅读建议

本文档按照模块的依赖关系组织，建议按顺序阅读：
1. **配置管理** → 2. **日志系统** → 3. **用户模型** → 4. **数据库连接池** → 5. **HTTP 服务器** → 6. **主程序** → 7. **架构总结**

---

## 🎯 后续文档

当进入下一阶段开发时，将创建对应的代码讲解文档：

### 阶段B: 认证核心模块
- 📄 `[008]阶段B-认证核心模块代码实现详解.md`
  - password_hasher.cpp - 密码哈希（PBKDF2）
  - jwt_manager.cpp - JWT 令牌管理
  - auth_service.cpp - 认证服务实现
  - user_repository.cpp - 用户数据访问层

### 阶段C: API 接口模块
- 📄 `[009]阶段C-API接口模块代码实现详解.md`
  - auth_handler.cpp - 认证 API 处理器
  - json_response.cpp - 统一响应格式
  - validator.cpp - 输入验证工具

---

**文档完成时间**: 2025-10-01
**作者**: AI Assistant
**版本**: 1.0.0
**覆盖阶段**: 阶段A（项目骨架）

