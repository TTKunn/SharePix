# 用户信息管理功能完善 - 实施计划

**文档编号**: [106]
**创建时间**: 2025-10-09
**版本**: v2.0.0
**状态**: 🚧 进行中

---

## 📋 任务概述

为Knot图片分享系统补充完整的用户信息管理功能，实现5个核心API接口。

### 实施范围

| 序号 | 功能 | API路径 | 方法 | 优先级 | 状态 |
|------|------|---------|------|--------|------|
| 1 | 获取当前用户信息 | `/api/v1/users/profile` | GET | P0 | ✅ 已完成 (v2.1.0) |
| 2 | 修改用户信息 | `/api/v1/users/profile` | PUT | P0 | ✅ 已完成 (v2.1.0) |
| 3 | 获取其他用户公开信息 | `/api/v1/users/:user_id` | GET | P1 | ✅ 已完成 (v2.1.0) |
| 4 | 用户名可用性检查 | `/api/v1/users/check-username` | GET | P1 | ✅ 已完成 (v2.1.0) |
| 5 | **用户头像上传** | `/api/v1/users/avatar` | POST | P0 | ⏳ 待实施 (v2.5.0) |

**总工作量**: 
- v2.1.0 已完成: 9-12小时
- v2.5.0 头像上传: 4-6小时

---

## 📝 详细任务列表

### 阶段1：数据库变更（30分钟）

- [x] **任务1.1**: 备份当前数据库 ✅
  - 执行: `mysqldump -u root -p knot_image_sharing > backup_$(date +%Y%m%d_%H%M%S).sql`
  - 验证: 检查备份文件是否生成

- [x] **任务1.2**: 添加新字段到users表 ✅
  - 执行SQL:
    ```sql
    ALTER TABLE users ADD COLUMN bio VARCHAR(500) NULL COMMENT '个人简介' AFTER avatar_url;
    ALTER TABLE users ADD COLUMN gender ENUM('male', 'female', 'other', 'prefer_not_to_say') NULL COMMENT '性别' AFTER bio;
    ALTER TABLE users ADD COLUMN location VARCHAR(100) NULL COMMENT '所在地' AFTER gender;
    ```
  - 验证: `DESC users;` 检查字段是否添加成功

---

### 阶段2：Model层（1小时）

- [x] **任务2.1**: 修改 `src/models/user.h` ✅
  - 添加私有成员变量: `bio_`, `gender_`, `location_` ✅
  - 添加getter方法: `getBio()`, `getGender()`, `getLocation()` ✅
  - 添加setter方法: `setBio()`, `setGender()`, `setLocation()` ✅

- [x] **任务2.2**: 修改 `src/models/user.cpp` ✅
  - 更新构造函数，初始化新字段 ✅
  - 更新 `toJson()` 方法，包含新字段 ✅
  - 更新 `fromJson()` 方法，解析新字段 ✅
  - 更新 `validate()` 方法，验证新字段 ✅

- [x] **任务2.3**: 编译测试 ✅
  - 执行: `cd build && make` ✅
  - 验证: 编译无错误 ✅

---

### 阶段3：Repository层（2-3小时）

- [x] **任务3.1**: 修改 `src/database/user_repository.h` ✅
  - 添加方法声明: `updateUserProfile()` ✅
  - 添加方法声明: `emailExistsForOtherUser()` ✅
  - 添加方法声明: `phoneExistsForOtherUser()` ✅

- [x] **任务3.2**: 实现 `src/database/user_repository.cpp` - `updateUserProfile()` ✅
  - 使用ConnectionGuard获取连接
  - 准备SQL: `UPDATE users SET real_name=?, email=?, avatar_url=?, phone=?, bio=?, gender=?, location=?, update_time=CURRENT_TIMESTAMP WHERE id=?`
  - 使用MYSQL_BIND绑定参数
  - 执行更新
  - 添加详细的中文注释
  - 添加错误处理和日志

- [x] **任务3.3**: 实现 `src/database/user_repository.cpp` - `emailExistsForOtherUser()` ✅
  - 使用ConnectionGuard获取连接 ✅
  - 准备SQL: `SELECT COUNT(*) FROM users WHERE email=? AND id!=?` ✅
  - 执行查询并返回结果 ✅
  - 添加详细的中文注释 ✅

- [x] **任务3.4**: 实现 `src/database/user_repository.cpp` - `phoneExistsForOtherUser()` ✅
  - 使用ConnectionGuard获取连接 ✅
  - 准备SQL: `SELECT COUNT(*) FROM users WHERE phone=? AND id!=?` ✅
  - 执行查询并返回结果 ✅
  - 添加详细的中文注释 ✅

- [x] **任务3.5**: 编译测试 ✅
  - 执行: `cd build && make` ✅
  - 验证: 编译无错误 ✅

---

### 阶段4：Service层（2-3小时）

- [x] **任务4.1**: 修改 `src/core/auth_service.h` ✅
  - 添加结构体: `UpdateProfileResult` ✅
  - 添加结构体: `UsernameCheckResult` ✅
  - 添加方法声明: `updateUserProfile()` ✅
  - 添加方法声明: `getUserPublicInfo()` ✅
  - 添加方法声明: `checkUsernameAvailability()` ✅
  - 添加私有方法声明: `validateProfileUpdateInput()` ✅

- [x] **任务4.2**: 实现 `src/core/auth_service.cpp` - `validateProfileUpdateInput()` ✅
  - 验证real_name: 非空，不超过50字符
  - 验证email: 如果提供，验证邮箱格式
  - 验证phone: 11位中国手机号
  - 验证bio: 不超过500字符
  - 验证gender: male/female/other/prefer_not_to_say
  - 验证location: 不超过100字符
  - 添加详细的中文注释

- [x] **任务4.3**: 实现 `src/core/auth_service.cpp` - `updateUserProfile()` ✅
  - 调用 `validateProfileUpdateInput()` 验证输入 ✅
  - 调用 `userRepository_->findById()` 检查用户是否存在 ✅
  - 如果修改了email，调用 `emailExistsForOtherUser()` 检查唯一性 ✅
  - 如果修改了phone，调用 `phoneExistsForOtherUser()` 检查唯一性 ✅
  - 调用 `userRepository_->updateUserProfile()` 更新 ✅
  - 查询并返回更新后的用户信息 ✅
  - 添加详细的中文注释和日志 ✅

- [x] **任务4.4**: 实现 `src/core/auth_service.cpp` - `getUserPublicInfo()` ✅
  - 调用 `userRepository_->findByUserId()` 查询用户 ✅
  - 返回用户对象（只包含公开信息） ✅
  - 添加详细的中文注释 ✅

- [x] **任务4.5**: 实现 `src/core/auth_service.cpp` - `checkUsernameAvailability()` ✅
  - 验证用户名格式 ✅
  - 调用 `userRepository_->usernameExists()` 检查是否存在 ✅
  - 返回可用性结果 ✅
  - 添加详细的中文注释 ✅

- [x] **任务4.6**: 编译测试 ✅
  - 执行: `cd build && make` ✅
  - 验证: 编译无错误 ✅

---

### 阶段5：Handler层（2小时）

- [x] **任务5.1**: 修改 `src/api/auth_handler.h` ✅
  - 添加方法声明: `handleGetProfile()` ✅
  - 添加方法声明: `handleUpdateProfile()` ✅
  - 添加方法声明: `handleGetUserPublicInfo()` ✅
  - 添加方法声明: `handleCheckUsername()` ✅

- [x] **任务5.2**: 实现 `src/api/auth_handler.cpp` - `handleGetProfile()` ✅
  - 提取JWT token
  - 验证token并获取userId
  - 调用 `userRepository_->findById(userId)`
  - 构造JSON响应
  - 添加详细的中文注释

- [x] **任务5.3**: 实现 `src/api/auth_handler.cpp` - `handleUpdateProfile()` ✅
  - 提取JWT token ✅
  - 验证token并获取userId ✅
  - 解析JSON请求体 ✅
  - 提取字段: real_name, email, avatar_url, phone, bio, gender, location ✅
  - 调用 `authService_->updateUserProfile()` ✅
  - 构造JSON响应 ✅
  - 添加详细的中文注释 ✅

- [x] **任务5.4**: 实现 `src/api/auth_handler.cpp` - `handleGetUserPublicInfo()` ✅
  - 从路径参数提取user_id ✅
  - 调用 `authService_->getUserPublicInfo()` ✅
  - 构造JSON响应（只包含公开字段） ✅
  - 添加详细的中文注释 ✅

- [x] **任务5.5**: 实现 `src/api/auth_handler.cpp` - `handleCheckUsername()` ✅
  - 从查询参数提取username ✅
  - 调用 `authService_->checkUsernameAvailability()` ✅
  - 构造JSON响应 ✅
  - 添加详细的中文注释 ✅

- [x] **任务5.6**: 修改 `src/api/auth_handler.cpp` - `registerRoutes()` ✅
  - 注册路由: `GET /api/v1/users/profile` ✅
  - 注册路由: `PUT /api/v1/users/profile` ✅
  - 注册路由: `GET /api/v1/users/:user_id` ✅
  - 注册路由: `GET /api/v1/users/check-username` ✅
  - 修复路由顺序冲突问题 ✅

- [x] **任务5.7**: 编译测试 ✅
  - 执行: `cd build && make` ✅
  - 验证: 编译无错误 ✅

---

### 阶段6：集成测试（1-2小时）

- [x] **任务6.1**: 启动服务器 ✅
  - 执行: `cd backend-service && ./build/knot_image_sharing` ✅
  - 验证: 服务器正常启动，监听8080端口 ✅

- [x] **任务6.2**: 测试用户注册和登录 ✅
  - 注册测试用户 ✅
  - 登录获取access_token ✅
  - 保存token用于后续测试 ✅

- [x] **任务6.3**: 测试获取当前用户信息 ✅
  - 执行: `curl -X GET http://localhost:8080/api/v1/users/profile -H "Authorization: Bearer {token}"` ✅
  - 验证: 返回200，包含用户信息 ✅

- [x] **任务6.4**: 测试修改用户信息 ✅
  - 执行: `curl -X PUT http://localhost:8080/api/v1/users/profile -H "Authorization: Bearer {token}" -H "Content-Type: application/json" -d '{...}'` ✅
  - 验证: 返回200，信息更新成功，新字段(bio、gender、location)正确保存 ✅

- [x] **任务6.5**: 测试获取其他用户公开信息 ✅
  - 执行: `curl -X GET http://localhost:8080/api/v1/users/{user_id}` ✅
  - 验证: 返回200，只包含公开信息 ✅

- [x] **任务6.6**: 测试用户名可用性检查 ✅
  - 执行: `curl -X GET "http://localhost:8080/api/v1/users/check-username?username=test"` ✅
  - 验证: 返回200，正确显示可用性(已存在/可用/无效格式) ✅

- [x] **任务6.7**: 异常流程测试 ✅
  - 测试无效token ✅
  - 测试格式错误的输入 ✅
  - 测试唯一性约束冲突 ✅
  - 验证: 返回正确的错误码和错误信息 ✅

---

### 阶段7：文档更新（30分钟）

- [x] **任务7.1**: 更新 `[000]API文档.md` ✅
  - 在"认证相关API"章节添加4个新接口 ✅
  - 更新版本号为 v2.1.0 ✅
  - 更新目录 ✅

- [x] **任务7.2**: 更新 `[101]阶段B-用户认证模块.md` ✅
  - 更新"完成的模块"列表
  - 添加新功能说明

- [x] **任务7.3**: 更新 `README.md` ✅
  - 更新功能列表

---

## ✅ 验收标准

### 功能验收
- [x] 所有4个API接口正常工作 ✅
- [x] JWT认证正确实施 ✅
- [x] 输入验证正确执行 ✅
- [x] 唯一性约束正确检查 ✅
- [x] 错误处理完善 ✅
- [x] 响应格式统一 ✅

### 代码质量验收
- [x] 符合九层架构规范 ✅
- [x] 详细的中文注释 ✅
- [x] 使用预编译语句 ✅
- [x] 使用ConnectionGuard ✅
- [x] 统一的错误处理 ✅
- [x] 无内存泄漏 ✅

### 测试验收
- [x] 所有集成测试通过 ✅
- [x] 异常流程测试通过 ✅

### 文档验收
- [x] API文档更新完整 ✅
- [ ] 架构文档更新 ⏳
- [ ] README更新 ⏳

---

## 📊 进度跟踪

| 阶段 | 任务数 | 已完成 | 进度 |
|------|--------|--------|------|
| 阶段1：数据库变更 | 2 | 2 | 100% ✅ |
| 阶段2：Model层 | 3 | 3 | 100% ✅ |
| 阶段3：Repository层 | 5 | 5 | 100% ✅ |
| 阶段4：Service层 | 6 | 6 | 100% ✅ |
| 阶段5：Handler层 | 7 | 7 | 100% ✅ |
| 阶段6：集成测试 | 7 | 7 | 100% ✅ |
| 阶段7：文档更新 | 3 | 3 | 100% ✅ |
| **总计** | **33** | **33** | **100%** |

---

## 🐛 当前问题记录

### 问题1：服务器API请求无响应

**发现时间**: 2025-10-09 21:34

**问题描述**:
服务器可以正常启动并监听8080端口，但所有API请求（包括原有的注册、登录接口）都返回"Empty reply from server"错误，服务器进程随后崩溃。

**复现步骤**:
1. 编译项目：`cd build && make -j4`（编译成功，无错误）
2. 启动服务器：`LD_LIBRARY_PATH=/usr/lib/x86_64-linux-gnu:$LD_LIBRARY_PATH ./knot_image_sharing ../config/config.json`
3. 服务器启动日志正常，显示：
   ```
   [2025-10-09 21:34:06.883] [info] [thread 42444] Auth routes registered
   [2025-10-09 21:34:06.883] [info] [thread 42444] Starting HTTP server...
   ```
4. 发送测试请求：
   ```bash
   curl -X POST http://localhost:8080/api/v1/auth/register \
     -H "Content-Type: application/json" \
     -d '{"username":"test123","password":"Test123456","real_name":"测试","phone":"13800138002","email":"test@test.com"}'
   ```
5. 结果：`curl: (52) Empty reply from server`
6. 服务器进程崩溃（return code: -1）

**预期结果**:
应该返回JSON响应，例如：
```json
{
  "success": true,
  "message": "注册成功",
  "data": {
    "user_id": "USR_2025Q1_XXX",
    "username": "test123",
    ...
  }
}
```

**可能原因分析**:

1. **数据库查询问题**：
   - 新添加的字段（bio, gender, location）在查询时可能导致NULL值处理错误
   - Repository层的`findById`或`findByUserId`方法可能需要更新以处理新字段
   - 建议检查：`src/database/user_repository.cpp`中的查询结果绑定部分

2. **JSON序列化问题**：
   - User模型的`toJson()`方法已更新包含新字段
   - 但可能在某些情况下（如字段为空）导致序列化失败
   - 建议检查：`src/models/user.cpp`的`toJson()`方法

3. **内存访问问题**：
   - 可能存在未初始化的指针或越界访问
   - 建议使用gdb调试：`gdb ./knot_image_sharing`

4. **路由冲突**：
   - 新添加的路由可能与现有路由冲突
   - 特别是`GET /api/v1/users/:user_id`使用了正则表达式匹配
   - 建议检查：`src/api/auth_handler.cpp`的`registerRoutes()`方法

**调试建议**:

1. **添加更多日志**：
   ```cpp
   // 在Handler方法开始处添加
   Logger::info("进入handleRegister方法");
   Logger::info("请求体: " + req.body);
   ```

2. **使用gdb调试**：
   ```bash
   gdb ./knot_image_sharing
   (gdb) run ../config/config.json
   # 在另一个终端发送请求
   # 查看崩溃位置
   (gdb) bt
   ```

3. **检查数据库查询**：
   - 在`user_repository.cpp`的查询方法中添加日志
   - 验证新字段的NULL值处理是否正确

4. **简化测试**：
   - 先测试不涉及新字段的API（如登录）
   - 如果登录也失败，说明问题不在新字段
   - 如果登录成功，逐步测试新API

**临时解决方案**:
如果问题难以定位，可以考虑：
1. 回滚到添加新字段之前的版本
2. 逐步添加功能，每次添加后测试
3. 使用git bisect定位引入问题的提交

**状态**: ✅ 已解决

**解决时间**: 2025-10-09 22:10

**解决方法**:
修复了`src/database/user_repository.cpp`中`buildUserFromStatement`方法的字段绑定问题。

**具体修改**:
1. 将`MYSQL_BIND result[14]`扩展为`MYSQL_BIND result[17]`
2. 添加bio、gender、location三个字段的变量声明:
   ```cpp
   char bio[501] = {0};
   char gender[25] = {0};
   char location[101] = {0};
   ```
3. 添加对应的长度变量和NULL标志变量:
   ```cpp
   unsigned long bio_length, gender_length, location_length;
   bool bio_is_null, gender_is_null, location_is_null;
   ```
4. 在result数组中添加bio(result[11])、gender(result[12])、location(result[13])的绑定
5. 将device_count、create_time、update_time的索引从[11][12][13]调整为[14][15][16]
6. 在fetch后添加bio、gender、location字段的值设置:
   ```cpp
   if (!bio_is_null) {
       user.setBio(std::string(bio, bio_length));
   }
   if (!gender_is_null) {
       user.setGender(std::string(gender, gender_length));
   }
   if (!location_is_null) {
       user.setLocation(std::string(location, location_length));
   }
   ```

**修改文件**: `backend-service/src/database/user_repository.cpp` (第157-327行)

**验证结果**:
- ✅ 编译成功无错误
- ✅ 服务器正常启动
- ✅ 用户注册接口正常工作
- ✅ 用户登录接口正常工作
- ✅ 获取用户信息接口正常工作
- ✅ 更新用户信息接口正常工作，新字段(bio、gender、location)正确读写

**测试用例**:
```bash
# 注册用户
curl -X POST http://localhost:8080/api/v1/auth/register \
  -H "Content-Type: application/json" \
  -d '{"username":"testuser001","password":"Test123456","real_name":"测试用户001","phone":"13900000099","email":"test001@example.com"}'

# 登录
curl -X POST http://localhost:8080/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"testuser001","password":"Test123456"}'

# 更新用户信息(包含新字段)
curl -X PUT http://localhost:8080/api/v1/users/profile \
  -H "Authorization: Bearer {TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{"real_name":"测试用户001更新","email":"test001@example.com","phone":"13900000099","bio":"这是我的个人简介","gender":"male","location":"北京"}'
```

**根本原因分析**:
数据库表users增加了3个新字段(bio、gender、location),但`buildUserFromStatement`方法的MYSQL_BIND数组大小未同步更新,导致`SELECT * FROM users`查询返回17个字段时,只绑定了14个槽位,造成内存访问越界,服务器崩溃。

---

## 📝 变更日志

### 2025-10-09 22:15 - Bug修复与测试完成

**修复内容**:
- 修复了`buildUserFromStatement`方法的字段绑定bug (user_repository.cpp:157-327)
- 解决了服务器API请求导致崩溃的问题

**测试完成**:
- ✅ 任务6.1: 服务器启动测试通过
- ✅ 任务6.2: 用户注册和登录测试通过
- ✅ 任务6.3: 获取当前用户信息测试通过
- ✅ 任务6.4: 修改用户信息测试通过(包括新字段)

**待完成**:
- ⏳ 任务6.5: 获取其他用户公开信息
- ⏳ 任务6.6: 用户名可用性检查
- ⏳ 任务6.7: 异常流程测试
- ⏳ 阶段7: 文档更新(3个任务)

**当前进度**: 82% (27/33任务完成)

---

### 2025-10-09 22:35 - 路由修复与全部测试完成

**修复内容**:
- 修复路由冲突问题:调整路由注册顺序,将`check-username`放在正则匹配路由`/users/([^/]+)`之前
- 修改文件: `src/api/auth_handler.cpp` (第68-76行)
- 原因: 正则表达式路由会匹配所有`/users/xxx`格式的URL,导致`check-username`被误匹配

**测试完成**:
- ✅ 任务6.5: 获取其他用户公开信息测试通过
- ✅ 任务6.6: 用户名可用性检查测试通过
  - 测试用户名已存在: 返回available=false ✅
  - 测试用户名可用: 返回available=true ✅
  - 测试无效格式: 返回valid=false ✅
- ✅ 任务6.7: 异常流程测试通过
  - 无效token测试 ✅
  - 格式错误输入测试 ✅
  - 唯一性约束冲突测试 ✅

**文档更新完成**:
- ✅ 任务7.1: [000]API文档更新完成
  - 版本号更新为 v2.1.0
  - 目录添加4个新接口链接
  - 添加4个新接口完整文档(请求/响应/错误码说明)

**当前进度**: 94% (31/33任务完成)

**待完成任务**:
- ⏳ 任务7.2: 更新[101]阶段B-用户认证模块.md
- ⏳ 任务7.3: 更新README.md

---

### 2025-10-09 22:40 - 所有文档更新完成 🎉

**文档更新完成**:
- ✅ 任务7.2: 更新[101]阶段B-用户认证模块.md完成
  - 版本号更新为 v2.1.0
  - 在"完成的模块"表格中添加用户信息管理模块
  - 在"API接口"章节添加4个新接口文档
  - 在"完成总结"中添加v2.1.0新增功能说明
  - 更新文档维护者为Knot Development Team

- ✅ 任务7.3: 更新README.md完成
  - 版本号更新为 v2.1.0
  - 在"核心功能"中添加用户信息管理功能说明
  - 在"API文档"中添加用户信息管理接口表格
  - 在"项目进度-阶段B"中添加v2.1.0新增功能清单

**🎉 项目完成**: 100% (33/33任务全部完成)

**功能实现情况**:
- ✅ 获取当前用户信息 (GET /api/v1/users/profile)
- ✅ 修改用户信息 (PUT /api/v1/users/profile)
- ✅ 获取其他用户公开信息 (GET /api/v1/users/:user_id)
- ✅ 用户名可用性检查 (GET /api/v1/users/check-username)

**数据库变更**:
- ✅ bio字段 (个人简介)
- ✅ gender字段 (性别)
- ✅ location字段 (所在地)

**Bug修复**:
- ✅ MYSQL_BIND数组大小不匹配问题
- ✅ 路由冲突问题

---

## 🎯 阶段8：用户头像上传功能（v2.5.0）

### 功能需求分析

#### 业务需求
- 用户可以上传自定义头像图片
- 系统自动压缩和裁剪为标准尺寸（200x200）
- 自动删除旧头像文件（节省存储空间）
- 返回带服务器URL前缀的完整头像路径
- 支持常见图片格式（JPEG、PNG、GIF、WebP）

#### 技术需求
- 文件大小限制：最大5MB
- 图片尺寸：自动裁剪为200x200正方形
- 存储路径：`/uploads/avatars/USER_ID_timestamp.jpg`
- 压缩质量：JPEG 80%
- 支持格式：image/jpeg, image/png, image/gif, image/webp

#### API设计

**接口**: `POST /api/v1/users/avatar`

**请求头**:
```
Authorization: Bearer {access_token}
Content-Type: multipart/form-data
```

**请求参数**:
| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| avatar | File | 是 | 头像图片文件 |

**成功响应** (200):
```json
{
  "success": true,
  "message": "头像上传成功",
  "data": {
    "avatar_url": "http://8.138.115.164:8080/uploads/avatars/USR_2025Q4_abc123_1728912345.jpg",
    "file_size": 45678,
    "width": 200,
    "height": 200
  },
  "timestamp": 1728912345
}
```

**错误响应**:
- 400: 未提供文件、文件格式不支持、文件过大
- 401: 未授权（token无效或过期）
- 500: 服务器内部错误

---

### 阶段8.1：工具层增强（1小时）

#### 任务8.1.1: 创建 `src/utils/avatar_processor.h`

**功能**: 专门处理头像的工具类（基于ImageProcessor）

**类定义**:
```cpp
/**
 * @brief 头像处理结果结构体
 */
struct AvatarProcessResult {
    bool success;              // 处理是否成功
    std::string message;       // 错误信息（如果失败）
    std::string avatarPath;    // 头像路径
    int width;                 // 图片宽度（固定200）
    int height;                // 图片高度（固定200）
    long long fileSize;        // 文件大小（字节）
    
    AvatarProcessResult() : success(false), width(0), height(0), fileSize(0) {}
};

/**
 * @brief 头像处理工具类
 * 
 * 专门用于处理用户头像上传，包括裁剪、压缩、保存
 */
class AvatarProcessor {
public:
    /**
     * @brief 处理头像图片（裁剪为正方形 + 压缩）
     * 
     * @param inputPath 输入图片路径（临时文件）
     * @param userId 用户ID（用于生成文件名）
     * @param outputDir 输出目录（例：uploads/avatars/）
     * @return AvatarProcessResult 处理结果
     */
    static AvatarProcessResult processAvatar(
        const std::string& inputPath,
        const std::string& userId,
        const std::string& outputDir
    );
    
    /**
     * @brief 删除旧头像文件
     * 
     * @param avatarUrl 旧头像URL（相对路径）
     * @return bool 成功返回true
     */
    static bool deleteOldAvatar(const std::string& avatarUrl);
    
    /**
     * @brief 验证头像文件格式和大小
     * 
     * @param filePath 文件路径
     * @param maxSize 最大文件大小（字节）
     * @return std::pair<bool, std::string> {是否有效, 错误信息}
     */
    static std::pair<bool, std::string> validateAvatarFile(
        const std::string& filePath,
        long long maxSize = 5 * 1024 * 1024
    );

private:
    static constexpr int AVATAR_SIZE = 200;        // 头像尺寸（200x200）
    static constexpr int JPEG_QUALITY = 80;        // JPEG压缩质量
    static constexpr long long MAX_FILE_SIZE = 5 * 1024 * 1024;  // 5MB
    
    /**
     * @brief 裁剪图片为正方形（居中裁剪）
     * 
     * @param inputData 输入图片数据
     * @param width 原图宽度
     * @param height 原图高度
     * @param channels 通道数
     * @return unsigned char* 裁剪后的图片数据（需要手动释放）
     */
    static unsigned char* cropToSquare(
        unsigned char* inputData,
        int width,
        int height,
        int channels,
        int& outSize
    );
};
```

**实现要点**:
1. 使用stb_image加载图片
2. 如果不是正方形，居中裁剪为正方形
3. 使用stb_image_resize缩放到200x200
4. 使用stb_image_write保存为JPEG（80%质量）
5. 文件命名格式：`USER_ID_timestamp.jpg`

---

#### 任务8.1.2: 实现 `src/utils/avatar_processor.cpp`

**核心逻辑**:

```cpp
AvatarProcessResult AvatarProcessor::processAvatar(
    const std::string& inputPath,
    const std::string& userId,
    const std::string& outputDir
) {
    AvatarProcessResult result;
    
    try {
        // 1. 验证文件
        auto [valid, errorMsg] = validateAvatarFile(inputPath);
        if (!valid) {
            result.message = errorMsg;
            return result;
        }
        
        // 2. 加载图片
        int width, height, channels;
        unsigned char* data = stbi_load(inputPath.c_str(), &width, &height, &channels, 0);
        if (!data) {
            result.message = "无法加载图片";
            return result;
        }
        
        // 3. 裁剪为正方形（如果需要）
        int squareSize = std::min(width, height);
        unsigned char* squareData = cropToSquare(data, width, height, channels, squareSize);
        stbi_image_free(data);
        
        // 4. 缩放到200x200
        unsigned char* resizedData = (unsigned char*)malloc(AVATAR_SIZE * AVATAR_SIZE * channels);
        stbir_resize_uint8_linear(
            squareData, squareSize, squareSize, 0,
            resizedData, AVATAR_SIZE, AVATAR_SIZE, 0,
            (stbir_pixel_layout)channels
        );
        free(squareData);
        
        // 5. 生成文件名：USER_ID_timestamp.jpg
        std::string timestamp = std::to_string(std::time(nullptr));
        std::string filename = userId + "_" + timestamp + ".jpg";
        std::string outputPath = outputDir + filename;
        
        // 6. 保存为JPEG
        int saveResult = stbi_write_jpg(
            outputPath.c_str(),
            AVATAR_SIZE,
            AVATAR_SIZE,
            channels,
            resizedData,
            JPEG_QUALITY
        );
        free(resizedData);
        
        if (!saveResult) {
            result.message = "无法保存头像";
            return result;
        }
        
        // 7. 构建结果
        result.success = true;
        result.avatarPath = "/uploads/avatars/" + filename;
        result.width = AVATAR_SIZE;
        result.height = AVATAR_SIZE;
        result.fileSize = ImageProcessor::getFileSize(outputPath);
        
        Logger::info("Avatar processed successfully for user: " + userId);
        return result;
        
    } catch (const std::exception& e) {
        result.message = "处理头像时发生异常: " + std::string(e.what());
        Logger::error(result.message);
        return result;
    }
}

bool AvatarProcessor::deleteOldAvatar(const std::string& avatarUrl) {
    if (avatarUrl.empty() || avatarUrl.find("/uploads/avatars/") == std::string::npos) {
        return false;  // 不是有效的头像路径
    }
    
    // 构建完整文件路径
    std::string filePath = "." + avatarUrl;  // 相对于项目根目录
    
    // 删除文件
    if (std::remove(filePath.c_str()) == 0) {
        Logger::info("Old avatar deleted: " + avatarUrl);
        return true;
    } else {
        Logger::warning("Failed to delete old avatar: " + avatarUrl);
        return false;
    }
}

std::pair<bool, std::string> AvatarProcessor::validateAvatarFile(
    const std::string& filePath,
    long long maxSize
) {
    // 1. 检查文件是否存在
    struct stat st;
    if (stat(filePath.c_str(), &st) != 0) {
        return {false, "文件不存在"};
    }
    
    // 2. 检查文件大小
    if (st.st_size > maxSize) {
        return {false, "文件大小超过5MB限制"};
    }
    
    // 3. 检查文件格式
    if (!ImageProcessor::validateFormat(filePath)) {
        return {false, "不支持的图片格式"};
    }
    
    return {true, ""};
}

unsigned char* AvatarProcessor::cropToSquare(
    unsigned char* inputData,
    int width,
    int height,
    int channels,
    int& outSize
) {
    int squareSize = std::min(width, height);
    outSize = squareSize;
    
    // 计算裁剪起始位置（居中）
    int startX = (width - squareSize) / 2;
    int startY = (height - squareSize) / 2;
    
    // 分配输出缓冲区
    unsigned char* output = (unsigned char*)malloc(squareSize * squareSize * channels);
    
    // 复制像素数据
    for (int y = 0; y < squareSize; y++) {
        for (int x = 0; x < squareSize; x++) {
            int srcIdx = ((startY + y) * width + (startX + x)) * channels;
            int dstIdx = (y * squareSize + x) * channels;
            for (int c = 0; c < channels; c++) {
                output[dstIdx + c] = inputData[srcIdx + c];
            }
        }
    }
    
    return output;
}
```

---

### 阶段8.2：Service层（1.5小时）

#### 任务8.2.1: 修改 `src/core/auth_service.h`

**添加结构体**:
```cpp
/**
 * @brief 头像上传结果
 */
struct UploadAvatarResult {
    bool success = false;
    std::string message;
    std::string avatarUrl;      // 头像URL（相对路径）
    long long fileSize = 0;
    int width = 0;
    int height = 0;
};
```

**添加方法声明**:
```cpp
/**
 * @brief 上传用户头像
 * 
 * @param userId 用户ID
 * @param tempFilePath 临时文件路径
 * @return UploadAvatarResult 上传结果
 */
UploadAvatarResult uploadAvatar(int userId, const std::string& tempFilePath);
```

---

#### 任务8.2.2: 实现 `src/core/auth_service.cpp` - `uploadAvatar()`

```cpp
UploadAvatarResult AuthService::uploadAvatar(int userId, const std::string& tempFilePath) {
    UploadAvatarResult result;
    
    try {
        Logger::info("Uploading avatar for user ID: " + std::to_string(userId));
        
        // 1. 验证用户存在
        auto existingUser = userRepo_->findById(userId);
        if (!existingUser.has_value()) {
            result.message = "用户不存在";
            Logger::warning(result.message);
            return result;
        }
        
        // 2. 获取用户的user_id（用于文件命名）
        std::string userIdStr = existingUser->getUserId();
        
        // 3. 处理头像图片
        std::string avatarDir = "uploads/avatars/";
        auto processResult = AvatarProcessor::processAvatar(tempFilePath, userIdStr, avatarDir);
        
        if (!processResult.success) {
            result.message = processResult.message;
            Logger::error("Failed to process avatar: " + result.message);
            return result;
        }
        
        // 4. 删除旧头像（如果存在）
        std::string oldAvatarUrl = existingUser->getAvatarUrl();
        if (!oldAvatarUrl.empty()) {
            AvatarProcessor::deleteOldAvatar(oldAvatarUrl);
        }
        
        // 5. 更新数据库中的avatar_url
        bool updateSuccess = userRepo_->updateAvatarUrl(userId, processResult.avatarPath);
        if (!updateSuccess) {
            result.message = "更新数据库失败";
            Logger::error(result.message);
            // 删除刚上传的头像文件
            AvatarProcessor::deleteOldAvatar(processResult.avatarPath);
            return result;
        }
        
        // 6. 删除临时文件
        std::remove(tempFilePath.c_str());
        
        // 7. 构建成功结果
        result.success = true;
        result.message = "头像上传成功";
        result.avatarUrl = processResult.avatarPath;
        result.fileSize = processResult.fileSize;
        result.width = processResult.width;
        result.height = processResult.height;
        
        Logger::info("Avatar uploaded successfully for user: " + userIdStr);
        return result;
        
    } catch (const std::exception& e) {
        result.message = "上传头像时发生异常: " + std::string(e.what());
        Logger::error(result.message);
        return result;
    }
}
```

---

### 阶段8.3：Repository层（30分钟）

#### 任务8.3.1: 修改 `src/database/user_repository.h`

**添加方法声明**:
```cpp
/**
 * @brief 更新用户头像URL
 * 
 * @param userId 用户数据库ID
 * @param avatarUrl 新的头像URL
 * @return bool 成功返回true
 */
bool updateAvatarUrl(int userId, const std::string& avatarUrl);
```

---

#### 任务8.3.2: 实现 `src/database/user_repository.cpp` - `updateAvatarUrl()`

```cpp
bool UserRepository::updateAvatarUrl(int userId, const std::string& avatarUrl) {
    // 使用ConnectionGuard获取数据库连接
    ConnectionGuard connGuard(pool_);
    if (!connGuard.isValid()) {
        Logger::error("Failed to get database connection");
        return false;
    }
    
    MYSQL* conn = connGuard.get();
    
    // 准备SQL语句
    const char* sql = "UPDATE users SET avatar_url = ?, update_time = CURRENT_TIMESTAMP WHERE id = ?";
    
    MYSQL_STMT* stmt = mysql_stmt_init(conn);
    if (!stmt) {
        Logger::error("Failed to initialize statement");
        return false;
    }
    
    if (mysql_stmt_prepare(stmt, sql, strlen(sql)) != 0) {
        Logger::error("Failed to prepare statement: " + std::string(mysql_stmt_error(stmt)));
        mysql_stmt_close(stmt);
        return false;
    }
    
    // 绑定参数
    MYSQL_BIND bind[2];
    memset(bind, 0, sizeof(bind));
    
    // avatar_url
    unsigned long avatar_length = avatarUrl.length();
    bind[0].buffer_type = MYSQL_TYPE_STRING;
    bind[0].buffer = (char*)avatarUrl.c_str();
    bind[0].buffer_length = avatarUrl.length();
    bind[0].length = &avatar_length;
    
    // userId
    bind[1].buffer_type = MYSQL_TYPE_LONG;
    bind[1].buffer = (char*)&userId;
    
    if (mysql_stmt_bind_param(stmt, bind) != 0) {
        Logger::error("Failed to bind parameters: " + std::string(mysql_stmt_error(stmt)));
        mysql_stmt_close(stmt);
        return false;
    }
    
    // 执行更新
    if (mysql_stmt_execute(stmt) != 0) {
        Logger::error("Failed to execute statement: " + std::string(mysql_stmt_error(stmt)));
        mysql_stmt_close(stmt);
        return false;
    }
    
    mysql_stmt_close(stmt);
    
    Logger::info("Avatar URL updated for user ID: " + std::to_string(userId));
    return true;
}
```

---

### 阶段8.4：Handler层（1.5小时）

#### 任务8.4.1: 修改 `src/api/auth_handler.h`

**添加方法声明**:
```cpp
/**
 * @brief 处理头像上传请求
 * 
 * @param req HTTP请求对象
 * @param res HTTP响应对象
 */
void handleUploadAvatar(const httplib::Request& req, httplib::Response& res);

private:
/**
 * @brief 保存上传的文件到临时目录
 * 
 * @param file 上传的文件对象
 * @return std::string 临时文件路径（失败返回空字符串）
 */
std::string saveTempFile(const httplib::MultipartFormData& file);
```

---

#### 任务8.4.2: 实现 `src/api/auth_handler.cpp` - `handleUploadAvatar()`

```cpp
void AuthHandler::handleUploadAvatar(const httplib::Request& req, httplib::Response& res) {
    try {
        // 1. 验证JWT token
        std::string authHeader = req.get_header_value("Authorization");
        if (authHeader.substr(0, 7) != "Bearer ") {
            sendJsonResponse(res, 401, false, "未授权：缺少或无效的Authorization头");
            return;
        }
        
        std::string token = authHeader.substr(7);
        auto jwtManager = std::make_unique<JWTManager>();
        TokenValidationResult validation = jwtManager->validateAccessToken(token);
        
        if (!validation.valid) {
            sendJsonResponse(res, 401, false, "未授权：" + validation.message);
            return;
        }
        
        int userId = validation.userId;
        
        // 2. 检查是否有上传的文件
        if (!req.has_file("avatar")) {
            sendJsonResponse(res, 400, false, "请求错误：未提供头像文件");
            return;
        }
        
        // 3. 获取上传的文件
        auto file = req.get_file_value("avatar");
        
        // 4. 验证文件类型
        std::string contentType = file.content_type;
        if (contentType != "image/jpeg" && 
            contentType != "image/png" && 
            contentType != "image/gif" && 
            contentType != "image/webp") {
            sendJsonResponse(res, 400, false, "请求错误：不支持的图片格式");
            return;
        }
        
        // 5. 保存到临时文件
        std::string tempFilePath = saveTempFile(file);
        if (tempFilePath.empty()) {
            sendJsonResponse(res, 500, false, "服务器错误：无法保存临时文件");
            return;
        }
        
        // 6. 调用Service层处理头像上传
        auto result = authService_->uploadAvatar(userId, tempFilePath);
        
        if (!result.success) {
            sendJsonResponse(res, 400, false, result.message);
            return;
        }
        
        // 7. 构建响应数据（使用UrlHelper添加URL前缀）
        Json::Value data;
        data["avatar_url"] = UrlHelper::toFullUrl(result.avatarUrl);
        data["file_size"] = static_cast<Json::Int64>(result.fileSize);
        data["width"] = result.width;
        data["height"] = result.height;
        
        sendJsonResponse(res, 200, true, result.message, data);
        
        Logger::info("Avatar uploaded successfully for user ID: " + std::to_string(userId));
        
    } catch (const std::exception& e) {
        Logger::error("Exception in handleUploadAvatar: " + std::string(e.what()));
        sendJsonResponse(res, 500, false, "服务器内部错误");
    }
}

std::string AuthHandler::saveTempFile(const httplib::MultipartFormData& file) {
    try {
        // 生成临时文件名
        std::string timestamp = std::to_string(std::time(nullptr));
        std::string tempDir = "uploads/temp/";
        std::string tempFilePath = tempDir + "avatar_" + timestamp + ".tmp";
        
        // 确保临时目录存在
        system(("mkdir -p " + tempDir).c_str());
        
        // 写入文件
        std::ofstream ofs(tempFilePath, std::ios::binary);
        if (!ofs) {
            Logger::error("Failed to create temp file: " + tempFilePath);
            return "";
        }
        
        ofs.write(file.content.data(), file.content.size());
        ofs.close();
        
        Logger::info("Temp file saved: " + tempFilePath);
        return tempFilePath;
        
    } catch (const std::exception& e) {
        Logger::error("Exception in saveTempFile: " + std::string(e.what()));
        return "";
    }
}
```

---

#### 任务8.4.3: 修改 `src/api/auth_handler.cpp` - `registerRoutes()`

```cpp
// 在registerRoutes()方法中添加路由
server.Post("/api/v1/users/avatar", [this](const httplib::Request& req, httplib::Response& res) {
    handleUploadAvatar(req, res);
});
```

**注意路由顺序**：将此路由放在 `/api/v1/users/check-username` 之后，`/api/v1/users/([^/]+)` 之前。

---

### 阶段8.5：测试与验证（1小时）

#### 任务8.5.1: 创建测试目录

```bash
mkdir -p uploads/avatars uploads/temp
chmod 755 uploads/avatars uploads/temp
```

---

#### 任务8.5.2: 编译测试

```bash
cd backend-service/build
cmake ..
make -j4
```

**验证**: 编译无错误

---

#### 任务8.5.3: 功能测试

**测试用例1：正常上传头像**
```bash
# 1. 登录获取token
TOKEN=$(curl -X POST http://localhost:8080/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"testuser","password":"Test123456"}' \
  | jq -r '.data.access_token')

# 2. 上传头像
curl -X POST http://localhost:8080/api/v1/users/avatar \
  -H "Authorization: Bearer $TOKEN" \
  -F "avatar=@test_avatar.jpg"
```

**预期结果**:
```json
{
  "success": true,
  "message": "头像上传成功",
  "data": {
    "avatar_url": "http://8.138.115.164:8080/uploads/avatars/USR_2025Q4_abc123_1728912345.jpg",
    "file_size": 45678,
    "width": 200,
    "height": 200
  },
  "timestamp": 1728912345
}
```

---

**测试用例2：验证头像已更新**
```bash
# 获取用户信息，检查avatar_url是否已更新
curl -X GET http://localhost:8080/api/v1/users/profile \
  -H "Authorization: Bearer $TOKEN"
```

---

**测试用例3：上传第二次头像（验证旧头像被删除）**
```bash
# 再次上传新头像
curl -X POST http://localhost:8080/api/v1/users/avatar \
  -H "Authorization: Bearer $TOKEN" \
  -F "avatar=@test_avatar2.jpg"

# 验证：旧头像文件应该被删除，只保留最新的头像文件
ls -lh uploads/avatars/
```

---

**测试用例4：错误测试 - 未提供文件**
```bash
curl -X POST http://localhost:8080/api/v1/users/avatar \
  -H "Authorization: Bearer $TOKEN"
```

**预期结果**: 400错误，"请求错误：未提供头像文件"

---

**测试用例5：错误测试 - 文件过大**
```bash
# 创建一个6MB的测试文件
dd if=/dev/zero of=large_avatar.jpg bs=1M count=6

curl -X POST http://localhost:8080/api/v1/users/avatar \
  -H "Authorization: Bearer $TOKEN" \
  -F "avatar=@large_avatar.jpg"
```

**预期结果**: 400错误，"文件大小超过5MB限制"

---

**测试用例6：错误测试 - 不支持的格式**
```bash
# 上传非图片文件
curl -X POST http://localhost:8080/api/v1/users/avatar \
  -H "Authorization: Bearer $TOKEN" \
  -F "avatar=@test.txt"
```

**预期结果**: 400错误，"不支持的图片格式"

---

**测试用例7：错误测试 - 无效token**
```bash
curl -X POST http://localhost:8080/api/v1/users/avatar \
  -H "Authorization: Bearer invalid_token" \
  -F "avatar=@test_avatar.jpg"
```

**预期结果**: 401错误，"未授权"

---

### 阶段8.6：文档更新（30分钟）

#### 任务8.6.1: 更新 `[000]API文档.md`

在"用户相关API"章节添加：

```markdown
### 5. 上传用户头像

**接口**: `POST /api/v1/users/avatar`

**描述**: 上传用户头像图片，自动裁剪为200x200正方形并压缩

**认证**: 需要JWT token

**请求头**:
```
Authorization: Bearer {access_token}
Content-Type: multipart/form-data
```

**请求参数**:
| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| avatar | File | 是 | 头像图片文件（最大5MB） |

**支持格式**: JPEG, PNG, GIF, WebP

**成功响应** (200):
```json
{
  "success": true,
  "message": "头像上传成功",
  "data": {
    "avatar_url": "http://8.138.115.164:8080/uploads/avatars/USR_2025Q4_abc123_1728912345.jpg",
    "file_size": 45678,
    "width": 200,
    "height": 200
  },
  "timestamp": 1728912345
}
```

**错误响应**:
- 400: 未提供文件、文件格式不支持、文件过大
- 401: 未授权（token无效或过期）
- 500: 服务器内部错误
```

---

#### 任务8.6.2: 更新 `docs/api/openapi.yaml`

添加头像上传接口定义：

```yaml
/api/v1/users/avatar:
  post:
    tags:
      - 用户管理
    summary: 上传用户头像
    description: |
      上传用户头像图片，系统会自动：
      - 裁剪为200x200正方形
      - 压缩为JPEG格式（80%质量）
      - 删除旧头像文件
      - 返回带服务器URL前缀的完整路径
    security:
      - BearerAuth: []
    requestBody:
      required: true
      content:
        multipart/form-data:
          schema:
            type: object
            required:
              - avatar
            properties:
              avatar:
                type: string
                format: binary
                description: 头像图片文件（最大5MB，支持JPEG/PNG/GIF/WebP）
    responses:
      '200':
        description: 头像上传成功
        content:
          application/json:
            schema:
              type: object
              properties:
                success:
                  type: boolean
                  example: true
                message:
                  type: string
                  example: "头像上传成功"
                data:
                  type: object
                  properties:
                    avatar_url:
                      type: string
                      example: "http://8.138.115.164:8080/uploads/avatars/USR_2025Q4_abc123_1728912345.jpg"
                    file_size:
                      type: integer
                      example: 45678
                    width:
                      type: integer
                      example: 200
                    height:
                      type: integer
                      example: 200
                timestamp:
                  type: integer
                  example: 1728912345
      '400':
        description: 请求错误（未提供文件、格式不支持、文件过大）
      '401':
        description: 未授权
      '500':
        description: 服务器内部错误
```

---

#### 任务8.6.3: 更新 `README.md` 和 `CLAUDE.md`

在功能列表中添加：
- ✅ 用户头像上传（v2.5.0 - 自动裁剪、压缩、旧头像清理）

---

### 阶段8.7：性能优化与安全加固（可选，30分钟）

#### 优化建议

1. **并发上传限制**：
   - 使用信号量限制同时上传的数量
   - 防止服务器资源耗尽

2. **文件类型验证增强**：
   - 不仅检查MIME类型，还检查文件魔数
   - 防止伪造文件类型的攻击

3. **临时文件清理**：
   - 定期清理超过1小时的临时文件
   - 防止磁盘空间占用

4. **CDN集成**（未来）：
   - 将头像上传到CDN
   - 提升访问速度

---

## 📊 v2.5.0 进度跟踪

| 阶段 | 任务数 | 已完成 | 进度 |
|------|--------|--------|------|
| 阶段8.1：工具层增强 | 2 | 0 | 0% ⏳ |
| 阶段8.2：Service层 | 2 | 0 | 0% ⏳ |
| 阶段8.3：Repository层 | 2 | 0 | 0% ⏳ |
| 阶段8.4：Handler层 | 3 | 0 | 0% ⏳ |
| 阶段8.5：测试与验证 | 3 | 0 | 0% ⏳ |
| 阶段8.6：文档更新 | 3 | 0 | 0% ⏳ |
| 阶段8.7：性能优化 | 可选 | 0 | 0% ⏳ |
| **总计** | **15** | **0** | **0%** |

---

## ✅ v2.5.0 验收标准

### 功能验收
- [ ] 头像上传接口正常工作
- [ ] 图片自动裁剪为200x200正方形
- [ ] 图片自动压缩为JPEG格式
- [ ] 旧头像文件自动删除
- [ ] 返回的URL包含服务器前缀
- [ ] 文件大小和格式验证正确

### 安全验收
- [ ] JWT认证正确实施
- [ ] 文件类型验证严格
- [ ] 文件大小限制有效
- [ ] 临时文件正确清理
- [ ] 无路径遍历漏洞

### 性能验收
- [ ] 单次上传响应时间 < 2秒
- [ ] 并发上传不影响其他API
- [ ] 磁盘空间占用合理

### 代码质量验收
- [ ] 符合九层架构规范
- [ ] 详细的中文注释
- [ ] 统一的错误处理
- [ ] 无内存泄漏

---

**最后更新**: 2025-10-14 20:00
**维护者**: Knot Development Team

