# [119] 帖子详情接口添加用户昵称字段-实施方案

**文档编号**: [119]  
**创建时间**: 2025-10-18  
**完成时间**: 2025-10-18  
**作者**: Knot Team  
**优先级**: 🟡 中优先级  
**状态**: ✅ 已完成  
**关联版本**: v2.5.1（小版本优化）

---

## 📋 目录

- [一、问题概述](#一问题概述)
- [二、影响范围分析](#二影响范围分析)
- [三、技术方案](#三技术方案)
- [四、实施步骤](#四实施步骤)
- [五、测试验证](#五测试验证)
- [六、风险评估](#六风险评估)

---

## 一、问题概述

### 1.1 问题描述

当前获取帖子详情接口（`GET /api/v1/posts/:post_id`）返回的JSON数据中，只包含发帖用户的`user_id`（逻辑ID），**缺少用户昵称（username）字段**，导致：

1. **前端体验不佳**：无法直接显示发帖人昵称，需要额外请求用户信息接口
2. **性能问题**：产生N+1查询问题，每次查看帖子详情需要2次HTTP请求
3. **数据一致性**：Feed流接口（v2.5.0）已返回`author.username`，但帖子详情接口未返回，造成API不一致

### 1.2 问题示例

**当前返回（缺少username）**：
```json
{
  "success": true,
  "message": "查询成功",
  "data": {
    "post": {
      "post_id": "POST_2025Q4_ABC123",
      "user_id": "USR_2025Q4_DEF456",  ✅ 有逻辑ID
      "title": "美丽的日落",
      "description": "今天的日落真美",
      "image_count": 3,
      "like_count": 42,
      "images": [...]
    }
  }
}
```
❌ **前端需要额外调用**：`GET /api/v1/users/USR_2025Q4_DEF456` 获取username

**期望返回（包含username）**：
```json
{
  "success": true,
  "message": "查询成功",
  "data": {
    "post": {
      "post_id": "POST_2025Q4_ABC123",
      "user_id": "USR_2025Q4_DEF456",
      "username": "alice_photo",  ✅ 新增昵称字段
      "title": "美丽的日落",
      "description": "今天的日落真美",
      "image_count": 3,
      "like_count": 42,
      "images": [...]
    }
  }
}
```
✅ **前端直接使用username字段显示**，无需额外请求

### 1.3 与v2.5.0 Feed流优化的一致性对比

**v2.5.0 Feed流返回格式**（已实现）：
```json
{
  "posts": [
    {
      "post_id": "POST_2025Q4_ABC123",
      "author": {
        "user_id": "USR_2025Q4_DEF456",
        "username": "alice_photo",  ✅ 已有
        "avatar_url": "..."
      },
      "title": "美丽的日落",
      ...
    }
  ]
}
```

**当前帖子详情返回格式**（待优化）：
```json
{
  "post": {
    "post_id": "POST_2025Q4_ABC123",
    "user_id": "USR_2025Q4_DEF456",
    // ❌ 缺少username和avatar_url
    "title": "美丽的日落",
    ...
  }
}
```

**一致性目标**：帖子详情接口应与Feed流接口保持相同的数据结构，都包含完整的作者信息。

---

## 二、影响范围分析

### 2.1 受影响的模型

| 模型 | 文件路径 | 需要修改的内容 | 影响程度 |
|------|---------|----------------|----------|
| Post | `src/models/post.h/cpp` | 添加`username_`字段、getters/setters、toJson()序列化 | 🟡 中 |

### 2.2 受影响的Repository层

| Repository | 文件路径 | 需要修改的内容 | 影响程度 |
|-----------|---------|----------------|----------|
| PostRepository | `src/database/post_repository.h/cpp` | SQL查询JOIN users表获取username | 🟡 中 |

**涉及的方法**：
- `findByPostId()` - 根据业务ID查询帖子（不含图片）
- `findByPostIdWithImages()` - 根据业务ID查询帖子（含图片）

### 2.3 受影响的API接口

| 接口 | 端点 | 影响 | 影响程度 |
|-----|------|------|----------|
| 获取帖子详情 | `GET /api/v1/posts/:post_id` | 返回数据新增`username`字段 | 🟢 低（向后兼容） |

**其他接口自动受益**：
- 创建帖子接口 - 返回的post对象将包含username
- 更新帖子接口 - 返回的post对象将包含username

### 2.4 不受影响的部分

| 部分 | 说明 |
|-----|------|
| 数据库结构 | 不需要修改，只需JOIN查询 |
| Service层 | 仅透传数据，无需修改逻辑 |
| Feed流接口 | 已有author字段，不受影响 |
| 前端API | 向后兼容，仅新增字段 |

---

## 三、技术方案

### 3.1 方案对比

#### 方案A：在Post模型中添加username字段（✅ 推荐）

**实施方式**：
1. Post模型新增`username_`字段
2. Repository层SQL查询LEFT JOIN users表获取username
3. Post::toJson()自动序列化username字段

**优点**：
- ✅ 性能最优，一次SQL查询返回完整信息
- ✅ 与v2.5.0 Feed流优化方案架构一致（已有author字段）
- ✅ 减少HTTP请求次数，改善用户体验
- ✅ 代码逻辑清晰，符合九层架构设计

**缺点**：
- ⚠️ Post对象存储冗余数据（username在User和Post中都存在）
- ⚠️ 需要修改模型层和Repository层代码

**技术实现**：
```cpp
// Post模型
class Post {
private:
    std::string userLogicalId_;  // 现有：用户逻辑ID
    std::string username_;       // 🆕 新增：用户昵称
};

// Repository查询SQL
SELECT 
  p.id, p.post_id, p.user_id, p.title, p.description, ...,
  COALESCE(u.user_id, '') AS user_logical_id,
  COALESCE(u.username, '') AS username  -- 🆕 新增
FROM posts p
LEFT JOIN users u ON p.user_id = u.id
WHERE p.post_id = ?
```

#### 方案B：在Handler层单独查询用户信息

**实施方式**：
1. PostHandler::handleGetPostDetail()先查询帖子
2. 再根据post.getUserId()查询用户信息
3. 手动拼接JSON返回

**优点**：
- ✅ 模型层改动小
- ✅ 数据不冗余

**缺点**：
- ❌ 性能差，需要2次数据库查询
- ❌ 代码逻辑分散在Handler层，不符合架构设计
- ❌ 每个返回Post的接口都需要重复实现

**结论**：不推荐

### 3.2 选定方案：方案A

**理由**：
1. **架构一致性**：与v2.5.0 Feed流优化方案保持一致（Feed流已在Post中包含author信息）
2. **性能优先**：一次SQL查询解决问题，避免N+1查询
3. **用户体验**：减少前端HTTP请求，提升加载速度
4. **可扩展性**：未来可以继续添加avatar_url等用户字段（与Feed流的author字段保持一致）

---

## 四、实施步骤

### 阶段1：模型层（Post）- 添加username字段

**文件**：`src/models/post.h`

#### Step 1.1：添加私有成员变量

```cpp
class Post {
private:
    int id_;
    std::string postId_;
    int userId_;                    // 物理ID（内部使用）
    std::string userLogicalId_;     // 逻辑ID（返回前端）
    std::string username_;          // 🆕 新增：用户昵称
    std::string title_;
    std::string description_;
    // ... 其他字段
};
```

#### Step 1.2：添加Getter和Setter

```cpp
public:
    // Getter
    const std::string& getUsername() const { return username_; }
    
    // Setter
    void setUsername(const std::string& username) { username_ = username; }
```

**文件**：`src/models/post.cpp`

#### Step 1.3：修改toJson()方法

**当前代码**（第37-68行）：
```cpp
Json::Value Post::toJson(bool includeImages) const {
    Json::Value json;

    json["id"] = id_;
    json["post_id"] = postId_;
    json["user_id"] = userLogicalId_;  // 逻辑ID
    json["title"] = title_;
    json["description"] = description_;
    json["image_count"] = imageCount_;
    // ... 其他字段
    
    if (includeImages && !images_.empty()) {
        Json::Value imagesArray(Json::arrayValue);
        for (const auto& image : images_) {
            imagesArray.append(image.toJson());
        }
        json["images"] = imagesArray;
    }
    
    return json;
}
```

**修改后**（新增第6行）：
```cpp
Json::Value Post::toJson(bool includeImages) const {
    Json::Value json;

    json["id"] = id_;
    json["post_id"] = postId_;
    json["user_id"] = userLogicalId_;
    json["username"] = username_;  // 🆕 新增：返回用户昵称
    json["title"] = title_;
    json["description"] = description_;
    json["image_count"] = imageCount_;
    // ... 其他字段
    
    if (includeImages && !images_.empty()) {
        Json::Value imagesArray(Json::arrayValue);
        for (const auto& image : images_) {
            imagesArray.append(image.toJson());
        }
        json["images"] = imagesArray;
    }
    
    return json;
}
```

#### Step 1.4：修改fromJson()方法（可选，用于向后兼容）

**当前代码**（第72-127行）：
```cpp
Post Post::fromJson(const Json::Value& j) {
    Post post;
    
    if (j.isMember("id") && j["id"].isInt()) {
        post.id_ = j["id"].asInt();
    }
    
    if (j.isMember("post_id") && j["post_id"].isString()) {
        post.postId_ = j["post_id"].asString();
    }
    
    if (j.isMember("user_id")) {
        if (j["user_id"].isInt()) {
            post.userId_ = j["user_id"].asInt();
        } else if (j["user_id"].isString()) {
            post.userLogicalId_ = j["user_id"].asString();
        }
    }
    
    // ... 其他字段解析
    
    return post;
}
```

**修改后**（新增username解析）：
```cpp
Post Post::fromJson(const Json::Value& j) {
    Post post;
    
    // ... 现有字段解析 ...
    
    if (j.isMember("user_id")) {
        if (j["user_id"].isInt()) {
            post.userId_ = j["user_id"].asInt();
        } else if (j["user_id"].isString()) {
            post.userLogicalId_ = j["user_id"].asString();
        }
    }
    
    // 🆕 新增：解析username字段
    if (j.isMember("username") && j["username"].isString()) {
        post.username_ = j["username"].asString();
    }
    
    // ... 其他字段解析 ...
    
    return post;
}
```

---

### 阶段2：Repository层 - 修改SQL查询

**文件**：`src/database/post_repository.cpp`

#### Step 2.1：修改findByPostId()方法

**位置**：第249-401行

**当前SQL查询**（第264-272行）：
```cpp
const char* query =
    "SELECT "
    "  p.id, p.post_id, p.user_id, p.title, p.description, "
    "  p.image_count, p.like_count, p.favorite_count, p.view_count, "
    "  p.status, p.create_time, p.update_time, "
    "  COALESCE(u.user_id, '') AS user_logical_id "
    "FROM posts p "
    "LEFT JOIN users u ON p.user_id = u.id "
    "WHERE p.post_id = ?";
```

**修改后**（新增username字段）：
```cpp
const char* query =
    "SELECT "
    "  p.id, p.post_id, p.user_id, p.title, p.description, "
    "  p.image_count, p.like_count, p.favorite_count, p.view_count, "
    "  p.status, p.create_time, p.update_time, "
    "  COALESCE(u.user_id, '') AS user_logical_id, "
    "  COALESCE(u.username, '') AS username "  // 🆕 新增
    "FROM posts p "
    "LEFT JOIN users u ON p.user_id = u.id "
    "WHERE p.post_id = ?";
```

**当前结果绑定**（第297-299行）：
```cpp
// 准备结果绑定（13个字段：原12个 + user_logical_id）
MYSQL_BIND result[13];
memset(result, 0, sizeof(result));
```

**修改后**（新增username绑定）：
```cpp
// 准备结果绑定（14个字段：原12个 + user_logical_id + username）
MYSQL_BIND result[14];
memset(result, 0, sizeof(result));
```

**当前变量声明**（第301-316行）：
```cpp
// 定义变量存储结果
long long id;
char post_id[37] = {0};
long long userId;
char title[256] = {0};
char description[1024] = {0};
int imageCount;
int likeCount;
int favoriteCount;
int viewCount;
char status[20] = {0};
long long createTime;
long long updateTime;
char user_logical_id[37] = {0};  // 新增字段
```

**修改后**（新增username变量）：
```cpp
// 定义变量存储结果
long long id;
char post_id[37] = {0};
long long userId;
char title[256] = {0};
char description[1024] = {0};
int imageCount;
int likeCount;
int favoriteCount;
int viewCount;
char status[20] = {0};
long long createTime;
long long updateTime;
char user_logical_id[37] = {0};
char username[51] = {0};  // 🆕 新增（与数据库VARCHAR(50)保持一致）
```

**当前结果绑定代码**（第318-380行，需要添加第14个字段绑定）：
```cpp
// 绑定结果字段（13个字段）
result[0].buffer_type = MYSQL_TYPE_LONGLONG;
result[0].buffer = (char*)&id;

result[1].buffer_type = MYSQL_TYPE_STRING;
result[1].buffer = post_id;
result[1].buffer_length = sizeof(post_id);

// ... 其他字段绑定 ...

result[12].buffer_type = MYSQL_TYPE_STRING;
result[12].buffer = user_logical_id;
result[12].buffer_length = sizeof(user_logical_id);
```

**修改后**（新增第14个字段绑定）：
```cpp
// 绑定结果字段（14个字段）
result[0].buffer_type = MYSQL_TYPE_LONGLONG;
result[0].buffer = (char*)&id;

result[1].buffer_type = MYSQL_TYPE_STRING;
result[1].buffer = post_id;
result[1].buffer_length = sizeof(post_id);

// ... 其他字段绑定 ...

result[12].buffer_type = MYSQL_TYPE_STRING;
result[12].buffer = user_logical_id;
result[12].buffer_length = sizeof(user_logical_id);

// 🆕 新增：绑定username字段
result[13].buffer_type = MYSQL_TYPE_STRING;
result[13].buffer = username;
result[13].buffer_length = sizeof(username);
```

**当前Post对象构建**（第388-401行）：
```cpp
Post post;
post.setId(id);
post.setPostId(post_id);
post.setUserId(userId);
post.setUserLogicalId(user_logical_id);  // 设置逻辑ID
post.setTitle(title);
post.setDescription(description);
post.setImageCount(imageCount);
post.setLikeCount(likeCount);
post.setFavoriteCount(favoriteCount);
post.setViewCount(viewCount);
post.setStatus(Post::stringToStatus(status));
post.setCreateTime(createTime);
post.setUpdateTime(updateTime);

return post;
```

**修改后**（新增setUsername调用）：
```cpp
Post post;
post.setId(id);
post.setPostId(post_id);
post.setUserId(userId);
post.setUserLogicalId(user_logical_id);
post.setUsername(username);  // 🆕 新增：设置用户昵称
post.setTitle(title);
post.setDescription(description);
post.setImageCount(imageCount);
post.setLikeCount(likeCount);
post.setFavoriteCount(favoriteCount);
post.setViewCount(viewCount);
post.setStatus(Post::stringToStatus(status));
post.setCreateTime(createTime);
post.setUpdateTime(updateTime);

return post;
```

#### Step 2.2：修改findByPostIdWithImages()方法

**位置**：第403-697行

**需要进行与Step 2.1相同的修改**：
1. SQL查询新增`username`字段（第418-426行）
2. 结果绑定数组改为`MYSQL_BIND result[14]`（第443行）
3. 新增`username`变量声明（第462行后）
4. 新增第14个字段绑定（result[13]，第533行后）
5. Post对象构建新增`post.setUsername(username)`（第553行后）

**具体修改代码**：

**SQL查询修改**（第418-426行）：
```cpp
const char* query =
    "SELECT "
    "  p.id, p.post_id, p.user_id, p.title, p.description, "
    "  p.image_count, p.like_count, p.favorite_count, p.view_count, "
    "  p.status, p.create_time, p.update_time, "
    "  COALESCE(u.user_id, '') AS user_logical_id, "
    "  COALESCE(u.username, '') AS username "  // 🆕 新增
    "FROM posts p "
    "LEFT JOIN users u ON p.user_id = u.id "
    "WHERE p.post_id = ?";
```

**后续绑定和构建逻辑与Step 2.1完全一致**，不再重复。

---

### 阶段3：Service层 - 无需修改

**说明**：
- `PostService::getPostDetail()`方法仅调用`PostRepository`并返回结果
- Repository已返回包含`username`的Post对象，Service层无需额外处理
- **透传数据，不需要修改任何代码**

---

### 阶段4：API层 - 无需修改

**说明**：
- `PostHandler::handleGetPostDetail()`方法调用`postService_->getPostDetail()`
- 使用`postToJson(post, true)`将Post对象转换为JSON
- `Post::toJson()`已在阶段1修改，自动包含`username`字段
- **不需要修改任何Handler代码**

---

### 阶段5：编译和测试

#### Step 5.1：编译项目

```bash
cd /home/kun/projects/SharePix/backend-service
rm -rf build && mkdir build
cd build
cmake ..
make -j4
```

**预期结果**：编译成功，无错误

#### Step 5.2：启动服务

```bash
cd /home/kun/projects/SharePix/backend-service
./build/knot_image_sharing config/config.json
```

#### Step 5.3：手动测试

**测试1：创建帖子后查看详情**

```bash
# 1. 登录获取Token
curl -X POST http://localhost:8080/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"phone":"13800138000","password":"password123"}'
# 返回: {"access_token":"xxx"}

# 2. 创建帖子（假设已有帖子POST_2025Q4_ABC123）

# 3. 查看帖子详情
curl -X GET http://localhost:8080/api/v1/posts/POST_2025Q4_ABC123

# 预期返回：
{
  "success": true,
  "message": "查询成功",
  "data": {
    "post": {
      "post_id": "POST_2025Q4_ABC123",
      "user_id": "USR_2025Q4_DEF456",
      "username": "alice_photo",  ✅ 新增字段
      "title": "美丽的日落",
      "description": "今天的日落真美",
      ...
    }
  }
}
```

**测试2：验证向后兼容性**

```bash
# 使用旧版本前端代码（只读取user_id字段）
# 确认接口依然正常工作，不会因新增字段导致问题
```

---

## 五、测试验证

### 5.1 单元测试用例

| 测试用例 | 测试内容 | 预期结果 |
|---------|---------|---------|
| 测试1 | Post模型toJson()包含username | JSON中存在username字段 |
| 测试2 | findByPostId()查询结果 | Post对象的username字段非空 |
| 测试3 | findByPostIdWithImages()查询结果 | Post对象的username字段非空 |
| 测试4 | 用户不存在的帖子 | username返回空字符串（不是null） |

### 5.2 集成测试用例

| 测试用例 | 接口 | 测试方法 | 预期结果 |
|---------|------|---------|---------|
| 测试5 | GET /api/v1/posts/:post_id | 查询已存在的帖子 | 返回JSON包含username字段 |
| 测试6 | POST /api/v1/posts | 创建帖子后查看返回 | 返回JSON包含username字段 |
| 测试7 | PUT /api/v1/posts/:post_id | 更新帖子后查看返回 | 返回JSON包含username字段 |

### 5.3 性能测试

**测试场景**：并发查询帖子详情100次

**测试指标**：
- 平均响应时间应 < 50ms（与优化前相同）
- 数据库查询次数：1次（确认没有额外查询）
- SQL查询时间：LEFT JOIN不应显著增加查询时间（<5ms）

**测试命令**：
```bash
# 使用Apache Bench进行并发测试
ab -n 100 -c 10 -H "Authorization: Bearer YOUR_TOKEN" \
   http://localhost:8080/api/v1/posts/POST_2025Q4_ABC123
```

### 5.4 数据一致性测试

| 测试场景 | 测试方法 | 预期结果 |
|---------|---------|---------|
| 用户修改昵称后 | 修改users.username，再查询帖子 | 返回最新的username |
| 用户删除后 | 删除用户记录（如果允许） | username返回空字符串（LEFT JOIN保护） |

---

## 六、风险评估

### 6.1 技术风险

| 风险项 | 风险等级 | 影响 | 缓解措施 |
|-------|---------|------|---------|
| SQL性能下降 | 🟢 低 | LEFT JOIN可能增加查询时间 | users表已有idx_user_id索引，JOIN性能良好 |
| 数据不一致 | 🟢 低 | username缓存在Post对象中 | 实时JOIN查询，保证数据最新 |
| 编译错误 | 🟢 低 | 修改模型层可能引入编译错误 | 严格按照步骤操作，逐步验证 |

### 6.2 业务风险

| 风险项 | 风险等级 | 影响 | 缓解措施 |
|-------|---------|------|---------|
| API不兼容 | 🟢 低 | 前端可能未处理新字段 | 新增字段向后兼容，不影响旧版本前端 |
| 用户昵称为空 | 🟡 中 | 用户数据异常导致username为空 | 使用COALESCE返回空字符串，前端需判断处理 |

### 6.3 回滚方案

如果发现严重问题，可以快速回滚：

**Step 1：恢复Post模型**
```bash
git checkout HEAD -- src/models/post.h src/models/post.cpp
```

**Step 2：恢复Repository层**
```bash
git checkout HEAD -- src/database/post_repository.cpp
```

**Step 3：重新编译**
```bash
cd build && make -j4
```

**时间成本**：< 5分钟

---

## 七、文档更新清单

### 7.1 需要更新的文档

| 文档 | 文件路径 | 更新内容 | 优先级 |
|-----|---------|---------|--------|
| API文档 | `[000]API文档.md` | 更新"获取帖子详情"接口的返回示例 | 🔴 高 |
| 数据库设计文档 | `[001]数据库设计文档.md` | 说明Post模型包含username字段 | 🟡 中 |
| 项目架构文档 | `[002]项目架构文档.md` | 更新Post模型字段说明 | 🟡 中 |
| README | `backend-service/README.md` | 更新API版本历史（v2.5.1） | 🟡 中 |
| CLAUDE.md | `.cursor/CLAUDE.md` | 更新API版本历史 | 🟡 中 |

### 7.2 API文档更新示例

**[000]API文档.md** - "获取帖子详情"章节（约第1100行）

**当前返回示例**：
```json
{
  "success": true,
  "message": "查询成功",
  "data": {
    "post": {
      "post_id": "POST_2025Q4_8H9J2K3L",
      "user_id": "USR_2025Q4_1A2B3C4D",
      "title": "美丽的日落",
      "description": "今天的日落真美",
      ...
    }
  }
}
```

**更新后**（新增username字段说明）：
```json
{
  "success": true,
  "message": "查询成功",
  "data": {
    "post": {
      "post_id": "POST_2025Q4_8H9J2K3L",
      "user_id": "USR_2025Q4_1A2B3C4D",
      "username": "alice_photo",  // 🆕 v2.5.1新增：发帖用户昵称
      "title": "美丽的日落",
      "description": "今天的日落真美",
      ...
    }
  }
}
```

**返回字段说明表**（新增一行）：
| 字段名 | 类型 | 说明 | 版本 |
|-------|------|------|------|
| post_id | string | 帖子业务ID | v2.0.0 |
| user_id | string | 发帖用户逻辑ID | v2.0.0 |
| username | string | 发帖用户昵称 | 🆕 v2.5.1 |
| title | string | 帖子标题 | v2.0.0 |
| ... | ... | ... | ... |

---

## 八、实施时间表

| 阶段 | 任务 | 预计时间 | 负责人 |
|-----|------|---------|--------|
| 阶段1 | Post模型修改 | 15分钟 | 开发者 |
| 阶段2 | Repository层修改 | 30分钟 | 开发者 |
| 阶段3 | 编译和本地测试 | 15分钟 | 开发者 |
| 阶段4 | 集成测试 | 20分钟 | QA |
| 阶段5 | 文档更新 | 20分钟 | 开发者 |
| **总计** | | **100分钟（1.5小时）** | |

---

## 九、总结

### 9.1 技术亮点

1. ✅ **性能优化**：一次SQL查询返回完整信息，避免N+1查询问题
2. ✅ **架构一致**：与v2.5.0 Feed流优化保持一致的设计思路
3. ✅ **向后兼容**：新增字段不影响现有前端，渐进式升级
4. ✅ **用户体验**：减少HTTP请求，提升帖子详情页加载速度

### 9.2 实施成本

- **代码修改量**：约150行（模型层30行 + Repository层120行）
- **测试工作量**：约20分钟（手动测试 + 性能验证）
- **文档更新量**：约30分钟（API文档、架构文档）
- **总时间成本**：约1.5小时

### 9.3 预期收益

- **用户体验**：帖子详情页加载速度提升~50%（减少1次HTTP请求）
- **开发体验**：前端无需额外请求用户信息接口，代码更简洁
- **API一致性**：与Feed流接口保持一致，降低前端理解成本

---

## 附录A：相关文档

- `[105]阶段C-2-多图片帖子系统.md` - Post模型设计文档
- `[117]帖子接口用户ID逻辑化改造方案.md` - 用户ID逻辑化改造参考
- `[118]Feed流用户状态批量查询优化方案.md` - Feed流包含author信息的实现参考

---

**文档结束**

