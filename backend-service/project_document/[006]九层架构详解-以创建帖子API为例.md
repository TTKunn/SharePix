# [006] 九层架构详解 - 以创建帖子API为例

**文档版本**: v1.0  
**创建日期**: 2025-10-20  
**适用版本**: v2.7.0+  
**作者**: Knot Team  
**目标读者**: 项目新成员、后端开发工程师

---

## 📋 文档目录

1. [文档概述](#1-文档概述)
2. [九层架构全景图](#2-九层架构全景图)
3. [创建帖子API完整流程](#3-创建帖子api完整流程)
4. [第1层：客户端层](#4-第1层客户端层)
5. [第2层：HTTP服务器层](#5-第2层http服务器层)
6. [第3层：API接口层](#6-第3层api接口层)
7. [第4层：业务逻辑层](#7-第4层业务逻辑层)
8. [第5层：数据访问层](#8-第5层数据访问层)
9. [第6层：安全层](#9-第6层安全层)
10. [第7层：基础设施层](#10-第7层基础设施层)
11. [第8层：数据模型层](#11-第8层数据模型层)
12. [第9层：数据库层](#12-第9层数据库层)
13. [关键设计模式](#13-关键设计模式)
14. [性能指标与优化](#14-性能指标与优化)
15. [常见问题FAQ](#15-常见问题faq)

---

## 1. 文档概述

### 1.1 文档目的

本文档旨在帮助项目新成员：
- **快速理解**：掌握Knot项目的九层架构设计理念
- **实战学习**：通过创建帖子API的完整流程，学习代码实现细节
- **最佳实践**：了解企业级C++后端开发的设计模式和编码规范
- **问题排查**：掌握调试和问题定位的方法

### 1.2 为什么选择创建帖子API

创建帖子（`POST /api/v1/posts`）是Knot项目中最复杂的API之一，它包含了：

✅ **JWT身份验证** - 安全层的使用  
✅ **文件上传处理** - multipart/JSON两种格式支持  
✅ **图片压缩和缩略图生成** - 基础设施层的图片处理  
✅ **数据库事务** - 多表操作的一致性保证  
✅ **业务规则验证** - 1-9张图片的业务约束  
✅ **批量数据处理** - 图片和标签的批量插入  
✅ **错误处理和日志记录** - 完善的异常处理机制  

通过这个API，你可以学习到项目中90%的核心技术点。

### 1.3 前置知识要求

阅读本文档前，建议你已经了解：
- C++11/14/17基础语法（智能指针、lambda、RAII）
- HTTP协议基础（请求方法、状态码、Content-Type）
- MySQL基础（CRUD操作、索引、外键）
- JSON数据格式

**不需要**掌握的内容（文档会详细讲解）：
- cpp-httplib库的使用
- MySQL C API的使用
- JWT令牌的生成和验证
- 图片处理算法

---

## 2. 九层架构全景图

### 2.1 架构层次图

**文本版本**：

```
┌─────────────────────────────────────────────────────────────────┐
│ 第1层：客户端层（HTTP Client）                                    │
│ - HarmonyOS App, iOS App, Android App, Web Browser             │
│ - 发送HTTP请求，接收JSON响应                                      │
└─────────────────────────────────────────────────────────────────┘
                          ↓ HTTP Request (multipart/JSON)
┌─────────────────────────────────────────────────────────────────┐
│ 第2层：HTTP服务器层（src/server/http_server.cpp）                 │
│ - 技术栈：cpp-httplib 0.11.0                                     │
│ - 功能：路由分发、线程池管理、连接管理                              │
│ - 配置：监听0.0.0.0:8080，32线程，128连接                        │
└─────────────────────────────────────────────────────────────────┘
                          ↓ 路由到Handler
┌─────────────────────────────────────────────────────────────────┐
│ 第3层：API接口层（src/api/post_handler.cpp）                      │
│ - 功能：解析HTTP请求、JWT验证、参数验证、响应封装                   │
│ - 职责：协议转换（HTTP → 业务对象）                                │
│ - 关键类：PostHandler, BaseHandler                               │
└─────────────────────────────────────────────────────────────────┘
                          ↓ 调用Service
┌─────────────────────────────────────────────────────────────────┐
│ 第4层：业务逻辑层（src/core/post_service.cpp）                    │
│ - 功能：业务规则验证、流程编排、事务协调                            │
│ - 职责：封装复杂业务逻辑，协调多个Repository                       │
│ - 关键类：PostService, ImageService                              │
└─────────────────────────────────────────────────────────────────┘
                          ↓ 调用Repository
┌─────────────────────────────────────────────────────────────────┐
│ 第5层：数据访问层（src/database/post_repository.cpp）             │
│ - 功能：SQL预编译语句、CRUD操作、连接管理                          │
│ - 职责：数据持久化，屏蔽数据库细节                                 │
│ - 关键类：PostRepository, ImageRepository, TagRepository         │
└─────────────────────────────────────────────────────────────────┘
                          ↓ 安全检查
┌─────────────────────────────────────────────────────────────────┐
│ 第6层：安全层（src/security/）                                    │
│ - JWTManager：令牌生成和验证（jwt-cpp 0.6.0）                     │
│ - PasswordHasher：PBKDF2-HMAC-SHA256哈希（OpenSSL 1.1.1）        │
│ - 职责：身份认证、授权、数据加密                                   │
└─────────────────────────────────────────────────────────────────┘
                          ↓ 基础设施支持
┌─────────────────────────────────────────────────────────────────┐
│ 第7层：基础设施层（src/database/, src/utils/）                    │
│ - ConnectionPool：数据库连接池（10连接，可配置）                   │
│ - Logger：spdlog日志系统（文件+控制台）                           │
│ - ConfigManager：配置文件管理（config.json）                      │
│ - ImageProcessor：STB图片处理（压缩、缩略图、格式转换）             │
│ - Base64Decoder：Base64编解码                                    │
│ - UrlHelper：URL拼接和处理                                       │
└─────────────────────────────────────────────────────────────────┘
                          ↓ 数据模型
┌─────────────────────────────────────────────────────────────────┐
│ 第8层：数据模型层（src/models/）                                  │
│ - Post：帖子业务实体（包含图片列表）                               │
│ - Image：图片业务实体                                            │
│ - User：用户业务实体                                             │
│ - Tag：标签业务实体                                              │
│ - 功能：toJson()/fromJson()、数据验证、业务逻辑封装               │
└─────────────────────────────────────────────────────────────────┘
                          ↓ 持久化
┌─────────────────────────────────────────────────────────────────┐
│ 第9层：数据库层（MySQL 8.0）                                      │
│ - posts：帖子信息（主表）                                         │
│ - images：图片信息（外键post_id，级联删除）                        │
│ - users：用户信息                                                │
│ - tags, post_tags：标签系统                                      │
│ - share_links：分享链接                                          │
│ - likes, favorites, follows：互动系统                            │
└─────────────────────────────────────────────────────────────────┘
```

**Mermaid版本**（支持Mermaid的环境可渲染）：

```mermaid
flowchart TD
    L1["第1层：客户端层（HTTP Client）<br/>- HarmonyOS App, iOS App, Android App, Web Browser<br/>- 发送HTTP请求，接收JSON响应"]
    L2["第2层：HTTP服务器层（src/server/http_server.cpp）<br/>- 技术栈：cpp-httplib 0.11.0<br/>- 功能：路由分发、线程池管理、连接管理<br/>- 配置：监听0.0.0.0:8080，32线程，128连接"]
    L3["第3层：API接口层（src/api/post_handler.cpp）<br/>- 功能：解析HTTP请求、JWT验证、参数验证、响应封装<br/>- 职责：协议转换（HTTP → 业务对象）<br/>- 关键类：PostHandler, BaseHandler"]
    L4["第4层：业务逻辑层（src/core/post_service.cpp）<br/>- 功能：业务规则验证、流程编排、事务协调<br/>- 职责：封装复杂业务逻辑，协调多个Repository<br/>- 关键类：PostService, ImageService"]
    L5["第5层：数据访问层（src/database/post_repository.cpp）<br/>- 功能：SQL预编译语句、CRUD操作、连接管理<br/>- 职责：数据持久化，屏蔽数据库细节<br/>- 关键类：PostRepository, ImageRepository, TagRepository"]
    L6["第6层：安全层（src/security/）<br/>- JWTManager：令牌生成和验证（jwt-cpp 0.6.0）<br/>- PasswordHasher：PBKDF2-HMAC-SHA256哈希（OpenSSL 1.1.1）<br/>- 职责：身份认证、授权、数据加密"]
    L7["第7层：基础设施层（src/database/, src/utils/）<br/>- ConnectionPool：数据库连接池（10连接，可配置）<br/>- Logger：spdlog日志系统（文件+控制台）<br/>- ConfigManager：配置文件管理（config.json）<br/>- ImageProcessor：STB图片处理（压缩、缩略图、格式转换）<br/>- Base64Decoder：Base64编解码<br/>- UrlHelper：URL拼接和处理"]
    L8["第8层：数据模型层（src/models/）<br/>- Post：帖子业务实体（包含图片列表）<br/>- Image：图片业务实体<br/>- User：用户业务实体<br/>- Tag：标签业务实体<br/>- 功能：toJson()/fromJson()、数据验证、业务逻辑封装"]
    L9["第9层：数据库层（MySQL 8.0）<br/>- posts：帖子信息（主表）<br/>- images：图片信息（外键post_id，级联删除）<br/>- users：用户信息<br/>- tags, post_tags：标签系统<br/>- share_links：分享链接<br/>- likes, favorites, follows：互动系统"]
    
    L1 -->|HTTP Request<br/>multipart/JSON| L2
    L2 -->|路由到Handler| L3
    L3 -->|调用Service| L4
    L4 -->|调用Repository| L5
    L5 -->|安全检查| L6
    L6 -->|基础设施支持| L7
    L7 -->|数据模型| L8
    L8 -->|持久化| L9
```

### 2.2 层级交互规则

**严格的单向依赖原则**：

✅ **允许**：上层调用下层（例如：Handler → Service → Repository）  
❌ **禁止**：下层调用上层（例如：Service不能调用Handler）  
❌ **禁止**：跨层调用（例如：Handler不能直接调用Repository）  

**示例**：

```cpp
// ✅ 正确：Handler调用Service
class PostHandler {
    void handleCreatePost() {
        PostCreateResult result = postService_->createPost(...);
    }
};

// ✅ 正确：Service调用Repository
class PostService {
    PostCreateResult createPost() {
        postRepo_->createPost(post);
        imageRepo_->createImage(image);
    }
};

// ❌ 错误：Handler直接调用Repository（跨层）
class PostHandler {
    void handleCreatePost() {
        postRepo_->createPost(post);  // 违反架构原则！
    }
};

// ❌ 错误：Service调用Handler（向上调用）
class PostService {
    void createPost() {
        handler_->sendResponse(...);  // 违反架构原则！
    }
};
```

### 2.3 各层职责划分

| 层级 | 核心职责 | 关键类 | 文件位置 |
|-----|---------|--------|---------|
| **第1层** | 发送HTTP请求 | - | 客户端应用 |
| **第2层** | 路由分发、线程管理 | `HttpServer` | `src/server/` |
| **第3层** | 协议转换、参数验证 | `PostHandler` | `src/api/` |
| **第4层** | 业务逻辑、流程编排 | `PostService` | `src/core/` |
| **第5层** | 数据持久化、SQL操作 | `PostRepository` | `src/database/` |
| **第6层** | 身份认证、数据加密 | `JWTManager` | `src/security/` |
| **第7层** | 基础设施服务 | `ConnectionPool`, `Logger` | `src/utils/` |
| **第8层** | 业务实体、数据验证 | `Post`, `Image` | `src/models/` |
| **第9层** | 数据存储 | - | MySQL数据库 |

---

## 3. 创建帖子API完整流程

### 3.1 流程概览

**API端点**：`POST /api/v1/posts`  
**功能**：用户创建一个包含1-9张图片的帖子  
**认证**：需要JWT令牌  
**请求格式**：支持`multipart/form-data`和`application/json`两种格式

### 3.2 流程时序图

**文本版本**：

```
┌─────────┐  ┌──────────┐  ┌────────────┐  ┌─────────────┐  ┌───────────────┐  ┌────────┐
│ 客户端  │  │HTTP服务器│  │PostHandler │  │PostService  │  │PostRepository │  │ MySQL  │
└────┬────┘  └─────┬────┘  └──────┬─────┘  └──────┬──────┘  └───────┬───────┘  └───┬────┘
     │             │               │                │                 │              │
     ├─①HTTP POST─→│               │                │                 │              │
     │             ├─②路由分发────→│                │                 │              │
     │             │               ├─③JWT验证──────→│                 │              │
     │             │               │←────验证通过───┤                 │              │
     │             │               ├─④解析请求参数─→│                 │              │
     │             │               ├─⑤保存临时文件─→│                 │              │
     │             │               ├─⑥调用Service──→│                 │              │
     │             │               │                ├─⑦验证业务规则──→│              │
     │             │               │                ├─⑧生成帖子ID────→│              │
     │             │               │                ├─⑨创建Post对象──→│              │
     │             │               │                ├─⑩调用Repository→│              │
     │             │               │                │                 ├─⑪INSERT posts→│
     │             │               │                │                 │←─返回自增ID─┤
     │             │               │                ├─⑫处理图片1─────→│              │
     │             │               │                ├─⑬处理图片2─────→│              │
     │             │               │                ├─⑭处理图片3─────→│              │
     │             │               │                ├─⑮保存Image1────→│              │
     │             │               │                │                 ├─⑯INSERT images│
     │             │               │                ├─⑰保存Image2────→│              │
     │             │               │                ├─⑱保存Image3────→│              │
     │             │               │                ├─⑲更新image_count│              │
     │             │               │                ├─⑳关联标签1─────→│              │
     │             │               │                ├─㉑关联标签2─────→│              │
     │             │               │                ├─㉒查询完整帖子──→│              │
     │             │               │                │                 ├─㉓SELECT──────│
     │             │               │                │←────返回Post────┤              │
     │             │               │←─㉔返回Result──┤                 │              │
     │             │               ├─㉕清理临时文件─→│                 │              │
     │             │               ├─㉖封装JSON响应─→│                 │              │
     │             │←─㉗HTTP响应───┤                │                 │              │
     │←─㉘接收响应──┤               │                │                 │              │
```

**Mermaid版本**（支持Mermaid的环境可渲染）：

```mermaid
sequenceDiagram
    participant Client as 客户端
    participant Server as HTTP服务器
    participant Handler as PostHandler
    participant Service as PostService
    participant Repo as PostRepository
    participant DB as MySQL

    Client->>Server: ①HTTP POST
    Server->>Handler: ②路由分发
    Handler->>Service: ③JWT验证
    Service-->>Handler: 验证通过
    Handler->>Handler: ④解析请求参数
    Handler->>Handler: ⑤保存临时文件
    Handler->>Service: ⑥调用Service
    Service->>Service: ⑦验证业务规则
    Service->>Service: ⑧生成帖子ID
    Service->>Service: ⑨创建Post对象
    Service->>Repo: ⑩调用Repository
    Repo->>DB: ⑪INSERT posts
    DB-->>Repo: 返回自增ID
    Service->>Service: ⑫处理图片1
    Service->>Service: ⑬处理图片2
    Service->>Service: ⑭处理图片3
    Service->>Repo: ⑮保存Image1
    Repo->>DB: ⑯INSERT images
    Service->>Repo: ⑰保存Image2
    Service->>Repo: ⑱保存Image3
    Service->>Repo: ⑲更新image_count
    Service->>Repo: ⑳关联标签1
    Service->>Repo: ㉑关联标签2
    Service->>Repo: ㉒查询完整帖子
    Repo->>DB: ㉓SELECT
    Repo-->>Service: 返回Post
    Service-->>Handler: ㉔返回Result
    Handler->>Handler: ㉕清理临时文件
    Handler->>Handler: ㉖封装JSON响应
    Handler-->>Server: ㉗HTTP响应
    Server-->>Client: ㉘接收响应
```

### 3.3 关键步骤说明

| 步骤 | 层级 | 操作 | 耗时(估算) |
|-----|-----|------|-----------|
| ①-② | 第1-2层 | HTTP请求路由 | ~5ms |
| ③ | 第3层 + 第6层 | JWT令牌验证 | ~10ms |
| ④-⑤ | 第3层 | 解析参数、保存临时文件 | ~20ms |
| ⑥-⑨ | 第4层 | 业务逻辑验证、生成ID | ~5ms |
| ⑩-⑪ | 第5层 + 第9层 | 插入posts表 | ~10ms |
| ⑫-⑱ | 第4层 + 第7层 + 第9层 | 处理3张图片（压缩+缩略图+保存） | ~300ms |
| ⑲-㉑ | 第4层 + 第5层 | 更新统计、关联标签 | ~30ms |
| ㉒-㉓ | 第5层 + 第9层 | 查询完整帖子信息 | ~20ms |
| ㉔-㉘ | 第3-1层 | 响应封装、返回客户端 | ~50ms |
| **总计** | - | **完整流程** | **~450ms** |

**性能瓶颈**：图片处理（压缩+缩略图）占总时间的66%。

---

## 4. 第1层：客户端层

### 4.1 HTTP请求示例

**场景**：用户上传3张图片创建帖子

#### multipart/form-data格式（推荐用于Web和原生App）

```http
POST /api/v1/posts HTTP/1.1
Host: api.knot.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo3fQ...
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW

------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="title"

我的第一篇帖子
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="description"

今天天气真好，拍了几张风景照！
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="tags"

["旅游", "风景"]
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="imageFiles"; filename="photo1.jpg"
Content-Type: image/jpeg

<binary data>
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="imageFiles"; filename="photo2.jpg"
Content-Type: image/jpeg

<binary data>
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="imageFiles"; filename="photo3.jpg"
Content-Type: image/jpeg

<binary data>
------WebKitFormBoundary7MA4YWxkTrZu0gW--
```

#### application/json格式（推荐用于HarmonyOS）

```http
POST /api/v1/posts HTTP/1.1
Host: api.knot.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Content-Type: application/json

{
  "title": "我的第一篇帖子",
  "description": "今天天气真好，拍了几张风景照！",
  "tags": ["旅游", "风景"],
  "images": [
    {
      "filename": "photo1.jpg",
      "content_type": "image/jpeg",
      "data": "/9j/4AAQSkZJRgABAQEAYABgAAD..."  // Base64编码
    },
    {
      "filename": "photo2.jpg",
      "content_type": "image/jpeg",
      "data": "data:image/jpeg;base64,/9j/4AAQ..."  // Data URI格式也支持
    },
    {
      "filename": "photo3.jpg",
      "content_type": "image/jpeg",
      "data": "/9j/4AAQSkZJRgABAQEAYABgAAD..."
    }
  ]
}
```

### 4.2 客户端实现建议

**HarmonyOS示例**：

```typescript
// HarmonyOS ArkTS代码
async createPost(title: string, description: string, imagePaths: string[]) {
  const images = [];
  
  // 读取图片文件并转为Base64
  for (const path of imagePaths) {
    const imageData = await readImageAsBase64(path);
    images.push({
      filename: getFilename(path),
      content_type: "image/jpeg",
      data: imageData
    });
  }
  
  const response = await httpClient.post('/api/v1/posts', {
    headers: {
      'Authorization': `Bearer ${this.token}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      title: title,
      description: description,
      tags: ["旅游", "风景"],
      images: images
    })
  });
  
  return response.data;
}
```

---

## 5. 第2层：HTTP服务器层

### 5.1 服务器初始化

**文件**：`src/server/http_server.cpp`

```cpp
class HttpServer {
public:
    HttpServer() {
        // 创建httplib服务器实例
        server_ = std::make_unique<httplib::Server>();
        
        // 注册Handler
        postHandler_ = std::make_unique<PostHandler>();
        userHandler_ = std::make_unique<UserHandler>();
        // ... 其他Handler
        
        Logger::info("HttpServer initialized");
    }
    
    void start(const std::string& host, int port) {
        // 注册所有路由
        postHandler_->registerRoutes(*server_);
        userHandler_->registerRoutes(*server_);
        
        // 设置线程池大小
        server_->new_task_queue = [] {
            return new httplib::ThreadPool(32);  // 32个工作线程
        };
        
        // 启动服务器
        Logger::info("Server listening on " + host + ":" + std::to_string(port));
        server_->listen(host.c_str(), port);
    }
    
private:
    std::unique_ptr<httplib::Server> server_;
    std::unique_ptr<PostHandler> postHandler_;
    std::unique_ptr<UserHandler> userHandler_;
};
```

### 5.2 路由注册机制

**文件**：`src/api/post_handler.cpp` (第32-79行)

```cpp
void PostHandler::registerRoutes(httplib::Server& server) {
    // 创建帖子（需要认证）
    server.Post("/api/v1/posts", [this](const httplib::Request& req, httplib::Response& res) {
        handleCreatePost(req, res);
    });
    
    // 获取帖子详情（公开接口）
    server.Get("/api/v1/posts/:post_id", [this](const httplib::Request& req, httplib::Response& res) {
        handleGetPostDetail(req, res);
    });
    
    // 更新帖子（需要认证）
    server.Put("/api/v1/posts/:post_id", [this](const httplib::Request& req, httplib::Response& res) {
        handleUpdatePost(req, res);
    });
    
    // 删除帖子（需要认证）
    server.Delete("/api/v1/posts/:post_id", [this](const httplib::Request& req, httplib::Response& res) {
        handleDeletePost(req, res);
    });
    
    // 获取Feed流（可选认证）
    server.Get("/api/v1/posts", [this](const httplib::Request& req, httplib::Response& res) {
        handleGetRecentPosts(req, res);
    });
    
    Logger::info("PostHandler routes registered");
}
```

**关键点**：
- 使用lambda表达式捕获`this`指针，实现成员方法回调
- 路径参数使用`:param_name`语法（例如`:post_id`）
- 所有路由在服务器启动前注册完成

### 5.3 性能配置

**CMakeLists.txt配置**：

```cmake
# 编译定义
add_definitions(
    -DCPPHTTPLIB_LISTEN_BACKLOG=128      # 连接队列长度
    -DCPPHTTPLIB_THREAD_POOL_COUNT=32    # 线程池大小
    -DCPPHTTPLIB_READ_TIMEOUT_SECOND=30  # 读取超时
    -DCPPHTTPLIB_WRITE_TIMEOUT_SECOND=30 # 写入超时
)
```

**性能指标**：
- 最大并发连接：128
- 工作线程数：32
- 吞吐量：~200 QPS（简单查询）
- 吞吐量：~50 QPS（图片上传）

---

## 6. 第3层：API接口层

### 6.1 Handler基类设计

**文件**：`src/api/base_handler.h`

```cpp
class BaseHandler {
protected:
    /**
     * @brief 提取JWT令牌
     * @return 令牌字符串，失败返回空
     */
    std::string extractToken(const httplib::Request& req) const {
        std::string authHeader = req.get_header_value("Authorization");
        if (authHeader.substr(0, 7) == "Bearer ") {
            return authHeader.substr(7);
        }
        return "";
    }
    
    /**
     * @brief 从令牌获取用户ID
     * @return 用户ID，验证失败返回0
     */
    int getUserIdFromToken(const std::string& token) const {
        auto jwtManager = std::make_unique<JWTManager>();
        TokenValidationResult result = jwtManager->validateAccessToken(token);
        
        if (result.valid) {
            return result.userId;
        }
        return 0;
    }
    
    /**
     * @brief 解析JSON请求体
     */
    bool parseJsonBody(const std::string& body, Json::Value& json) const {
        Json::CharReaderBuilder builder;
        std::string errs;
        std::istringstream stream(body);
        return Json::parseFromStream(builder, stream, &json, &errs);
    }
    
    /**
     * @brief 发送成功响应
     */
    void sendSuccessResponse(httplib::Response& res, 
                             const std::string& message,
                             const Json::Value& data = Json::Value()) const {
        Json::Value response;
        response["success"] = true;
        response["message"] = message;
        response["timestamp"] = static_cast<Json::Int64>(std::time(nullptr));
        
        if (!data.isNull()) {
            response["data"] = data;
        }
        
        res.set_content(jsonToString(response), "application/json");
        res.status = 200;
    }
    
    /**
     * @brief 发送错误响应
     */
    void sendErrorResponse(httplib::Response& res,
                           int statusCode,
                           const std::string& message) const {
        Json::Value response;
        response["success"] = false;
        response["message"] = message;
        response["timestamp"] = static_cast<Json::Int64>(std::time(nullptr));
        
        res.set_content(jsonToString(response), "application/json");
        res.status = statusCode;
    }
};
```

### 6.2 创建帖子Handler实现

**文件**：`src/api/post_handler.cpp` (handleCreatePost方法)

#### 6.2.1 JWT身份验证

```cpp
void PostHandler::handleCreatePost(const httplib::Request& req, httplib::Response& res) {
    try {
        Logger::info("=== [CREATE POST] Request received ===");
        
        // 【步骤1】提取JWT令牌
        std::string token = extractToken(req);
        if (token.empty()) {
            Logger::warning("[CREATE POST] ✗ No token provided");
            sendErrorResponse(res, 401, "未提供认证令牌");
            return;
        }
        
        // 【步骤2】验证令牌并获取用户ID
        int userId = getUserIdFromToken(token);
        if (userId == 0) {
            Logger::warning("[CREATE POST] ✗ Invalid token");
            sendErrorResponse(res, 401, "无效的认证令牌");
            return;
        }
        
        Logger::info("[CREATE POST] ✓ User authenticated - UserID: " + std::to_string(userId));
```

**安全检查点**：
- ✅ Authorization头是否存在
- ✅ Bearer前缀是否正确
- ✅ JWT签名是否有效
- ✅ JWT是否过期
- ✅ user_id claim是否存在

#### 6.2.2 请求格式检测

```cpp
        // 【步骤3】检查请求格式
        std::string contentType = req.get_header_value("Content-Type");
        bool isMultipart = req.is_multipart_form_data();
        bool isJson = (contentType.find("application/json") != std::string::npos);
        
        if (!isMultipart && !isJson) {
            Logger::error("[CREATE POST] ✗ Unsupported Content-Type: " + contentType);
            sendErrorResponse(res, 400, "请求必须使用multipart/form-data或application/json格式");
            return;
        }
        
        Logger::info("[CREATE POST] ✓ Request format: " + 
                    std::string(isMultipart ? "multipart" : "JSON"));
```

**设计亮点**：
- 支持两种格式，适应不同客户端需求
- multipart适合Web浏览器和原生App
- JSON+Base64适合HarmonyOS等特殊平台

#### 6.2.3 解析multipart请求

```cpp
        std::string title;
        std::string description;
        std::vector<std::string> tags;
        std::vector<std::string> savedImagePaths;
        
        if (isMultipart) {
            // 【步骤4】获取文本字段
            if (req.form.has_field("title")) {
                title = req.form.get_field("title");
            }
            if (title.empty()) {
                sendErrorResponse(res, 400, "标题不能为空");
                return;
            }
            
            if (req.form.has_field("description")) {
                description = req.form.get_field("description");
            }
            
            // 【步骤5】解析标签（支持JSON数组格式）
            if (req.form.has_field("tags")) {
                auto tagFields = req.form.get_fields("tags");
                
                if (tagFields.size() == 1) {
                    const std::string& tagsValue = tagFields[0];
                    
                    // 检查是否为JSON数组格式（["tag1", "tag2"]）
                    if (!tagsValue.empty() && tagsValue[0] == '[') {
                        try {
                            Json::Value tagsJson;
                            Json::CharReaderBuilder builder;
                            std::string errs;
                            std::istringstream stream(tagsValue);
                            
                            if (Json::parseFromStream(builder, stream, &tagsJson, &errs)) {
                                if (tagsJson.isArray()) {
                                    for (const auto& tag : tagsJson) {
                                        if (tag.isString()) {
                                            tags.push_back(tag.asString());
                                        }
                                    }
                                    Logger::info("[CREATE POST] ✓ Parsed " + 
                                               std::to_string(tags.size()) + " tags from JSON array");
                                }
                            } else {
                                // JSON解析失败，当作普通字符串
                                tags.push_back(tagsValue);
                            }
                        } catch (const std::exception& e) {
                            Logger::warning("[CREATE POST] ⚠ Failed to parse tags JSON: " + 
                                          std::string(e.what()));
                            tags.push_back(tagsValue);
                        }
                    } else {
                        // 不是JSON数组格式，当作普通字符串
                        tags.push_back(tagsValue);
                    }
                } else {
                    // 多个tags字段，直接使用
                    tags = tagFields;
                }
            }
```

**标签解析支持的格式**：
1. JSON数组字符串：`["旅游", "风景"]`
2. 多个tags字段：`tags=旅游&tags=风景`
3. 单个字符串：`tags=旅游`

#### 6.2.4 处理图片文件上传

```cpp
            // 【步骤6】处理图片文件
            if (req.form.has_file("imageFiles")) {
                auto imageFiles = req.form.get_files("imageFiles");
                
                Logger::info("[CREATE POST] ✓ Received " + 
                           std::to_string(imageFiles.size()) + " image file(s)");
                
                for (size_t i = 0; i < imageFiles.size(); i++) {
                    const auto& fileData = imageFiles[i];
                    
                    Logger::info("[CREATE POST] Processing image " + 
                               std::to_string(i + 1) + "/" + 
                               std::to_string(imageFiles.size()) + 
                               " - Filename: " + fileData.filename + 
                               ", Size: " + std::to_string(fileData.content.size()) + " bytes");
                    
                    // 【步骤6.1】验证文件类型
                    if (fileData.content_type.find("image/") != 0) {
                        Logger::error("[CREATE POST] ✗ Invalid MIME type: " + fileData.content_type);
                        sendErrorResponse(res, 400, "只能上传图片文件");
                        return;
                    }
                    
                    // 【步骤6.2】验证文件大小（最大5MB）
                    const size_t MAX_SIZE = 5 * 1024 * 1024;
                    if (fileData.content.size() > MAX_SIZE) {
                        Logger::error("[CREATE POST] ✗ File too large: " + 
                                    std::to_string(fileData.content.size()) + " bytes");
                        sendErrorResponse(res, 400, "图片文件大小不能超过5MB");
                        return;
                    }
                    
                    // 【步骤6.3】保存到临时目录
                    std::string savedPath = saveUploadedFile(
                        fileData.content,
                        fileData.filename,
                        fileData.content_type
                    );
                    
                    if (savedPath.empty()) {
                        Logger::error("[CREATE POST] ✗ Failed to save image " + 
                                    std::to_string(i + 1));
                        sendErrorResponse(res, 500, "保存图片文件失败");
                        return;
                    }
                    
                    savedImagePaths.push_back(savedPath);
                    Logger::info("[CREATE POST] ✓ Image " + std::to_string(i + 1) + 
                               " saved - Path: " + savedPath);
                }
            } else {
                Logger::warning("[CREATE POST] ⚠ No image files found");
            }
        }
```

**saveUploadedFile辅助方法**：

```cpp
std::string PostHandler::saveUploadedFile(
    const std::string& content,
    const std::string& filename,
    const std::string& contentType
) {
    try {
        // 【步骤1】检测并解码Base64数据（如果是JSON格式）
        std::string actualContent = content;
        
        if (Base64Decoder::isBase64(content)) {
            Logger::info("[SAVE FILE] Detected Base64 encoded data");
            actualContent = Base64Decoder::decode(content);
            Logger::info("[SAVE FILE] ✓ Decoded - Size: " + 
                        std::to_string(actualContent.size()) + " bytes");
        }
        
        // 【步骤2】生成唯一文件名
        std::string extension = "";
        size_t dotPos = filename.find_last_of('.');
        if (dotPos != std::string::npos) {
            extension = filename.substr(dotPos);
        }
        
        auto now = std::chrono::system_clock::now();
        auto timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(
            now.time_since_epoch()
        ).count();
        
        std::string uniqueFilename = "upload_" + std::to_string(timestamp) + 
                                    "_" + std::to_string(rand() % 10000) + extension;
        
        // 【步骤3】确保临时目录存在
        std::string tempDir = "/tmp/knot_uploads";
        system(("mkdir -p " + tempDir).c_str());
        
        // 【步骤4】保存文件
        std::string tempPath = tempDir + "/" + uniqueFilename;
        std::ofstream file(tempPath, std::ios::binary);
        if (!file.is_open()) {
            Logger::error("[SAVE FILE] ✗ Failed to open file: " + tempPath);
            return "";
        }
        
        file.write(actualContent.data(), actualContent.size());
        file.close();
        
        Logger::info("[SAVE FILE] ✓ File saved - Path: " + tempPath);
        return tempPath;
        
    } catch (const std::exception& e) {
        Logger::error("[SAVE FILE] ✗ Exception: " + std::string(e.what()));
        return "";
    }
}
```

---

## 7. 第4层：业务逻辑层

业务逻辑层是整个架构的核心，负责封装复杂的业务流程，协调多个Repository和基础设施服务。

### 7.1 PostService类设计

**文件**：`src/core/post_service.h`

```cpp
class PostService {
public:
    PostService();
    ~PostService();
    
    /**
     * @brief 创建帖子
     * @param userId 用户ID
     * @param title 标题
     * @param description 描述
     * @param imagePaths 图片临时文件路径列表
     * @param tags 标签列表
     * @return PostCreateResult 创建结果
     */
    PostCreateResult createPost(
        int userId,
        const std::string& title,
        const std::string& description,
        const std::vector<std::string>& imagePaths,
        const std::vector<std::string>& tags
    );
    
private:
    std::unique_ptr<PostRepository> postRepo_;
    std::unique_ptr<ImageService> imageService_;
    std::unique_ptr<TagRepository> tagRepo_;
    std::unique_ptr<ImageRepository> imageRepo_;
    
    std::string generatePostId();  // 生成唯一ID
    bool validateImageCount(int count);  // 验证图片数量
    bool checkOwnership(const std::string& postId, int userId);  // 权限检查
};
```

### 7.2 创建帖子业务流程

**文件**：`src/core/post_service.cpp` (createPost方法)

#### 7.2.1 业务规则验证

```cpp
PostCreateResult PostService::createPost(
    int userId,
    const std::string& title,
    const std::string& description,
    const std::vector<std::string>& imagePaths,
    const std::vector<std::string>& tags
) {
    PostCreateResult result;
    
    try {
        Logger::info("Creating post for user ID: " + std::to_string(userId));
        
        // 【步骤1】验证标题
        if (title.empty() || title.length() > 255) {
            result.message = "标题长度必须在1-255字符之间";
            Logger::warning(result.message);
            return result;
        }
        
        // 【步骤2】验证描述
        if (description.length() > 5000) {
            result.message = "描述长度不能超过5000字符";
            Logger::warning(result.message);
            return result;
        }
        
        // 【步骤3】验证图片数量（业务核心规则）
        if (!validateImageCount(imagePaths.size())) {
            result.message = "图片数量必须在1-9张之间";
            Logger::warning(result.message);
            return result;
        }
```

**validateImageCount方法**：

```cpp
bool PostService::validateImageCount(int imageCount) {
    bool valid = (imageCount >= 1 && imageCount <= 9);
    if (!valid) {
        Logger::warning("Invalid image count: " + std::to_string(imageCount) + 
                       " (must be 1-9)");
    }
    return valid;
}
```

**业务规则总结**：
- 标题：必填，1-255字符
- 描述：可选，最多5000字符
- 图片：必须1-9张（核心业务约束）
- 标签：可选，无数量限制

#### 7.2.2 生成帖子业务ID

```cpp
        // 【步骤4】生成帖子ID
        std::string postId = generatePostId();
        
        Logger::info("Generated post ID: " + postId);
```

**generatePostId方法实现**：

```cpp
std::string PostService::generatePostId() {
    auto now = std::chrono::system_clock::now();
    auto time = std::chrono::system_clock::to_time_t(now);
    std::tm* tm = std::localtime(&time);
    
    // 计算年份和季度
    int year = tm->tm_year + 1900;    // 2025
    int quarter = (tm->tm_mon / 3) + 1;  // Q1/Q2/Q3/Q4
    
    // 生成6位随机字符串（大小写字母+数字）
    static const char alphanum[] =
        "0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";
    
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(0, sizeof(alphanum) - 2);
    
    std::string randomPart;
    for (int i = 0; i < 6; ++i) {
        randomPart += alphanum[dis(gen)];
    }
    
    // 拼接：POST_2025Q4_Abc123
    std::ostringstream oss;
    oss << "POST_" << year << "Q" << quarter << "_" << randomPart;
    
    return oss.str();
}
```

**ID格式示例**：
- `POST_2025Q1_A1b2C3` - 2025年第1季度
- `POST_2025Q4_Xyz789` - 2025年第4季度
- `POST_2026Q2_MnO4pQ` - 2026年第2季度

**设计优势**：
- ✅ 可读性强（包含时间信息）
- ✅ 唯一性高（62^6 ≈ 568亿种组合）
- ✅ 便于排序（按季度分区）
- ✅ 便于统计（可按季度聚合）

#### 7.2.3 构建Post对象

```cpp
        // 【步骤5】构建Post对象
        Post post;
        post.setPostId(postId);
        post.setUserId(userId);
        post.setTitle(title);
        post.setDescription(description);
        post.setImageCount(imagePaths.size());
        post.setStatus(PostStatus::APPROVED);  // 默认审核通过
        post.setLikeCount(0);
        post.setFavoriteCount(0);
        post.setViewCount(0);
```

**为什么默认审核通过？**
- 当前版本未实现内容审核机制
- 未来可集成第三方内容审核API
- 或者实现管理员手动审核功能

#### 7.2.4 创建帖子记录

```cpp
        // 【步骤6】创建帖子记录
        if (!postRepo_->createPost(post)) {
            result.message = "创建帖子记录失败";
            Logger::error(result.message);
            return result;
        }
        
        Logger::info("Post created with ID: " + postId + 
                    ", physical ID: " + std::to_string(post.getId()));
```

**关键点**：
- `post.getId()` 返回数据库自增ID（物理ID）
- `post.getPostId()` 返回业务逻辑ID（如`POST_2025Q4_Abc123`）
- Repository的`createPost`方法会自动设置物理ID

#### 7.2.5 处理图片上传

```cpp
        // 【步骤7】处理图片上传
        std::vector<Image> savedImages;
        int actualImageCount = 0;
        
        for (size_t i = 0; i < imagePaths.size(); i++) {
            Logger::info("Processing image " + std::to_string(i + 1) + "/" + 
                        std::to_string(imagePaths.size()));
            
            // 【步骤7.1】调用ImageService处理图片
            std::vector<std::string> emptyTags;
            ImageUploadResult imgResult = imageService_->uploadImage(
                userId,
                imagePaths[i],   // 临时文件路径
                title,           // 使用帖子标题作为图片标题
                "",              // 图片描述为空
                emptyTags        // 图片标签为空
            );
            
            if (!imgResult.success) {
                Logger::warning("Image processing failed: " + imgResult.message);
                continue;  // 跳过失败的图片，继续处理下一张
            }
            
            // 【步骤7.2】设置图片的postId和displayOrder
            Image image = imgResult.image;
            image.setPostId(post.getId());           // 关联帖子物理ID
            image.setDisplayOrder(actualImageCount);  // 图片顺序（0, 1, 2）
            
            // 【步骤7.3】保存图片记录到数据库
            if (!imageRepo_->createImage(image)) {
                Logger::warning("Failed to save image record: " + image.getImageId());
            } else {
                Logger::info("Image saved successfully: " + image.getImageId());
                savedImages.push_back(image);
                actualImageCount++;
            }
        }
```

**ImageService::uploadImage做了什么？**

1. **读取图片文件**：使用STB库读取临时文件
2. **验证图片格式**：检查是否为有效的JPEG/PNG/GIF/WebP
3. **压缩原图**：JPEG 80%质量压缩
4. **生成缩略图**：居中裁剪到300x300像素
5. **保存到文件系统**：`/var/uploads/images/2025Q4/`
6. **生成图片ID**：`IMG_2025Q4_Xyz789`
7. **返回Image对象**：包含文件路径、尺寸、大小等信息

**为什么允许部分图片失败？**
- 容错性：单张图片失败不应导致整个操作失败
- 用户体验：至少保留成功的图片
- 业务约束：最终验证至少有1张图片成功

#### 7.2.6 验证并更新图片数量（关键修复点）

```cpp
        // 【步骤8】验证至少有一张图片成功上传
        if (savedImages.empty()) {
            Logger::error("No images were successfully processed");
            // 回滚：删除刚创建的帖子记录
            postRepo_->deletePost(postId);
            result.message = "所有图片处理失败，帖子创建失败";
            return result;
        }
        
        // 【步骤9】🔧 关键修复：始终更新帖子的实际图片数量
        post.setImageCount(actualImageCount);
        postRepo_->updatePost(post);
        Logger::info("Updated post image count to: " + std::to_string(actualImageCount));
```

**这里解决了你提到的数据一致性问题！**

**问题原因**：
- 初始设置：`post.setImageCount(imagePaths.size())` - 假设3张
- 实际保存：可能只成功2张（1张处理失败）
- 数据库：`posts.image_count = 3`，但`images`表只有2条记录
- 结果：数据不一致

**修复方案**：
- 使用`actualImageCount`（实际成功保存的数量）
- 调用`postRepo_->updatePost(post)`同步更新数据库
- 确保`posts.image_count`与`images`表记录数一致

#### 7.2.7 关联标签

```cpp
        // 【步骤10】处理标签关联
        for (const auto& tagName : tags) {
            if (tagName.empty()) continue;
            
            Logger::info("Processing tag: " + tagName);
            
            // 【步骤10.1】查找标签是否存在
            auto tagOpt = tagRepo_->findByName(tagName);
            int tagId = 0;
            
            if (!tagOpt.has_value()) {
                // 【步骤10.2】标签不存在，创建新标签
                Tag newTag;
                newTag.setName(tagName);
                newTag.setUseCount(0);
                
                if (!tagRepo_->createTag(newTag)) {
                    Logger::warning("Failed to create tag: " + tagName);
                    continue;  // 跳过此标签，不影响帖子创建
                }
                
                // 重新查询获取标签ID
                tagOpt = tagRepo_->findByName(tagName);
                if (!tagOpt.has_value()) {
                    Logger::warning("Failed to retrieve created tag: " + tagName);
                    continue;
                }
            }
            
            tagId = tagOpt->getId();
            
            // 【步骤10.3】关联帖子和标签（插入post_tags表）
            if (!tagRepo_->linkPostTag(post.getId(), tagId)) {
                Logger::warning("Failed to link post and tag: " + tagName);
                continue;
            }
            
            // 【步骤10.4】增加标签使用次数
            tagRepo_->incrementUseCount(tagId);
            Logger::info("Tag linked successfully: " + tagName);
        }
```

**标签系统设计**：

**数据库表结构**：
```sql
-- tags表
CREATE TABLE tags (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) UNIQUE NOT NULL,
    use_count INT DEFAULT 0,
    INDEX idx_name (name),
    INDEX idx_use_count (use_count)
);

-- post_tags关联表
CREATE TABLE post_tags (
    post_id INT NOT NULL,
    tag_id INT NOT NULL,
    PRIMARY KEY (post_id, tag_id),
    FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,
    FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
);
```

**业务逻辑**：
- 标签不存在时自动创建
- 使用`use_count`统计标签热度
- 删除帖子时自动解除标签关联（级联删除）
- 标签失败不影响帖子创建（容错性）

#### 7.2.8 查询完整帖子信息

```cpp
        // 【步骤11】查询完整帖子信息（包含图片）
        auto postWithImages = postRepo_->findByPostIdWithImages(postId);
        if (!postWithImages.has_value()) {
            // 查询失败，使用原始post对象
            result.success = true;
            result.message = "帖子创建成功（图片加载失败）";
            result.post = post;
            Logger::warning("Post created but failed to load with images");
            return result;
        }
        
        // 【步骤12】返回成功结果
        result.success = true;
        result.message = "帖子创建成功";
        result.post = *postWithImages;  // 包含所有图片的完整Post对象
        Logger::info("Post created successfully: " + postId);
        return result;
        
    } catch (const std::exception& e) {
        result.message = "创建帖子异常: " + std::string(e.what());
        Logger::error(result.message);
        return result;
    }
}
```

**为什么要重新查询？**
- 确保返回的数据与数据库一致
- 获取完整的图片列表（包含文件路径、尺寸等）
- 获取用户逻辑ID（通过LEFT JOIN users表）
- 提供完整的帖子信息给前端

### 7.3 数据一致性保证方法

#### 7.3.1 recalculateImageCount方法

**文件**：`src/core/post_service.cpp`

```cpp
bool PostService::recalculateImageCount(const std::string& postId) {
    try {
        Logger::info("Recalculating image count for post: " + postId);
        
        // 【步骤1】验证帖子是否存在
        auto postOpt = postRepo_->findByPostId(postId);
        if (!postOpt.has_value()) {
            Logger::error("Post not found for image count recalculation: " + postId);
            return false;
        }
        
        // 【步骤2】获取实际的图片数量
        std::vector<Image> images = imageRepo_->findByPostId(postOpt->getId());
        int actualCount = static_cast<int>(images.size());
        
        // 【步骤3】更新图片数量
        if (updateImageCount(postId, actualCount)) {
            Logger::info("Image count recalculated successfully: " + postId + 
                        " -> " + std::to_string(actualCount));
            return true;
        } else {
            Logger::error("Failed to update image count after recalculation: " + postId);
            return false;
        }
        
    } catch (const std::exception& e) {
        Logger::error("Exception in recalculateImageCount: " + std::string(e.what()));
        return false;
    }
}
```

**使用场景**：
- 删除图片后重新计算
- 添加图片后重新计算
- 数据修复脚本

#### 7.3.2 事务保护（删除图片示例）

```cpp
bool PostService::removeImageFromPost(
    const std::string& postId,
    const std::string& imageId,
    int userId
) {
    Logger::info("Removing image from post: postId=" + postId + 
                ", imageId=" + imageId + 
                ", userId=" + std::to_string(userId));
    
    // 使用事务保护整个操作
    return executeInTransaction([this, postId, imageId, userId](MYSQL* conn) -> bool {
        // 【步骤1】验证帖子所有权
        if (!checkOwnership(postId, userId)) {
            Logger::warning("User " + std::to_string(userId) + 
                          " does not own post " + postId);
            return false;  // 事务会自动回滚
        }
        
        // 【步骤2】查询帖子信息
        auto postOpt = postRepo_->findByPostId(postId);
        if (!postOpt.has_value()) {
            Logger::error("Post not found: " + postId);
            return false;  // 事务会自动回滚
        }
        
        Post post = *postOpt;
        
        // 【步骤3】检查当前图片数量（至少要保留1张）
        int currentImageCount = post.getImageCount();
        if (currentImageCount <= 1) {
            Logger::warning("Cannot remove last image from post (minimum 1 required)");
            return false;  // 事务会自动回滚
        }
        
        // 【步骤4】删除图片
        if (!imageService_->deleteImage(imageId, userId)) {
            Logger::error("Failed to delete image: " + imageId);
            return false;  // 事务会自动回滚
        }
        
        // 【步骤5】重新计算并更新帖子的图片数量
        if (!recalculateImageCount(postId)) {
            Logger::error("Failed to recalculate post image count");
            return false;  // 事务会自动回滚
        }
        
        Logger::info("Image removed successfully from post: " + postId);
        return true;  // 提交事务
    });
}
```

**executeInTransaction实现**（第7层）：

```cpp
bool executeInTransaction(std::function<bool(MYSQL*)> operation) {
    ConnectionGuard connGuard(DatabaseConnectionPool::getInstance());
    if (!connGuard.isValid()) {
        return false;
    }
    
    MYSQL* conn = connGuard.get();
    
    // 开启事务
    if (mysql_query(conn, "START TRANSACTION") != 0) {
        return false;
    }
    
    // 执行操作
    bool success = operation(conn);
    
    // 提交或回滚
    if (success) {
        mysql_query(conn, "COMMIT");
    } else {
        mysql_query(conn, "ROLLBACK");
    }
    
    return success;
}
```

**事务优势**：
- ✅ 原子性：所有操作要么全部成功，要么全部失败
- ✅ 一致性：保证数据的完整性约束
- ✅ 隔离性：并发操作不会相互干扰
- ✅ 持久性：提交后数据永久保存

---

## 8. 第5层：数据访问层

数据访问层负责与数据库进行交互，屏蔽SQL细节，为上层提供面向对象的数据访问接口。

### 8.1 PostRepository类设计

**文件**：`src/database/post_repository.h`

```cpp
class PostRepository {
public:
    PostRepository();
    ~PostRepository() = default;
    
    /**
     * @brief 创建帖子记录
     * @param post 帖子对象（会自动设置id）
     * @return 成功返回true
     */
    bool createPost(Post& post);
    
    /**
     * @brief 根据业务ID查找帖子
     * @param postId 业务逻辑ID（如POST_2025Q4_ABC123）
     * @return Post对象（包含用户逻辑ID）
     */
    std::optional<Post> findByPostId(const std::string& postId);
    
    /**
     * @brief 根据业务ID查找帖子（包含图片）
     * @param postId 业务逻辑ID
     * @return Post对象（包含images）
     */
    std::optional<Post> findByPostIdWithImages(const std::string& postId);
    
    /**
     * @brief 更新帖子信息
     * @param post 帖子对象
     * @return 成功返回true
     */
    bool updatePost(const Post& post);
    
    /**
     * @brief 删除帖子（级联删除图片）
     * @param postId 业务逻辑ID
     * @return 成功返回true
     */
    bool deletePost(const std::string& postId);
};
```

### 8.2 创建帖子记录

**文件**：`src/database/post_repository.cpp`

```cpp
bool PostRepository::createPost(Post& post) {
    try {
        // 【步骤1】获取数据库连接（使用RAII）
        ConnectionGuard connGuard(DatabaseConnectionPool::getInstance());
        if (!connGuard.isValid()) {
            Logger::error("Failed to get database connection");
            return false;
        }
        
        // 【步骤2】准备预编译语句
        MySQLStatement stmt(connGuard.get());
        if (!stmt.isValid()) {
            return false;
        }
        
        const char* query = 
            "INSERT INTO posts (post_id, user_id, title, description, image_count, status) "
            "VALUES (?, ?, ?, ?, ?, ?)";
        
        if (mysql_stmt_prepare(stmt.get(), query, strlen(query)) != 0) {
            Logger::error("Failed to prepare statement: " + 
                         std::string(mysql_stmt_error(stmt.get())));
            return false;
        }
        
        // 【步骤3】绑定参数
        MYSQL_BIND bind[6];
        memset(bind, 0, sizeof(bind));
        
        // post_id (VARCHAR)
        bind[0].buffer_type = MYSQL_TYPE_STRING;
        bind[0].buffer = (char*)post.getPostId().c_str();
        bind[0].buffer_length = post.getPostId().length();
        
        // user_id (INT)
        int userId = post.getUserId();
        bind[1].buffer_type = MYSQL_TYPE_LONG;
        bind[1].buffer = &userId;
        
        // title (VARCHAR)
        bind[2].buffer_type = MYSQL_TYPE_STRING;
        bind[2].buffer = (char*)post.getTitle().c_str();
        bind[2].buffer_length = post.getTitle().length();
        
        // description (TEXT, 可为NULL)
        std::string description = post.getDescription();
        bool description_is_null = description.empty();
        bind[3].buffer_type = MYSQL_TYPE_STRING;
        bind[3].buffer = (char*)description.c_str();
        bind[3].buffer_length = description.length();
        bind[3].is_null = &description_is_null;  // 空值处理
        
        // image_count (INT)
        int imageCount = post.getImageCount();
        bind[4].buffer_type = MYSQL_TYPE_LONG;
        bind[4].buffer = &imageCount;
        
        // status (VARCHAR)
        std::string status = Post::statusToString(post.getStatus());
        bind[5].buffer_type = MYSQL_TYPE_STRING;
        bind[5].buffer = (char*)status.c_str();
        bind[5].buffer_length = status.length();
        
        // 【步骤4】绑定并执行
        if (mysql_stmt_bind_param(stmt.get(), bind) != 0) {
            Logger::error("Failed to bind parameters: " + 
                         std::string(mysql_stmt_error(stmt.get())));
            return false;
        }
        
        if (mysql_stmt_execute(stmt.get()) != 0) {
            Logger::error("Failed to execute statement: " + 
                         std::string(mysql_stmt_error(stmt.get())));
            return false;
        }
        
        // 【步骤5】获取自增ID
        post.setId(static_cast<int>(mysql_stmt_insert_id(stmt.get())));
        
        Logger::info("Post created successfully: " + post.getPostId());
        return true;
        
    } catch (const std::exception& e) {
        Logger::error("Exception in createPost: " + std::string(e.what()));
        return false;
    }
}
```

**关键技术点**：

1. **ConnectionGuard（RAII模式）**：
   ```cpp
   ConnectionGuard connGuard(DatabaseConnectionPool::getInstance());
   // 离开作用域时自动归还连接到连接池
   ```

2. **MySQLStatement（智能指针封装）**：
   ```cpp
   MySQLStatement stmt(connGuard.get());
   // 离开作用域时自动调用mysql_stmt_close
   ```

3. **预编译语句（防SQL注入）**：
   ```cpp
   // ❌ 错误：字符串拼接（SQL注入风险）
   std::string sql = "INSERT INTO posts (title) VALUES ('" + title + "')";
   
   // ✅ 正确：预编译语句 + 参数绑定
   const char* sql = "INSERT INTO posts (title) VALUES (?)";
   mysql_stmt_prepare(stmt, sql, strlen(sql));
   mysql_stmt_bind_param(stmt, bind);
   ```

4. **NULL值处理**：
   ```cpp
   bool description_is_null = description.empty();
   bind[3].is_null = &description_is_null;  // MySQL会插入NULL
   ```

5. **获取自增ID**：
   ```cpp
   int autoIncrementId = mysql_stmt_insert_id(stmt.get());
   post.setId(autoIncrementId);  // 设置物理ID供后续使用
   ```

### 8.3 查询帖子（包含用户逻辑ID）

```cpp
std::optional<Post> PostRepository::findByPostId(const std::string& postId) {
    try {
        ConnectionGuard connGuard(DatabaseConnectionPool::getInstance());
        if (!connGuard.isValid()) {
            return std::nullopt;
        }
        
        MySQLStatement stmt(connGuard.get());
        
        // 【关键SQL】使用LEFT JOIN获取用户逻辑ID
        const char* query =
            "SELECT "
            "  p.id, p.post_id, p.user_id, p.title, p.description, "
            "  p.image_count, p.like_count, p.favorite_count, p.view_count, "
            "  p.status, p.create_time, p.update_time, "
            "  COALESCE(u.user_id, '') AS user_logical_id, "  // 用户逻辑ID
            "  COALESCE(u.username, '') AS username "          // 用户昵称
            "FROM posts p "
            "LEFT JOIN users u ON p.user_id = u.id "
            "WHERE p.post_id = ?";
        
        // ... 省略绑定和执行代码
        
        // 【步骤：解析结果】
        if (mysql_stmt_fetch(stmt.get()) == 0) {
            Post post;
            post.setId(static_cast<int>(id));
            post.setPostId(std::string(post_id, post_id_length));
            post.setUserId(static_cast<int>(userId));
            post.setTitle(std::string(title, title_length));
            
            // 设置用户逻辑ID（v2.5.0新增）
            if (!userLogicalIdIsNull && userLogicalIdLength > 0) {
                post.setUserLogicalId(std::string(userLogicalId, userLogicalIdLength));
            }
            
            // 设置用户昵称（v2.5.1新增）
            if (!usernameIsNull && usernameLength > 0) {
                post.setUsername(std::string(username, usernameLength));
            }
            
            // ... 解析其他字段
            
            return post;
        }
        
        return std::nullopt;
        
    } catch (const std::exception& e) {
        Logger::error("Exception in findByPostId: " + std::string(e.what()));
        return std::nullopt;
    }
}
```

**SQL查询实际执行**：

```sql
SELECT 
  p.id, p.post_id, p.user_id, p.title, p.description,
  p.image_count, p.like_count, p.favorite_count, p.view_count,
  p.status, p.create_time, p.update_time,
  COALESCE(u.user_id, '') AS user_logical_id,
  COALESCE(u.username, '') AS username
FROM posts p
LEFT JOIN users u ON p.user_id = u.id
WHERE p.post_id = 'POST_2025Q4_Abc123';
```

**查询结果示例**：

| id | post_id | user_id | title | user_logical_id | username |
|----|---------|---------|-------|----------------|----------|
| 42 | POST_2025Q4_Abc123 | 7 | 我的第一篇帖子 | USR_2025Q4_Xyz789 | 张三 |

### 8.4 查询帖子（包含图片）

```cpp
std::optional<Post> PostRepository::findByPostIdWithImages(const std::string& postId) {
    try {
        // 【步骤1】先查询Post（包含用户信息）
        auto postOpt = findByPostId(postId);
        if (!postOpt.has_value()) {
            return std::nullopt;
        }
        
        Post post = postOpt.value();
        
        // 【步骤2】再查询Images（关联表）
        ImageRepository imageRepo;
        std::vector<Image> images = imageRepo.findByPostId(post.getId());
        
        // 【步骤3】添加图片到Post
        for (const auto& image : images) {
            post.addImage(image);
        }
        
        return post;
        
    } catch (const std::exception& e) {
        Logger::error("Exception in findByPostIdWithImages: " + std::string(e.what()));
        return std::nullopt;
    }
}
```

**查询流程**：

1. **第1次查询**：获取帖子基本信息
   ```sql
   SELECT p.*, u.user_id, u.username
   FROM posts p
   LEFT JOIN users u ON p.user_id = u.id
   WHERE p.post_id = 'POST_2025Q4_Abc123';
   ```

2. **第2次查询**：获取关联的所有图片
   ```sql
   SELECT image_id, file_url, thumbnail_url, display_order,
          width, height, mime_type, file_size, create_time
   FROM images
   WHERE post_id = 42
   ORDER BY display_order ASC;
   ```

3. **内存组装**：将图片列表添加到Post对象

**性能优化**：对于批量查询（如Feed流），使用`getRecentPostsWithImagesOptimized`方法，一次LEFT JOIN查询所有数据，避免N+1问题。

---

## 9. 第6层：安全层

### 9.1 JWTManager - 令牌管理

**文件**：`src/security/jwt_manager.h`

```cpp
class JWTManager {
public:
    JWTManager();
    
    /**
     * @brief 生成访问令牌
     * @param userId 用户ID
     * @return 访问令牌字符串
     */
    std::string generateAccessToken(int userId);
    
    /**
     * @brief 生成刷新令牌
     * @param userId 用户ID
     * @return 刷新令牌字符串
     */
    std::string generateRefreshToken(int userId);
    
    /**
     * @brief 验证访问令牌
     * @param token 令牌字符串
     * @return TokenValidationResult（包含valid和userId）
     */
    TokenValidationResult validateAccessToken(const std::string& token);
    
private:
    std::string secret_;  // JWT密钥（从config.json读取）
};

/**
 * @brief 令牌验证结果
 */
struct TokenValidationResult {
    bool valid;        // 是否有效
    int userId;        // 用户ID
    std::string error; // 错误信息
};
```

**文件**：`src/security/jwt_manager.cpp`

```cpp
#include "security/jwt_manager.h"
#include "utils/config_manager.h"
#include <jwt-cpp/jwt.h>

JWTManager::JWTManager() {
    // 从配置文件读取密钥
    secret_ = ConfigManager::getInstance().getJwtSecret();
}

std::string JWTManager::generateAccessToken(int userId) {
    auto now = std::chrono::system_clock::now();
    
    // 访问令牌有效期：1小时
    auto expireTime = now + std::chrono::hours(1);
    
    auto token = jwt::create()
        .set_issuer("knot-api")                                    // 签发者
        .set_type("JWT")                                           // 类型
        .set_issued_at(now)                                        // 签发时间
        .set_expires_at(expireTime)                                // 过期时间
        .set_payload_claim("user_id", jwt::claim(userId))          // 用户ID
        .sign(jwt::algorithm::hs256{secret_});                     // HMAC-SHA256签名
    
    return token;
}

TokenValidationResult JWTManager::validateAccessToken(const std::string& token) {
    TokenValidationResult result;
    result.valid = false;
    result.userId = 0;
    
    try {
        // 【步骤1】解码令牌
        auto decoded = jwt::decode(token);
        
        // 【步骤2】创建验证器
        auto verifier = jwt::verify()
            .allow_algorithm(jwt::algorithm::hs256{secret_})  // 验证算法和密钥
            .with_issuer("knot-api");                          // 验证签发者
        
        // 【步骤3】验证签名和过期时间
        verifier.verify(decoded);
        
        // 【步骤4】提取user_id
        if (decoded.has_payload_claim("user_id")) {
            result.userId = decoded.get_payload_claim("user_id").as_int();
            result.valid = true;
        } else {
            result.error = "Missing user_id claim";
        }
        
    } catch (const jwt::token_verification_exception& e) {
        result.error = "Token verification failed: " + std::string(e.what());
    } catch (const std::exception& e) {
        result.error = "Token validation error: " + std::string(e.what());
    }
    
    return result;
}
```

**JWT令牌结构**：

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJrbm90LWFwaSIsImlhdCI6MTY5NzgxMjIxNSwiZXhwIjoxNjk3ODE1ODE1LCJ1c2VyX2lkIjo3fQ.signature

Header（Base64）         Payload（Base64）                     Signature（HMAC-SHA256）
```

**解码后的Payload**：

```json
{
  "iss": "knot-api",
  "iat": 1697812215,
  "exp": 1697815815,
  "user_id": 7
}
```

**安全特性**：
- ✅ HMAC-SHA256签名，防止令牌篡改
- ✅ 有效期检查，自动拒绝过期令牌
- ✅ 签发者验证，防止伪造令牌
- ✅ 密钥存储在配置文件，生产环境必须修改

### 9.2 PasswordHasher - 密码哈希

**文件**：`src/security/password_hasher.h`

```cpp
class PasswordHasher {
public:
    /**
     * @brief 哈希密码
     * @param password 原始密码
     * @return 哈希结果（包含盐值，格式：salt$hash）
     */
    static std::string hashPassword(const std::string& password);
    
    /**
     * @brief 验证密码
     * @param password 原始密码
     * @param hashedPassword 哈希结果
     * @return 密码是否匹配
     */
    static bool verifyPassword(const std::string& password, 
                               const std::string& hashedPassword);
};
```

**实现**：

```cpp
#include <openssl/evp.h>
#include <openssl/rand.h>

std::string PasswordHasher::hashPassword(const std::string& password) {
    // 【步骤1】生成随机盐值（16字节）
    unsigned char salt[16];
    RAND_bytes(salt, sizeof(salt));
    
    // 【步骤2】PBKDF2-HMAC-SHA256哈希
    unsigned char hash[32];
    PKCS5_PBKDF2_HMAC(
        password.c_str(), password.length(),  // 密码
        salt, sizeof(salt),                   // 盐值
        100000,                                // 迭代次数（100,000）
        EVP_sha256(),                          // 哈希算法
        sizeof(hash), hash                     // 输出
    );
    
    // 【步骤3】转换为Hex字符串
    std::string saltHex = bytesToHex(salt, sizeof(salt));
    std::string hashHex = bytesToHex(hash, sizeof(hash));
    
    // 【步骤4】拼接：salt$hash
    return saltHex + "$" + hashHex;
}

bool PasswordHasher::verifyPassword(
    const std::string& password,
    const std::string& hashedPassword
) {
    // 【步骤1】分离盐值和哈希
    size_t pos = hashedPassword.find('$');
    if (pos == std::string::npos) {
        return false;
    }
    
    std::string saltHex = hashedPassword.substr(0, pos);
    std::string storedHashHex = hashedPassword.substr(pos + 1);
    
    // 【步骤2】使用相同的盐值重新哈希
    unsigned char salt[16];
    hexToBytes(saltHex, salt, sizeof(salt));
    
    unsigned char newHash[32];
    PKCS5_PBKDF2_HMAC(
        password.c_str(), password.length(),
        salt, sizeof(salt),
        100000,
        EVP_sha256(),
        sizeof(newHash), newHash
    );
    
    std::string newHashHex = bytesToHex(newHash, sizeof(newHash));
    
    // 【步骤3】比较哈希值
    return newHashHex == storedHashHex;
}
```

**密码哈希示例**：

```
原始密码：mypassword123
盐值（Hex）：a1b2c3d4e5f67890a1b2c3d4e5f67890
哈希（Hex）：f3e2d1c0b9a8f7e6d5c4b3a2918f0e8d7c6b5a49382716f5e4d3c2b1a0f9e8d7
存储格式：a1b2c3d4e5f67890a1b2c3d4e5f67890$f3e2d1c0b9a8f7e6d5c4b3a2918f0e8d7c6b5a49382716f5e4d3c2b1a0f9e8d7
```

**安全特性**：
- ✅ 每个用户独立盐值，防止彩虹表攻击
- ✅ 100,000次迭代，增加暴力破解成本
- ✅ SHA-256算法，密码学安全
- ✅ 盐值和哈希一起存储，方便验证

---

## 10. 第7层：基础设施层

### 10.1 ConnectionPool - 数据库连接池

**文件**：`src/database/connection_pool.h`

```cpp
class DatabaseConnectionPool {
public:
    static DatabaseConnectionPool& getInstance();
    
    /**
     * @brief 获取数据库连接
     * @return MYSQL连接指针，失败返回nullptr
     */
    MYSQL* getConnection();
    
    /**
     * @brief 归还连接到连接池
     * @param conn MYSQL连接指针
     */
    void returnConnection(MYSQL* conn);
    
private:
    std::vector<MYSQL*> connections_;       // 连接列表
    std::queue<MYSQL*> availableConnections_; // 可用连接队列
    std::mutex mutex_;                      // 互斥锁
    std::condition_variable condition_;     // 条件变量
    int poolSize_;                          // 连接池大小
};
```

**实现**：

```cpp
DatabaseConnectionPool& DatabaseConnectionPool::getInstance() {
    static DatabaseConnectionPool instance;
    return instance;
}

MYSQL* DatabaseConnectionPool::getConnection() {
    std::unique_lock<std::mutex> lock(mutex_);
    
    // 【步骤1】等待可用连接
    condition_.wait(lock, [this] {
        return !availableConnections_.empty();
    });
    
    // 【步骤2】从队列取出连接
    MYSQL* conn = availableConnections_.front();
    availableConnections_.pop();
    
    // 【步骤3】检查连接是否存活
    if (mysql_ping(conn) != 0) {
        Logger::warning("Connection lost, reconnecting...");
        mysql_close(conn);
        conn = createConnection();  // 重新创建连接
    }
    
    return conn;
}

void DatabaseConnectionPool::returnConnection(MYSQL* conn) {
    std::unique_lock<std::mutex> lock(mutex_);
    
    // 归还连接到队列
    availableConnections_.push(conn);
    
    // 通知等待的线程
    condition_.notify_one();
}
```

**连接池工作流程**：

**文本版本**：

```
初始化：创建10个MySQL连接，全部放入availableConnections_队列

┌─────────────┐
│ Thread 1    │────getConnection()───→ 从队列取出conn1
└─────────────┘                         ↓
                                    使用conn1查询
                                        ↓
                                    returnConnection(conn1)
                                        ↓
                                    conn1回到队列

┌─────────────┐
│ Thread 2    │────getConnection()───→ 等待（队列为空）
└─────────────┘                         ↓
                                    Thread 1归还后
                                        ↓
                                    获取conn1（被唤醒）
```

**Mermaid版本**（支持Mermaid的环境可渲染）：

```mermaid
graph TB
    Init["初始化：创建10个MySQL连接<br/>全部放入availableConnections_队列"]
    
    T1Start["Thread 1: getConnection()"]
    T1Get["从队列取出conn1"]
    T1Use["使用conn1查询"]
    T1Return["returnConnection(conn1)"]
    T1Back["conn1回到队列"]
    
    T2Start["Thread 2: getConnection()"]
    T2Wait["等待（队列为空）"]
    T2Wake["Thread 1归还后"]
    T2Get["获取conn1（被唤醒）"]
    
    Init --> T1Start
    Init --> T2Start
    T1Start --> T1Get
    T1Get --> T1Use
    T1Use --> T1Return
    T1Return --> T1Back
    T1Back -.通知.-> T2Wake
    
    T2Start --> T2Wait
    T2Wait --> T2Wake
    T2Wake --> T2Get
```

**优势**：
- ✅ 避免频繁创建/销毁连接（昂贵操作）
- ✅ 限制最大连接数，防止数据库过载
- ✅ 自动重连机制，提高可用性
- ✅ 线程安全，支持并发访问

### 10.2 Logger - 日志系统

**文件**：`src/utils/logger.h`

```cpp
class Logger {
public:
    static void init(const std::string& logFile);
    
    static void debug(const std::string& message);
    static void info(const std::string& message);
    static void warning(const std::string& message);
    static void error(const std::string& message);
    static void fatal(const std::string& message);
};
```

**基于spdlog实现**：

```cpp
#include <spdlog/spdlog.h>
#include <spdlog/sinks/rotating_file_sink.h>
#include <spdlog/sinks/stdout_color_sinks.h>

void Logger::init(const std::string& logFile) {
    // 【步骤1】创建文件日志（每10MB轮换，保留3个文件）
    auto fileSink = std::make_shared<spdlog::sinks::rotating_file_sink_mt>(
        logFile, 10 * 1024 * 1024, 3
    );
    
    // 【步骤2】创建控制台日志（彩色输出）
    auto consoleSink = std::make_shared<spdlog::sinks::stdout_color_sink_mt>();
    
    // 【步骤3】组合两个sink
    std::vector<spdlog::sink_ptr> sinks {fileSink, consoleSink};
    auto logger = std::make_shared<spdlog::logger>("main", sinks.begin(), sinks.end());
    
    // 【步骤4】设置日志级别和格式
    logger->set_level(spdlog::level::debug);
    logger->set_pattern("[%Y-%m-%d %H:%M:%S.%e] [%^%l%$] [%t] %v");
    
    // 【步骤5】设置为默认logger
    spdlog::set_default_logger(logger);
}

void Logger::info(const std::string& message) {
    spdlog::info(message);
}
```

**日志输出示例**：

```
[2025-10-20 14:30:15.123] [info] [1234] Creating post for user ID: 7
[2025-10-20 14:30:15.156] [info] [1234] Generated post ID: POST_2025Q4_Abc123
[2025-10-20 14:30:15.189] [info] [1234] Processing image 1/3
[2025-10-20 14:30:15.456] [info] [1234] Image saved successfully: IMG_2025Q4_Xyz789
[2025-10-20 14:30:15.489] [info] [1234] Post created successfully: POST_2025Q4_Abc123
```

**日志级别**：
- `debug`：调试信息（开发环境）
- `info`：正常流程信息
- `warning`：警告信息（可恢复错误）
- `error`：错误信息（操作失败）
- `fatal`：致命错误（程序崩溃）

---

## 11. 第8层：数据模型层

### 11.1 Post模型类

**文件**：`src/models/post.h`

```cpp
enum class PostStatus {
    PENDING,     // 待审核
    APPROVED,    // 已通过
    REJECTED     // 已拒绝
};

class Post {
public:
    Post();
    ~Post() = default;
    
    // Getters
    int getId() const { return id_; }
    const std::string& getPostId() const { return postId_; }
    int getUserId() const { return userId_; }
    const std::string& getUserLogicalId() const { return userLogicalId_; }
    const std::string& getUsername() const { return username_; }
    const std::string& getTitle() const { return title_; }
    // ... 其他getters
    
    // Setters
    void setId(int id) { id_ = id; }
    void setPostId(const std::string& postId) { postId_ = postId; }
    // ... 其他setters
    
    /**
     * @brief 添加图片到帖子
     */
    void addImage(const Image& image);
    
    /**
     * @brief 转换为JSON
     * @param includeImages 是否包含图片列表
     */
    Json::Value toJson(bool includeImages = true) const;
    
    /**
     * @brief 从JSON创建Post对象
     */
    static Post fromJson(const Json::Value& json);
    
    /**
     * @brief 数据验证
     */
    std::string validate() const;
    
private:
    int id_;                      // 物理ID（自增主键）
    std::string postId_;          // 业务逻辑ID
    int userId_;                  // 发布用户物理ID
    std::string userLogicalId_;   // 发布用户逻辑ID
    std::string username_;        // 发布用户昵称
    std::string title_;           // 标题
    std::string description_;     // 描述
    int imageCount_;              // 图片数量
    int likeCount_;               // 点赞数
    int favoriteCount_;           // 收藏数
    int commentCount_;            // 评论数
    int viewCount_;               // 浏览数
    PostStatus status_;           // 审核状态
    std::time_t createTime_;      // 创建时间
    std::time_t updateTime_;      // 更新时间
    std::vector<Image> images_;   // 关联的图片列表
};
```

### 11.2 toJson实现

**文件**：`src/models/post.cpp`

```cpp
Json::Value Post::toJson(bool includeImages) const {
    Json::Value json;
    
    json["id"] = id_;
    json["post_id"] = postId_;
    json["user_id"] = userLogicalId_;  // 返回逻辑ID（前端使用）
    json["username"] = username_;      // 返回用户昵称
    json["title"] = title_;
    json["description"] = description_;
    json["image_count"] = imageCount_;
    json["like_count"] = likeCount_;
    json["favorite_count"] = favoriteCount_;
    json["comment_count"] = commentCount_;
    json["view_count"] = viewCount_;
    json["status"] = statusToString(status_);
    json["create_time"] = static_cast<Json::Int64>(createTime_);
    json["update_time"] = static_cast<Json::Int64>(updateTime_);
    
    // 添加封面图片URL
    std::string coverUrl = getCoverImageUrl();
    if (!coverUrl.empty()) {
        json["cover_image_url"] = coverUrl;
    }
    
    // 如果需要包含图片列表
    if (includeImages && !images_.empty()) {
        Json::Value imagesArray(Json::arrayValue);
        for (const auto& image : images_) {
            imagesArray.append(image.toJson());  // 调用Image::toJson()
        }
        json["images"] = imagesArray;
    }
    
    return json;
}
```

**JSON输出示例**：

```json
{
  "id": 42,
  "post_id": "POST_2025Q4_Abc123",
  "user_id": "USR_2025Q4_Xyz789",
  "username": "张三",
  "title": "我的第一篇帖子",
  "description": "今天天气真好！",
  "image_count": 3,
  "like_count": 0,
  "favorite_count": 0,
  "comment_count": 0,
  "view_count": 0,
  "status": "APPROVED",
  "create_time": 1697812215,
  "update_time": 1697812215,
  "cover_image_url": "https://api.knot.com/uploads/images/2025Q4/IMG_2025Q4_001_thumb.jpg",
  "images": [
    {
      "image_id": "IMG_2025Q4_001",
      "display_order": 0,
      "file_url": "https://api.knot.com/uploads/images/2025Q4/IMG_2025Q4_001.jpg",
      "thumbnail_url": "https://api.knot.com/uploads/images/2025Q4/IMG_2025Q4_001_thumb.jpg",
      "width": 1920,
      "height": 1080,
      "mime_type": "image/jpeg",
      "file_size": 524288,
      "create_time": 1697812215
    }
  ]
}
```

---

## 12. 第9层：数据库层

### 12.1 数据库表结构

#### 12.1.1 posts表

**文件**：`config/database.sql`

```sql
CREATE TABLE posts (
    id INT PRIMARY KEY AUTO_INCREMENT COMMENT '物理ID',
    post_id VARCHAR(255) UNIQUE NOT NULL COMMENT '业务逻辑ID (POST_2025Q4_Abc123)',
    user_id INT NOT NULL COMMENT '发布用户ID (外键)',
    title VARCHAR(255) NOT NULL COMMENT '标题',
    description TEXT COMMENT '描述',
    image_count INT DEFAULT 0 COMMENT '图片数量',
    like_count INT DEFAULT 0 COMMENT '点赞数',
    favorite_count INT DEFAULT 0 COMMENT '收藏数',
    comment_count INT DEFAULT 0 COMMENT '评论数',
    view_count INT DEFAULT 0 COMMENT '浏览数',
    status VARCHAR(20) DEFAULT 'APPROVED' COMMENT '审核状态',
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    INDEX idx_post_id (post_id),
    INDEX idx_user_id (user_id),
    INDEX idx_status (status),
    INDEX idx_create_time (create_time),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='帖子信息表';
```

**关键设计点**：

1. **双ID设计**：
   - `id`：物理ID（自增主键），用于数据库内部关联
   - `post_id`：业务逻辑ID，用于API和前端展示

2. **索引策略**：
   - `idx_post_id`：支持API查询（WHERE post_id = ?）
   - `idx_user_id`：支持用户帖子列表（WHERE user_id = ?）
   - `idx_status`：支持按状态筛选
   - `idx_create_time`：支持时间排序（ORDER BY create_time DESC）

3. **外键级联删除**：
   - 删除用户时自动删除该用户的所有帖子
   - `ON DELETE CASCADE`

---

## 13. 关键设计模式

### 13.1 RAII（Resource Acquisition Is Initialization）

**原理**：资源的获取和释放绑定到对象的生命周期。

**应用场景**：数据库连接管理

```cpp
class ConnectionGuard {
public:
    explicit ConnectionGuard(DatabaseConnectionPool& pool)
        : pool_(pool), conn_(pool.getConnection()) {
        Logger::debug("Connection acquired");
    }
    
    ~ConnectionGuard() {
        if (conn_) {
            pool_.returnConnection(conn_);
            Logger::debug("Connection returned");
        }
    }
    
    MYSQL* get() const { return conn_; }
    bool isValid() const { return conn_ != nullptr; }
    
    // 禁止拷贝和赋值
    ConnectionGuard(const ConnectionGuard&) = delete;
    ConnectionGuard& operator=(const ConnectionGuard&) = delete;
    
private:
    DatabaseConnectionPool& pool_;
    MYSQL* conn_;
};
```

**优势**：
- ✅ 自动资源管理，防止泄漏
- ✅ 异常安全，即使抛出异常也能正确释放
- ✅ 代码简洁，无需手动释放

---

## 14. 总结与学习路径

### 14.1 核心要点回顾

**九层架构的精髓**：
1. **职责清晰**：每层只做自己该做的事
2. **单向依赖**：只能上层调用下层
3. **低耦合**：通过接口和数据模型交互
4. **高内聚**：相关功能集中在同一层

**创建帖子API的关键技术**：
1. **JWT认证**：安全的身份验证机制
2. **multipart/JSON双格式支持**：适应不同客户端
3. **图片处理**：压缩、缩略图、格式转换
4. **数据库事务**：保证数据一致性
5. **RAII模式**：自动资源管理
6. **预编译语句**：防止SQL注入
7. **连接池**：提升数据库性能
8. **双ID设计**：物理ID + 业务逻辑ID

### 14.2 新人学习路径

**第1周：熟悉基础设施层（第7层）**
- 学习连接池的工作原理
- 理解RAII模式
- 熟悉日志系统的使用

**第2周：掌握数据模型层（第8层）和数据访问层（第5层）**
- 学习Post、Image模型类
- 理解Repository的设计
- 练习编写预编译SQL语句

**第3周：学习业务逻辑层（第4层）**
- 研究PostService的实现
- 理解业务规则验证
- 学习事务管理

**第4周：理解API接口层（第3层）**
- 学习Handler的路由注册
- 理解JWT验证流程
- 练习响应封装

**第5周：综合实战**
- 独立实现一个简单API（如获取帖子详情）
- 从Handler → Service → Repository → Database
- 完成单元测试

### 14.3 结语

通过本文档，你已经学习了：
- ✅ 九层架构的设计理念和实现细节
- ✅ 创建帖子API的完整流程（27个步骤）
- ✅ 关键设计模式（RAII、单例、分层、工厂、策略）
- ✅ 性能优化策略（异步处理、批量插入、索引优化）
- ✅ 常见问题和最佳实践

**下一步**：
1. 阅读实际代码，对照文档理解
2. 尝试运行项目，观察日志输出
3. 修改代码，验证你的理解
4. 参考本文档实现新功能

**记住**：好的架构不是一天建成的，需要不断实践和优化。祝你在Knot项目中学习愉快！🚀

---

**文档作者**: Knot Team  
**最后更新**: 2025-10-20  
**文档版本**: v1.0  
**适用项目版本**: v2.7.0+

如有疑问，请查阅其他项目文档或联系项目负责人。

